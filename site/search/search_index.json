{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programmieren II \u00b6 Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis mordenen Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das genaze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df! Organisatorisches \u00b6 Der (Corona-)Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und anhand von Videos eingef\u00fchrt und verdeutlicht, das Skript und die Videos werden (sp\u00e4testens) freitags hochgeladen, das hei\u00dft, \"Vorlesungen\" finden asynchron statt (im Selbststudium), zusammen mit dem Skript und den Videos werden sowohl die \u00dcbung als auch die Aufgabe hochgeladen, die \u00dcbung (und die vergangene Aufgabe) werden donnerstags (8:00 Uhr und nochmal 14:00 Uhr) besprochen (Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie w\u00e4hlen), bei Bedarf k\u00f6nnen wir auch gerne jederzeit eine Synchron-Video-Vorlesung einschieben, um Fragen zu erkl\u00e4ren, die Veranstaltung wird durch ein Tutorium unterst\u00fctzt, sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf GitHub hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt! Grober Inhalt (kann sich noch \u00e4ndern) \u00b6 Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Die Vorlesungsvideos finden Sie darunter f\u00fcr die einzelnen Wochen (unter Inhalte ). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 05.-09.04.2021 Einf\u00fchrung und Organisatorisches, Wiederholung - - - 1. 12.-16.04.2021 Git \u00dcbung 1 Aufgabe 1 25.04.2021 2. 19.-23.04.2021 Enumerations und Exceptions \u00dcbung 2 Aufgabe 2 02.05.2021 3. 26.-30.04.2021 Testen mit JUnit \u00dcbung 3 Aufgabe 3 09.05.2021 4. 03.-07.05.2021 Collections (List und Set) \u00dcbung 4 Aufgabe 4 16.05.2021 5. 10.-14.05.2021 Wrapper-Klassen (boxing und unboxing) \u00dcbung 5 Aufgabe 5 23.05.2021 6. 17.-21.05.2021 Collections (Map) + Abstrakte Klassen \u00dcbung 6 - - 7. 24.-28.05.2021 Interfaces \u00dcbung 7 Aufgabe 6 06.06.2021 8. 31.-04.06.2021 GUI \u00dcbung 8 Aufgabe 7 13.06.2021 9. 07.-11.06.2021 Ereignisse \u00dcbung 9 Aufgabe 8 20.06.2021 10. 14.-18.06.2021 Dialoge und Graphics \u00dcbung 10 Aufgabe 9 04.07.2021 12. 21.-25.06.2021 Neuerungen in Java 10-14 \u00dcbung 11 - - 13. 28.-02.07.2021 - \u00dcbung 12 - - 14. 05.-09.07.2021 Klausurvorbereitung \u00dcbung 13 - - 15. 12.-16.07.2021 Klausurvorbereitung - - - Inhalte \u00b6 05.-09.04.2021 - Einf\u00fchrung und Organisatorisches + Wiederholung siehe Organisatorisches siehe Wiederholung siehe Aufgabe 1 12.-16.04.2021 - Git siehe Git Video zu Git siehe \u00dcbung 1 siehe Aufgabe 2 19.-23.04.2021 - Enum und Exceptions siehe Mehrdimensionale Arrays und Aufz\u00e4hlungstypen Video zu Mehrdimensionale Arrays und Aufz\u00e4hlungstypen siehe Exceptions Video zu Exceptions - das ist Teil 1 (Einf\u00fchrung) noch ein Video zu Exceptions - das ist Teil 2 (eigene Exceptions) siehe \u00dcbung 2 siehe Aufgabe 3 26.-30.04.2021 - Testen mit JUnit siehe auch Teil 2 des Videos zu Exceptions (unter 19.-23.04.2021 - Enum und Exceptions eins dr\u00fcber) - das kam erst diese Woche hinzu, deshalb hier der Verweis, geh\u00f6rt aber thematisch in die Woche davor, deshalb dort siehe JUnit-Tests siehe Video zu JUnit-Tests siehe \u00dcbung 3 siehe Aufgabe 4 Video aus der Vorlesung vom 28.04.2021 Quellcode aus der Vorlesung vom 28.04.2021 MyMath.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package vorlesungen.testen ; public class MyMath { public static int abs ( int number ) { if ( number < 0 ) { return - number ; } else { return number ; } } public static double abs ( double number ) { if ( number < 0 ) { return - number ; } else { return number ; } } public static double sqrt ( double number ) { double a = number ; double b = 1.0 ; final double AREA = number ; final double ERROR = 0.000001 ; while ( abs ( a - b ) >= ERROR ) { a = ( a + b ) / 2.0 ; b = AREA / a ; } return a ; } public static int ggT ( int a , int b ) { while ( b != 0 ) { int rest = a % b ; a = b ; b = rest ; } return a ; } } MyMathTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package vorlesungen.testen ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class MyMathTest { @Test void testAbs3 () { int result = MyMath . abs ( 3 ); assertEquals ( 3 , result , \"abs(3) not 3\" ); } @Test void testAbsMinus3 () { int result = MyMath . abs ( - 3 ); assertEquals ( 3 , result , \"abs(-3) not 3\" ); } @Test void testSqrt9 () { double result = MyMath . sqrt ( 9.0 ); assertEquals ( 3.0 , result , 0.00001 ); } @Test void testSqrt25 () { double result = MyMath . sqrt ( 25.0 ); assertTrue ( MyMath . abs ( 5.0 - result ) <= 0.00001 ); } @Test void testGgT44und12 () { int result = MyMath . ggT ( 44 , 12 ); assertEquals ( 4 , result , \"ggT of 44 and 12 not 4\" ); } } module-info.java 1 2 3 4 module SoSe2021 { requires java . desktop ; requires org . junit . jupiter . api ; } 03.-07.05.2021 - Collections (List und Set) siehe Collections siehe Video zu Collections - Vorlesung 05.05.2021 Quellcode aus der Vorlesung vom 05.05.2021 ListenUndMengen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 package vorlesungen.listenmengen ; import java.util.* ; /* * Collections: aehnlich wie Arrays, viele Elemente speichern * keine feste Laenge * wir koennen nur Referenztypen speichern (also nicht int, boolean, char, double, ...) * Elemente verschiedenen Typs speicherbar --> gar nicht gut, deshalb Typisieren * Arten von Collections: List (wie Arrays), Set (keine Doppelungen), Stack, Queue * Map (2-spaltige Tabellen Schl\u00fcssel-/Werte-Paare) */ public class ListenUndMengen { public static void main ( String [] args ) { System . out . printf ( \"%n%n-------------- Listen ------------------%n%n\" ); Set < String > set1 = new HashSet <> (); Set < String > set2 = new TreeSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; Integer i1 = 1 ; System . out . println ( set1 . add ( s1 )); System . out . println ( set1 . add ( s2 )); System . out . println ( set1 . add ( s3 )); System . out . println ( set1 . add ( s4 )); // System.out.println(set1.add(i1)); System . out . println ( set1 . size ()); Iterator < String > it = set1 . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } System . out . println (); for ( String element : set1 ) { System . out . println ( element ); } System . out . println ( set1 . remove ( \"erster\" )); System . out . println ( set1 . remove ( \"vierter\" )); System . out . println (); for ( String element : set1 ) { System . out . println ( element ); } System . out . printf ( \"%n%n-------------- Listen ------------------%n%n\" ); List < String > l1 = new ArrayList <> (); List < String > l2 = new LinkedList <> (); l1 . add ( s1 ); l1 . add ( s2 ); l1 . add ( s3 ); l1 . add ( s4 ); for ( String s : l1 ) { System . out . println ( s ); } System . out . println ( l1 . size ()); System . out . println ( l1 . remove ( \"zweiter\" )); System . out . println ( l1 . remove ( \"vierter\" )); for ( String s : l1 ) { System . out . println ( s ); } System . out . println (); System . out . println ( \"geloescht : \" + l1 . remove ( 1 )); for ( String s : l1 ) { System . out . println ( s ); } System . out . println (); l2 . add ( \"neu\" ); l2 . add ( \"alt\" ); for ( String s : l2 ) { System . out . println ( s ); } System . out . println (); l1 . addAll ( l2 ); for ( String s : l1 ) { System . out . println ( s ); } System . out . println (); l1 . removeAll ( l2 ); for ( String s : l1 ) { System . out . println ( s ); } } } siehe \u00dcbung 5 siehe Aufgabe 5 10.-14.05.2021 - Wrapper-Klassen (boxing und unboxing) siehe Wrapper-Klassen siehe Video zu Wrapper-Klassen - Vorlesung 12.05.2021 diese Woche keine neue \u00dcbung (Donnerstag ist Feiertag) diese Woche keine neue Aufgabe (M\u00f6glichkeit, bisher \"Liegengebliebenes\" aufzuarbeiten) L\u00f6sungen f\u00fcr Aufgaben 1 - 3 hochgeladen 17.-21.05.2021 - Collections (Map) siehe Maps siehe Video zu Maps - Vorlesung 19.05.2021 Quellcode aus der Vorlesung vom 19.05.2021 Maps.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 package vorlesungen.maps ; import java.util.* ; public class Maps { public static void main ( String [] args ) { /* * in Maps speichern wir Schluessel-Werte-Paare * Schluessel sind eindeutig, Schluesseltyp K * Werte koennen sich doppel, Wertetyp V * statt add(), addAll() hier put(), putAll() */ Map < String , Integer > mapA = new HashMap <> (); mapA . put ( \"A\" , 1 ); mapA . put ( \"B\" , 2 ); mapA . put ( \"C\" , 3 ); /* * ein einzelnes Schluessel-Werte-Paar ist vom * Typ Map.Entry * typisiert: Map.Entry<K,V> * unser Beispiel: Map.Entry<String, Integer> */ /* * leider nicht iterator(), sondern entrySet() * entrySet() erzeugt eine Set von lauter Schluessel-Werte-Paaren */ // Variante 1 Set < Map . Entry < String , Integer >> allEntriesFromMapA = mapA . entrySet (); for ( Map . Entry < String , Integer > entry : allEntriesFromMapA ) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } System . out . println ( allEntriesFromMapA . size ()); // Iterator<Map.Entry<String, Integer>> it = allEntriesFromMapA.iterator(); System . out . println (); // Variante 2 for ( Map . Entry < String , Integer > entry : mapA . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } System . out . println ( mapA . containsKey ( \"B\" )); System . out . println ( mapA . containsKey ( \"D\" )); System . out . println ( mapA . get ( \"B\" )); System . out . printf ( \"%n%n------------ alle keys von mapA ---------------%n%n\" ); Set < String > allKeys = mapA . keySet (); for ( String key : allKeys ) { System . out . println ( \"key : \" + key ); } System . out . printf ( \"%n%n------------ mapA ---------------%n%n\" ); mapA . put ( \"B\" , 5 ); for ( Map . Entry < String , Integer > entry : mapA . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } System . out . printf ( \"%n%n------------ mapB ---------------%n%n\" ); Map < String , Integer > mapB = new HashMap <> (); mapB . put ( \"B\" , 6 ); mapB . put ( \"D\" , 7 ); for ( Map . Entry < String , Integer > entry : mapB . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } mapA . putAll ( mapB ); System . out . printf ( \"%n%n------------ mapA ---------------%n%n\" ); for ( Map . Entry < String , Integer > entry : mapA . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } mapA . put ( \"E\" , 1 ); System . out . printf ( \"%n%n------------ alle values von mapA ---------------%n%n\" ); Collection < Integer > allValues = mapA . values (); for ( Integer val : allValues ) { System . out . println ( \"value : \" + val ); } } } siehe \u00dcbung 6 siehe Aufgabe 6","title":"Home"},{"location":"#programmieren-ii","text":"Herzlich willkommen zur Programmieren II -Veranstaltung! Wir haben in Programmieren I unter Verwendung der Programmiersprache Java bereits wesentliche Konzepte kennengelernt, die f\u00fcr das Verst\u00e4ndnis mordenen Programmierens notwendig sind. Diese Kenntnisse wollen wir nun erweitern und vertiefen. Wir werden Git kennenlernen, Exceptions, Wrapper-Klassen, Interfaces und Collections. Wir besch\u00e4ftigen uns intensiv mit dem Testen von Programmen und erzeugen uns eigene Nutzeroberfl\u00e4chen. Hier einige Tipps, damit Sie die Veranstaltung erfolgreich durchf\u00fchren und Sie dabei auch Spa\u00df haben: L\u00f6sen Sie alle \u00dcbungsaufgaben selbst\u00e4ndig! Es ist kein Problem, wenn Sie f\u00fcr das Bew\u00e4ltigen der \u00dcbungen etwas l\u00e4nger ben\u00f6tigen. Sollten Sie es gar nicht alleine schaffen, ist das auch kein Problem. Wichtig ist dann, dass Sie sich die L\u00f6sung anschauen und es erneut selbst\u00e4ndig versuchen. H\u00f6ren Sie nicht auf, bis Sie es geschafft haben! Sie k\u00f6nnen die Hausaufgaben zu zweit l\u00f6sen. Achten Sie aber darauf, dass Sie Ihre gemeinsame L\u00f6sung vollst\u00e4ndig verstanden haben und dass Sie sie danach auch alleine erstellen k\u00f6nnen. Sie k\u00f6nnen beim L\u00f6sen der Hausaufgaben beliebig kreativ sein! Die Aufgabenstellung gibt Ihnen Anhaltspunkte f\u00fcr eine eventuelle L\u00f6sung. Sie k\u00f6nnen es aber auch ganz anders machen! Die Klausurvorbereitung beginnt mit Beginn der Veranstaltung. Es ist nicht m\u00f6glich, die Klausur am Ende des Semesters zu bestehen, wenn Sie nicht das ganze Semester \u00fcber intensiv programmieren. Die \u00dcbungsaufgaben sind \"kleine\" Aufgaben, um das in der Vorlesung vermittelte Wissen direkt anzuwenden. F\u00fcr die L\u00f6sung der Hausaufgaben ist bereits ein gewisses Abstraktionsniveau erforderlich, um zu erkennen, dass das in der Vorlesung vermittelte Wissen daf\u00fcr ausreichend ist. Programmieren lernt man nur durch Programmieren. Sie m\u00fcssen es tun. Das Lesen von B\u00fcchern oder das \"Anschauen\" von Code gen\u00fcgt nicht. Eine Sprache lernt man auch nur durch Sprechen. Sie m\u00fcssen programmieren, programmieren, prohgrammieren... Lassen Sie sich durch Fehler nicht verunsichern, sondern analysieren Sie Ihre Fehler. Bis zur Klausur sollten Sie alle Fehler einmal gemacht haben. Wenn Sie sich \u00fcberlegen, warum das jeweils ein Fehler war, dann werden Sie diesen Fehler nicht wiederholen und haben durch die Reflektion eine Menge gelernt. Fehler zu machen (und dar\u00fcber zu reflektieren) geh\u00f6rt zu den besten Lernmethoden des Programmierens. Haben Sie Spa\u00df! Je mehr Sie das Programmieren lernen, je mehr Spa\u00df werden Sie haben. Wir versuchen, dass Sie das genaze Semester \u00fcber Spa\u00df am Programmieren haben werden. Sollte es Ihnen zwischendurch keinen Spa\u00df mehr machen, geben Sie mir sofort Bescheid! Viel Erfolg! Und viel Spa\u00df!","title":"Programmieren II"},{"location":"#organisatorisches","text":"Der (Corona-)Plan zur Durchf\u00fchrung der Veranstaltung ist derzeit wie folgt: Themen werden ausf\u00fchrlich in diesem Skript beschrieben und anhand von Videos eingef\u00fchrt und verdeutlicht, das Skript und die Videos werden (sp\u00e4testens) freitags hochgeladen, das hei\u00dft, \"Vorlesungen\" finden asynchron statt (im Selbststudium), zusammen mit dem Skript und den Videos werden sowohl die \u00dcbung als auch die Aufgabe hochgeladen, die \u00dcbung (und die vergangene Aufgabe) werden donnerstags (8:00 Uhr und nochmal 14:00 Uhr) besprochen (Sie k\u00f6nnen frei w\u00e4hlen, welche der beiden \u00dcbungen Sie w\u00e4hlen), bei Bedarf k\u00f6nnen wir auch gerne jederzeit eine Synchron-Video-Vorlesung einschieben, um Fragen zu erkl\u00e4ren, die Veranstaltung wird durch ein Tutorium unterst\u00fctzt, sollten Sie W\u00fcnsche haben, diesen Plan zu \u00e4ndern, kommen Sie gerne auf mich zu Zur erfolgreichen Durchf\u00fchrung der Veranstaltung m\u00fcssen die Aufgaben l\u00f6sen und zu den jeweiligen Fristen auf GitHub hochladen. Wenn Sie alle Aufgaben fristgerecht hochgeladen haben, d\u00fcrfen Sie an der Klausur teilnehmen. Es werden insgesamt wahrscheinlich 10 Aufgaben sein, die Sie selbst\u00e4ndig l\u00f6sen und hochladen m\u00fcssen. Sie k\u00f6nnen die Aufgaben auch zu zweit l\u00f6sen. Laden Sie dann aber bitte beide jeweils die L\u00f6sung hoch. Am Ende des Semesters schreiben wir eine Klausur (am Rechner). Diese Klausur wird bewertet und entspricht der Note f\u00fcr das gesamte \"Programmieren\"-Modul. Unter Aufgaben sind die Aufgaben beschrieben, die Sie in jeder Woche ausf\u00fchren sollen. Damit Sie dies erfolgreich erledigen k\u00f6nnen, ist jeweils angegeben, welche Themen Sie daf\u00fcr durcharbeiten m\u00fcssen. Das Durcharbeiten der jeweiligen Themen entspricht jeweils einer Vorlesung. Diese wird also selbst\u00e4ndig durchgef\u00fchrt. Daneben gibt es jede Woche (zu jedem Thema) \u00dcbungen , die wir in den \u00dcbungszeiten besprechen. Diese dienen der Anwendung und der Festigung der erlangten Kenntnisse. Die \u00dcbungen sind kleine Aufgaben, an denen Sie das neue Wissen anwenden sollen. Die \u00dcbungen dienen der Bef\u00e4higung, die (gr\u00f6\u00dferen) Aufgaben l\u00f6sen zu k\u00f6nnen. F\u00fcr die Kommunikation untereinander verwenden wir Slack . Dort k\u00f6nnen Sie alle inhaltlichen und organisatorischen Fragen stellen. Ich f\u00e4nde es gut, wenn ich dort m\u00f6glichst wenig Fragen - zumindest die inhaltlichen - beantworten m\u00fcsste, sondern eine Art internes Diskussionsforum entsteht. Es ist sehr gew\u00fcnscht, dort Fragen zu stellen und noch mehr gew\u00fcnscht, diese von Ihnen dort beantwortet zu sehen. Damit w\u00e4re allen geholfen und ich kann besser erkennen, wo noch Nachhol- bzw. Erl\u00e4uterungsbedarf bei den meisten besteht. Au\u00dferdem lernen Sie beim Beantworten der Fragen nochmals deutlich mehr. Das w\u00e4re super, wenn das klappt!","title":"Organisatorisches"},{"location":"#grober-inhalt-kann-sich-noch-andern","text":"Wir besch\u00e4ftigen uns dieses Semester mit weiteren Konzepten der Programmierung. Wir lernen weitere Datenstrukturen kennen (Collections), werden lernen, mit Exceptions umzugehen und implementieren Tests. Wir besch\u00e4ftigen uns mit Grafischen Nutzeroberfl\u00e4chen (GUIs) und lernen, Nutzereignisse zu behandeln. Nachfolgend der vorl\u00e4ufige Wochenplan (wird eventuell angepasst). Die Vorlesungsvideos finden Sie darunter f\u00fcr die einzelnen Wochen (unter Inhalte ). Woche Themen (Vorlesung) \u00dcbung Aufgabe Abgabe Aufgabe bis 1. 05.-09.04.2021 Einf\u00fchrung und Organisatorisches, Wiederholung - - - 1. 12.-16.04.2021 Git \u00dcbung 1 Aufgabe 1 25.04.2021 2. 19.-23.04.2021 Enumerations und Exceptions \u00dcbung 2 Aufgabe 2 02.05.2021 3. 26.-30.04.2021 Testen mit JUnit \u00dcbung 3 Aufgabe 3 09.05.2021 4. 03.-07.05.2021 Collections (List und Set) \u00dcbung 4 Aufgabe 4 16.05.2021 5. 10.-14.05.2021 Wrapper-Klassen (boxing und unboxing) \u00dcbung 5 Aufgabe 5 23.05.2021 6. 17.-21.05.2021 Collections (Map) + Abstrakte Klassen \u00dcbung 6 - - 7. 24.-28.05.2021 Interfaces \u00dcbung 7 Aufgabe 6 06.06.2021 8. 31.-04.06.2021 GUI \u00dcbung 8 Aufgabe 7 13.06.2021 9. 07.-11.06.2021 Ereignisse \u00dcbung 9 Aufgabe 8 20.06.2021 10. 14.-18.06.2021 Dialoge und Graphics \u00dcbung 10 Aufgabe 9 04.07.2021 12. 21.-25.06.2021 Neuerungen in Java 10-14 \u00dcbung 11 - - 13. 28.-02.07.2021 - \u00dcbung 12 - - 14. 05.-09.07.2021 Klausurvorbereitung \u00dcbung 13 - - 15. 12.-16.07.2021 Klausurvorbereitung - - -","title":"Grober Inhalt (kann sich noch \u00e4ndern)"},{"location":"#inhalte","text":"05.-09.04.2021 - Einf\u00fchrung und Organisatorisches + Wiederholung siehe Organisatorisches siehe Wiederholung siehe Aufgabe 1 12.-16.04.2021 - Git siehe Git Video zu Git siehe \u00dcbung 1 siehe Aufgabe 2 19.-23.04.2021 - Enum und Exceptions siehe Mehrdimensionale Arrays und Aufz\u00e4hlungstypen Video zu Mehrdimensionale Arrays und Aufz\u00e4hlungstypen siehe Exceptions Video zu Exceptions - das ist Teil 1 (Einf\u00fchrung) noch ein Video zu Exceptions - das ist Teil 2 (eigene Exceptions) siehe \u00dcbung 2 siehe Aufgabe 3 26.-30.04.2021 - Testen mit JUnit siehe auch Teil 2 des Videos zu Exceptions (unter 19.-23.04.2021 - Enum und Exceptions eins dr\u00fcber) - das kam erst diese Woche hinzu, deshalb hier der Verweis, geh\u00f6rt aber thematisch in die Woche davor, deshalb dort siehe JUnit-Tests siehe Video zu JUnit-Tests siehe \u00dcbung 3 siehe Aufgabe 4 Video aus der Vorlesung vom 28.04.2021 Quellcode aus der Vorlesung vom 28.04.2021 MyMath.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package vorlesungen.testen ; public class MyMath { public static int abs ( int number ) { if ( number < 0 ) { return - number ; } else { return number ; } } public static double abs ( double number ) { if ( number < 0 ) { return - number ; } else { return number ; } } public static double sqrt ( double number ) { double a = number ; double b = 1.0 ; final double AREA = number ; final double ERROR = 0.000001 ; while ( abs ( a - b ) >= ERROR ) { a = ( a + b ) / 2.0 ; b = AREA / a ; } return a ; } public static int ggT ( int a , int b ) { while ( b != 0 ) { int rest = a % b ; a = b ; b = rest ; } return a ; } } MyMathTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package vorlesungen.testen ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class MyMathTest { @Test void testAbs3 () { int result = MyMath . abs ( 3 ); assertEquals ( 3 , result , \"abs(3) not 3\" ); } @Test void testAbsMinus3 () { int result = MyMath . abs ( - 3 ); assertEquals ( 3 , result , \"abs(-3) not 3\" ); } @Test void testSqrt9 () { double result = MyMath . sqrt ( 9.0 ); assertEquals ( 3.0 , result , 0.00001 ); } @Test void testSqrt25 () { double result = MyMath . sqrt ( 25.0 ); assertTrue ( MyMath . abs ( 5.0 - result ) <= 0.00001 ); } @Test void testGgT44und12 () { int result = MyMath . ggT ( 44 , 12 ); assertEquals ( 4 , result , \"ggT of 44 and 12 not 4\" ); } } module-info.java 1 2 3 4 module SoSe2021 { requires java . desktop ; requires org . junit . jupiter . api ; } 03.-07.05.2021 - Collections (List und Set) siehe Collections siehe Video zu Collections - Vorlesung 05.05.2021 Quellcode aus der Vorlesung vom 05.05.2021 ListenUndMengen.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 package vorlesungen.listenmengen ; import java.util.* ; /* * Collections: aehnlich wie Arrays, viele Elemente speichern * keine feste Laenge * wir koennen nur Referenztypen speichern (also nicht int, boolean, char, double, ...) * Elemente verschiedenen Typs speicherbar --> gar nicht gut, deshalb Typisieren * Arten von Collections: List (wie Arrays), Set (keine Doppelungen), Stack, Queue * Map (2-spaltige Tabellen Schl\u00fcssel-/Werte-Paare) */ public class ListenUndMengen { public static void main ( String [] args ) { System . out . printf ( \"%n%n-------------- Listen ------------------%n%n\" ); Set < String > set1 = new HashSet <> (); Set < String > set2 = new TreeSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; Integer i1 = 1 ; System . out . println ( set1 . add ( s1 )); System . out . println ( set1 . add ( s2 )); System . out . println ( set1 . add ( s3 )); System . out . println ( set1 . add ( s4 )); // System.out.println(set1.add(i1)); System . out . println ( set1 . size ()); Iterator < String > it = set1 . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } System . out . println (); for ( String element : set1 ) { System . out . println ( element ); } System . out . println ( set1 . remove ( \"erster\" )); System . out . println ( set1 . remove ( \"vierter\" )); System . out . println (); for ( String element : set1 ) { System . out . println ( element ); } System . out . printf ( \"%n%n-------------- Listen ------------------%n%n\" ); List < String > l1 = new ArrayList <> (); List < String > l2 = new LinkedList <> (); l1 . add ( s1 ); l1 . add ( s2 ); l1 . add ( s3 ); l1 . add ( s4 ); for ( String s : l1 ) { System . out . println ( s ); } System . out . println ( l1 . size ()); System . out . println ( l1 . remove ( \"zweiter\" )); System . out . println ( l1 . remove ( \"vierter\" )); for ( String s : l1 ) { System . out . println ( s ); } System . out . println (); System . out . println ( \"geloescht : \" + l1 . remove ( 1 )); for ( String s : l1 ) { System . out . println ( s ); } System . out . println (); l2 . add ( \"neu\" ); l2 . add ( \"alt\" ); for ( String s : l2 ) { System . out . println ( s ); } System . out . println (); l1 . addAll ( l2 ); for ( String s : l1 ) { System . out . println ( s ); } System . out . println (); l1 . removeAll ( l2 ); for ( String s : l1 ) { System . out . println ( s ); } } } siehe \u00dcbung 5 siehe Aufgabe 5 10.-14.05.2021 - Wrapper-Klassen (boxing und unboxing) siehe Wrapper-Klassen siehe Video zu Wrapper-Klassen - Vorlesung 12.05.2021 diese Woche keine neue \u00dcbung (Donnerstag ist Feiertag) diese Woche keine neue Aufgabe (M\u00f6glichkeit, bisher \"Liegengebliebenes\" aufzuarbeiten) L\u00f6sungen f\u00fcr Aufgaben 1 - 3 hochgeladen 17.-21.05.2021 - Collections (Map) siehe Maps siehe Video zu Maps - Vorlesung 19.05.2021 Quellcode aus der Vorlesung vom 19.05.2021 Maps.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 package vorlesungen.maps ; import java.util.* ; public class Maps { public static void main ( String [] args ) { /* * in Maps speichern wir Schluessel-Werte-Paare * Schluessel sind eindeutig, Schluesseltyp K * Werte koennen sich doppel, Wertetyp V * statt add(), addAll() hier put(), putAll() */ Map < String , Integer > mapA = new HashMap <> (); mapA . put ( \"A\" , 1 ); mapA . put ( \"B\" , 2 ); mapA . put ( \"C\" , 3 ); /* * ein einzelnes Schluessel-Werte-Paar ist vom * Typ Map.Entry * typisiert: Map.Entry<K,V> * unser Beispiel: Map.Entry<String, Integer> */ /* * leider nicht iterator(), sondern entrySet() * entrySet() erzeugt eine Set von lauter Schluessel-Werte-Paaren */ // Variante 1 Set < Map . Entry < String , Integer >> allEntriesFromMapA = mapA . entrySet (); for ( Map . Entry < String , Integer > entry : allEntriesFromMapA ) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } System . out . println ( allEntriesFromMapA . size ()); // Iterator<Map.Entry<String, Integer>> it = allEntriesFromMapA.iterator(); System . out . println (); // Variante 2 for ( Map . Entry < String , Integer > entry : mapA . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } System . out . println ( mapA . containsKey ( \"B\" )); System . out . println ( mapA . containsKey ( \"D\" )); System . out . println ( mapA . get ( \"B\" )); System . out . printf ( \"%n%n------------ alle keys von mapA ---------------%n%n\" ); Set < String > allKeys = mapA . keySet (); for ( String key : allKeys ) { System . out . println ( \"key : \" + key ); } System . out . printf ( \"%n%n------------ mapA ---------------%n%n\" ); mapA . put ( \"B\" , 5 ); for ( Map . Entry < String , Integer > entry : mapA . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } System . out . printf ( \"%n%n------------ mapB ---------------%n%n\" ); Map < String , Integer > mapB = new HashMap <> (); mapB . put ( \"B\" , 6 ); mapB . put ( \"D\" , 7 ); for ( Map . Entry < String , Integer > entry : mapB . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } mapA . putAll ( mapB ); System . out . printf ( \"%n%n------------ mapA ---------------%n%n\" ); for ( Map . Entry < String , Integer > entry : mapA . entrySet ()) { System . out . println ( \"Schluessel : \" + entry . getKey () + \" Wert : \" + entry . getValue ()); } mapA . put ( \"E\" , 1 ); System . out . printf ( \"%n%n------------ alle values von mapA ---------------%n%n\" ); Collection < Integer > allValues = mapA . values (); for ( Integer val : allValues ) { System . out . println ( \"value : \" + val ); } } } siehe \u00dcbung 6 siehe Aufgabe 6","title":"Inhalte"},{"location":"abstrakt/","text":"Abstrakte Klassen \u00b6 Abstrakte Klassen haben wir bereits verwendet, ohne bis her zu wissen, worum es sich dabei handelt. Wenn wir uns nochmal die \"Vererbungshierarchie\" von Collection anschauen, dann finden wir darin Interfaces : die Klassen Collection , List , Set , SortedSet und NavigableSet sind solche Interfaces (dazu kommen wir in der n\u00e4chsten Lektion) und Abtrakte Klassen : die Klassen AbstractCollection , AbstractList und AbstractSet sind solche abstrakten Klassen (die schauen wir uns jetzt an) Klassen - allgemein \u00b6 Wir haben uns bis jetzt Klassen erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen zu erben und somit alle Eigenschaften (Variablen und Methoden) dieser Klasse wiederzuverwenden und um daraus Objekte zu erzeugen. Diese Objekte weisen alle die gleichen Eigenschaften (Variablen und Methoden) auf. Diese Eigenschaften sind entweder in der Klasse definiert, von der wir Objekte erzeugen oder sie wurden in dieser Klasse von einer anderen Klasse geerbt. Angenommen, in der Klasse wurde eine Methode implementiert public void eineImplementierteMethode () { // Anweisungen } , dann konnten alle Objekte, die wir von dieser Klasse erzeugt haben, diese Methode aufrufen und ausf\u00fchren refVariable.eineImplementierteMethode(); . Klassen - abstrakt \u00b6 Abstrakte Klassen sind etwas anders. Von ihnen k\u00f6nnen wir keine Objekte erzeugen . Das hei\u00dft, f\u00fcr abstrakte Klassen gelten nur die beiden ersten Punkte der oberen Aufz\u00e4hlung. Abstrakte Klassen werden erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen alle Eigenschaften erben zu lassen. Der dritte obere Punkt gilt nicht ! Wir k\u00f6nnen von abstrakten Klassen keine Objekte erzeugen . Eine abstrakte Klasse enth\u00e4lt eine oder mehrere abstrakte Methoden. Oder besser andersherum: Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abstrakte Methoden \u00b6 Abstrakte Methoden sind Methoden, die nicht implementiert sind, d.h. sie haben keinen Methodenrumpf. Eine abstrakte Methode besteht nur aus einem Methodenkopf (gefolgt von einem Semikolon): public abstract void eineAbstrakteMethode (); Das Schl\u00fcsselwort abstract gibt an, dass die Methode nicht implementiert wird, sondern nur abstrakt beschreibt, wie der Name der Methode lautet, welche Parameter die Methode erwartet, wie der R\u00fcckgabetyp der Methode ist und wie der Sichtbarkeitsmodifizierer dieser Methode ist. Prinzipiell ist f\u00fcr abstrakte Methoden zu beachten, dass sie das Schl\u00fcsselwort abstract im Methodenkopf deklarieren und dass abstrakte Methode keinen Methodenrumpf hat, also keine { } . Die Deklaration einer abstrakten Methode endet aber mit einem Semikolon! Verwendung abstrakter Klassen \u00b6 Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abtrakte Klassen dienen als Typ und als Basisklasse, d.h. von abstrakten Klassen wird geerbt. Von abstrakten Klassen abgeleitete Klassen (also Klassen, die von einer abstrakten Klasse erben), m\u00fcssen die geerbten Methoden implementieren (ansonsten w\u00e4ren sie selbst wieder abstrakt)! Ein Beispiel - die abstrakte Klasse Shape \u00b6 Wir erstellen uns eine abstrakte Klasse Shape , welche zwei abstrakte Methoden enth\u00e4lt, perimeter() und area() . public abstract class Shape { public abstract double perimeter (); public abstract double area (); } Beachten Sie, dass eine Klasse selbst als abstract deklariert werden muss, wenn sie abstrakte Methoden enth\u00e4lt. Deshalb enth\u00e4lt die Klassendeklaration in Zeile 1 ebanfalls das Schl\u00fcsselwort abstract . Sie liesse sich auch sonst gar nicht compilieren. Rectangle erbt von Shape \u00b6 Shape kann nun bereits als Typ verwendet werden. Es lassen sich aber keine Objekte von der Klasse Shape erzeugen. Vielmehr ist die Klasse Shape auch dazu da, um von ihr zu erben. Wir erzeugen uns deshalb eine Klasse Rectangle , die von Shape erbt. Wenn wir nun schreiben: 1 2 3 4 public class Rectangle extends Shape { } dann ist Rectangle rot unterstrichen und Eclipse bietet uns zwei QuickFixes an: Add unimplemnted methods oder Make type Rectangle abstract Durch das Erben von Shape haben wir auch die beiden abstrakten Methoden perimeter() und area() geerbt. Wir haben nun entweder die M\u00f6glichkeit, diese Methoden zu implementieren oder die Klasse Rectangle ist selbst eine abstrakte Klasse. Wir w\u00e4hlen QuickFix 1 und lassen die Methoden hinzuf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Rectangle extends Shape { @Override public double perimeter () { // TODO Auto-generated method stub return 0 ; } @Override public double area () { // TODO Auto-generated method stub return 0 ; } } Eclipse f\u00fcgt die zu implementierenden Methoden genau so ein, wie wir sie geerbt haben (also als public und mit R\u00fcckgabetyp double sowie den in Shape definierten Namen). Nun sind die bedien Methoden aber jeweils implementiert (aber noch nicht richtig - TODO ). Da beide Methoden nun einen Methodenrumpf enthalten (Zeilen 6-9 und 13-16 ), sind sie nicht mehr abstrakt und somit ist auch die Klasse Rectangle keine abstrakte Klasse. Eine sinnvolle Implementierung der Klasse Rectangle sieht z.B. so aus, dass wir zwei Objektvariablen definieren, die die Breite und H\u00f6he eines Rechtecks beschreiben, dass wir einen parametrisierten Konstruktor hinzuf\u00fcgen und dass wir unter Verwendung der Werte der Objektvariablen die Methoden perimeter() und area() sinnvoll implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Nat\u00fcrlich k\u00f6nnte (und sollte) die Klasse auch noch um geeignete Implementierungen f\u00fcr mindestens die von Object geerbten Methoden equals() und toString() enthalten. Circle erbt von Shape \u00b6 Wir k\u00f6nnen beliebig oft von der Klasse Shape erben, d.h. wir k\u00f6nnen nun beliebig viele Klasse erstellen, die von der Klasse Shape erben. F\u00fcr jede dieser Klassen gilt nun: ein Objekt dieser Klasse (z.B. ein Objekt der Klasse Rectangle ) \"besitzt\" die Methoden perimeter() und area() , ein Objekt dieser Klasse ist auch vom (Laufzeit-)Typ Shape . Wir erzeugen uns eine weitere Klasse, um diese Tatsachen n\u00e4her zu betrachten: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } } Testen der Klassen \u00b6 Beispielsweise k\u00f6nnte nun in einer beliebigen Klasse eine Methode implementiert werden, in der ein Shape als Parameter verwendet wird und die f\u00fcr dieses Shape die Methode perimeter() oder area() aufruft. Es ist ja sicher, dass jedes Objekt vom Typ Shape diese Methoden als Eigenschaft \"besitzt\". Betrachten wir folgende TestklasseShape : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class TestklasseShape { public static void printPerimeter ( Shape s ) { System . out . printf ( \"perimeter : %.2f cm%n\" , s . perimeter ()); } public static void printArea ( Shape s ) { System . out . printf ( \"area : %.2f cm%n\" , s . area ()); } public static double sumPerimeters ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . perimeter (); } return sum ; } public static double sumAreas ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . area (); } return sum ; } public static void main ( String [] args ) { Shape s1 = new Rectangle ( 10 , 20 ); Shape s2 = new Circle ( 6.0 ); printPerimeter ( s1 ); printPerimeter ( s2 ); printArea ( s1 ); printArea ( s2 ); Shape [] shapes = new Shape [ 4 ] ; shapes [ 0 ] = s1 ; shapes [ 1 ] = s2 ; shapes [ 2 ] = new Rectangle ( 5 , 15 ); shapes [ 3 ] = new Circle ( 10.0 ); System . out . printf ( \"sum of perimeters : %.2f cm%n\" , sumPerimeters ( shapes )); System . out . printf ( \"sum of areas : %.2f cm%n\" , sumAreas ( shapes )); } } In dieser Testklasse sind vier Methoden implementiert, die als Parameter entweder Objekte vom Typ Shape oder vom Typ Shape[] erwarten. Von Objekten, die vom (Laufzeit-)Typ Shape sind, wissen wir, dass sie die Methoden perimeter() bzw. area() als Eigenschaften besitzen. Deshalb k\u00f6nnen wir diese Methoden auch in den jeweiligen Methoden f\u00fcr die Shape -Objekte aufrufen. Abstrakte Klassen fungieren also ein ein Muster f\u00fcr Klassen, die von den abstrakten Klassen erben, denn die abgeleiteten Klassen m\u00fcssen genau diese Methoden implementieren, die von den abstrakten Klassen vorgegeben sind. Ohne jetzt wirklich zu wissen, welche konkreten Klassen von dieser abstrakten Klasse erben und auch, ohne wirklich zu wissen, von welcher konkreten Klasse die Objekte erzeugt wurden (z.B. Rectangle oder Circle ), so wissen wir doch, dass diese Objekte zumindest \u00fcber die Methoden perimeter() und area() verf\u00fcgen. Beispiele aus den Java-Paketen \u00b6 In Java finden sich sehr viele abstrakte Klassen. Wir betrachten im Folgenden einige, zu denen wir bereits einen Bezug haben. Die abstrakte Klasse Number \u00b6 Die Klasse Number aus dem java.lang -Paket ist eine abstrakte Klasse. In dieser Klasse sind folgende abstrakte Methoden definiert: abstract double doubleValue() abstract float floatValue() abstract int intValue() abstract long longValue() Alle numerischen Wrapper-Klassen erben von Number , d.h. die Klassen Byte , Double , Float , Integer , Long und Short sind von Number abgeleitet. Das bedeutet, dass alle Objekte dieser konkreten Wrapper-Klassen auch vom Typ Number sind und somit die Methoden doubleValue() , floatValue() , intValue() und longValue() als Eigenschaften besitzen. Wir k\u00f6nnen also f\u00fcr alle solche Objekte diese Methoden aufrufen. Abstrakte Klassen f\u00fcr Collections \u00b6 Beispiele f\u00fcr abstrakte Klassen finden wir auch im java.util -Paket f\u00fcr die Collections. Beispielsweise definiert die abstrakte Klasse AbstractCollection eine Reihe uns bereits bekannter Methoden, wie z.B. add() , addAll() , clear() , contains() , isEmpty() , iterator() , remove() usw. Alle Klassen, die von dieser Klasse erben, wie z.B. AbstractList und AbstractSet verf\u00fcgen also ebenfalls \u00fcber diese Methoden. Beachten Sie, dass diese beiden Klassen AbstractList und AbstractSet ebenfalls abstrakt sind! Von AbstractSet erben z.B. die Klassen HashSet , TreeSet und EnumSet . Erst von diesen konkreten Klassen k\u00f6nnen tats\u00e4chlich Objekte erzeugt werden. Alle diese Objekte besitzen aber (nat\u00fcrlich) die bereits in AbstractCollection definierten Methoden. Success Wir kennen jetzt abstrakte Klassen. Abstrakte Klassen sind Klassen, die abstrakte Methoden enthalten. Abstrakte Methoden sind Methoden, die nicht implementiert sind. Von abstrakten Klassen k\u00f6nnen wir keine Objekte erzeugen. Abstrakte Klassen dienen uns als Typen und wir k\u00f6nnen von abstrakten Klassen erben. Eine Klasse, die von einer abstrakten Klasse erbt, muss die geerbten abstrakten Methoden implementieren (oder sie ist selbst wieder abstrakt). Alle Klassen, die von einer abstrakten Klasse erben, implementieren also die Methoden genau so, wie sie von der abstrakten Klasse vorgegeben wurden, also mit der Methodensignatur (Name der Methode, Parameter, R\u00fcckgabetyp und Sichtbarkeitsmodifizierer). Jedes Objekt einer Klasse, welche von der abstrakten Klasse geerbt hat, ist auch vom Typ der abstrakten Klasse.","title":"Abstrakte Klassen"},{"location":"abstrakt/#abstrakte-klassen","text":"Abstrakte Klassen haben wir bereits verwendet, ohne bis her zu wissen, worum es sich dabei handelt. Wenn wir uns nochmal die \"Vererbungshierarchie\" von Collection anschauen, dann finden wir darin Interfaces : die Klassen Collection , List , Set , SortedSet und NavigableSet sind solche Interfaces (dazu kommen wir in der n\u00e4chsten Lektion) und Abtrakte Klassen : die Klassen AbstractCollection , AbstractList und AbstractSet sind solche abstrakten Klassen (die schauen wir uns jetzt an)","title":"Abstrakte Klassen"},{"location":"abstrakt/#klassen-allgemein","text":"Wir haben uns bis jetzt Klassen erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen zu erben und somit alle Eigenschaften (Variablen und Methoden) dieser Klasse wiederzuverwenden und um daraus Objekte zu erzeugen. Diese Objekte weisen alle die gleichen Eigenschaften (Variablen und Methoden) auf. Diese Eigenschaften sind entweder in der Klasse definiert, von der wir Objekte erzeugen oder sie wurden in dieser Klasse von einer anderen Klasse geerbt. Angenommen, in der Klasse wurde eine Methode implementiert public void eineImplementierteMethode () { // Anweisungen } , dann konnten alle Objekte, die wir von dieser Klasse erzeugt haben, diese Methode aufrufen und ausf\u00fchren refVariable.eineImplementierteMethode(); .","title":"Klassen - allgemein"},{"location":"abstrakt/#klassen-abstrakt","text":"Abstrakte Klassen sind etwas anders. Von ihnen k\u00f6nnen wir keine Objekte erzeugen . Das hei\u00dft, f\u00fcr abstrakte Klassen gelten nur die beiden ersten Punkte der oberen Aufz\u00e4hlung. Abstrakte Klassen werden erstellt, um sie als einen neuen (Referenz-)Typ zu verwenden, um von diesen Klassen alle Eigenschaften erben zu lassen. Der dritte obere Punkt gilt nicht ! Wir k\u00f6nnen von abstrakten Klassen keine Objekte erzeugen . Eine abstrakte Klasse enth\u00e4lt eine oder mehrere abstrakte Methoden. Oder besser andersherum: Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse.","title":"Klassen - abstrakt"},{"location":"abstrakt/#abstrakte-methoden","text":"Abstrakte Methoden sind Methoden, die nicht implementiert sind, d.h. sie haben keinen Methodenrumpf. Eine abstrakte Methode besteht nur aus einem Methodenkopf (gefolgt von einem Semikolon): public abstract void eineAbstrakteMethode (); Das Schl\u00fcsselwort abstract gibt an, dass die Methode nicht implementiert wird, sondern nur abstrakt beschreibt, wie der Name der Methode lautet, welche Parameter die Methode erwartet, wie der R\u00fcckgabetyp der Methode ist und wie der Sichtbarkeitsmodifizierer dieser Methode ist. Prinzipiell ist f\u00fcr abstrakte Methoden zu beachten, dass sie das Schl\u00fcsselwort abstract im Methodenkopf deklarieren und dass abstrakte Methode keinen Methodenrumpf hat, also keine { } . Die Deklaration einer abstrakten Methode endet aber mit einem Semikolon!","title":"Abstrakte Methoden"},{"location":"abstrakt/#verwendung-abstrakter-klassen","text":"Eine Klasse, die eine oder mehrere abstrakte Methoden enth\u00e4lt, ist eine abstrakte Klasse. Abtrakte Klassen dienen als Typ und als Basisklasse, d.h. von abstrakten Klassen wird geerbt. Von abstrakten Klassen abgeleitete Klassen (also Klassen, die von einer abstrakten Klasse erben), m\u00fcssen die geerbten Methoden implementieren (ansonsten w\u00e4ren sie selbst wieder abstrakt)!","title":"Verwendung abstrakter Klassen"},{"location":"abstrakt/#ein-beispiel-die-abstrakte-klasse-shape","text":"Wir erstellen uns eine abstrakte Klasse Shape , welche zwei abstrakte Methoden enth\u00e4lt, perimeter() und area() . public abstract class Shape { public abstract double perimeter (); public abstract double area (); } Beachten Sie, dass eine Klasse selbst als abstract deklariert werden muss, wenn sie abstrakte Methoden enth\u00e4lt. Deshalb enth\u00e4lt die Klassendeklaration in Zeile 1 ebanfalls das Schl\u00fcsselwort abstract . Sie liesse sich auch sonst gar nicht compilieren.","title":"Ein Beispiel - die abstrakte Klasse Shape"},{"location":"abstrakt/#rectangle-erbt-von-shape","text":"Shape kann nun bereits als Typ verwendet werden. Es lassen sich aber keine Objekte von der Klasse Shape erzeugen. Vielmehr ist die Klasse Shape auch dazu da, um von ihr zu erben. Wir erzeugen uns deshalb eine Klasse Rectangle , die von Shape erbt. Wenn wir nun schreiben: 1 2 3 4 public class Rectangle extends Shape { } dann ist Rectangle rot unterstrichen und Eclipse bietet uns zwei QuickFixes an: Add unimplemnted methods oder Make type Rectangle abstract Durch das Erben von Shape haben wir auch die beiden abstrakten Methoden perimeter() und area() geerbt. Wir haben nun entweder die M\u00f6glichkeit, diese Methoden zu implementieren oder die Klasse Rectangle ist selbst eine abstrakte Klasse. Wir w\u00e4hlen QuickFix 1 und lassen die Methoden hinzuf\u00fcgen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Rectangle extends Shape { @Override public double perimeter () { // TODO Auto-generated method stub return 0 ; } @Override public double area () { // TODO Auto-generated method stub return 0 ; } } Eclipse f\u00fcgt die zu implementierenden Methoden genau so ein, wie wir sie geerbt haben (also als public und mit R\u00fcckgabetyp double sowie den in Shape definierten Namen). Nun sind die bedien Methoden aber jeweils implementiert (aber noch nicht richtig - TODO ). Da beide Methoden nun einen Methodenrumpf enthalten (Zeilen 6-9 und 13-16 ), sind sie nicht mehr abstrakt und somit ist auch die Klasse Rectangle keine abstrakte Klasse. Eine sinnvolle Implementierung der Klasse Rectangle sieht z.B. so aus, dass wir zwei Objektvariablen definieren, die die Breite und H\u00f6he eines Rechtecks beschreiben, dass wir einen parametrisierten Konstruktor hinzuf\u00fcgen und dass wir unter Verwendung der Werte der Objektvariablen die Methoden perimeter() und area() sinnvoll implementieren: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Nat\u00fcrlich k\u00f6nnte (und sollte) die Klasse auch noch um geeignete Implementierungen f\u00fcr mindestens die von Object geerbten Methoden equals() und toString() enthalten.","title":"Rectangle erbt von Shape"},{"location":"abstrakt/#circle-erbt-von-shape","text":"Wir k\u00f6nnen beliebig oft von der Klasse Shape erben, d.h. wir k\u00f6nnen nun beliebig viele Klasse erstellen, die von der Klasse Shape erben. F\u00fcr jede dieser Klassen gilt nun: ein Objekt dieser Klasse (z.B. ein Objekt der Klasse Rectangle ) \"besitzt\" die Methoden perimeter() und area() , ein Objekt dieser Klasse ist auch vom (Laufzeit-)Typ Shape . Wir erzeugen uns eine weitere Klasse, um diese Tatsachen n\u00e4her zu betrachten: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Circle extends Shape { private double radius ; public Circle ( double radius ) { this . radius = radius ; } @Override public double perimeter () { return Math . PI * 2.0 * this . radius ; } @Override public double area () { return Math . PI * this . radius * this . radius ; } }","title":"Circle erbt von Shape"},{"location":"abstrakt/#testen-der-klassen","text":"Beispielsweise k\u00f6nnte nun in einer beliebigen Klasse eine Methode implementiert werden, in der ein Shape als Parameter verwendet wird und die f\u00fcr dieses Shape die Methode perimeter() oder area() aufruft. Es ist ja sicher, dass jedes Objekt vom Typ Shape diese Methoden als Eigenschaft \"besitzt\". Betrachten wir folgende TestklasseShape : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class TestklasseShape { public static void printPerimeter ( Shape s ) { System . out . printf ( \"perimeter : %.2f cm%n\" , s . perimeter ()); } public static void printArea ( Shape s ) { System . out . printf ( \"area : %.2f cm%n\" , s . area ()); } public static double sumPerimeters ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . perimeter (); } return sum ; } public static double sumAreas ( Shape [] shapes ) { double sum = 0.0 ; for ( Shape s : shapes ) { sum += s . area (); } return sum ; } public static void main ( String [] args ) { Shape s1 = new Rectangle ( 10 , 20 ); Shape s2 = new Circle ( 6.0 ); printPerimeter ( s1 ); printPerimeter ( s2 ); printArea ( s1 ); printArea ( s2 ); Shape [] shapes = new Shape [ 4 ] ; shapes [ 0 ] = s1 ; shapes [ 1 ] = s2 ; shapes [ 2 ] = new Rectangle ( 5 , 15 ); shapes [ 3 ] = new Circle ( 10.0 ); System . out . printf ( \"sum of perimeters : %.2f cm%n\" , sumPerimeters ( shapes )); System . out . printf ( \"sum of areas : %.2f cm%n\" , sumAreas ( shapes )); } } In dieser Testklasse sind vier Methoden implementiert, die als Parameter entweder Objekte vom Typ Shape oder vom Typ Shape[] erwarten. Von Objekten, die vom (Laufzeit-)Typ Shape sind, wissen wir, dass sie die Methoden perimeter() bzw. area() als Eigenschaften besitzen. Deshalb k\u00f6nnen wir diese Methoden auch in den jeweiligen Methoden f\u00fcr die Shape -Objekte aufrufen. Abstrakte Klassen fungieren also ein ein Muster f\u00fcr Klassen, die von den abstrakten Klassen erben, denn die abgeleiteten Klassen m\u00fcssen genau diese Methoden implementieren, die von den abstrakten Klassen vorgegeben sind. Ohne jetzt wirklich zu wissen, welche konkreten Klassen von dieser abstrakten Klasse erben und auch, ohne wirklich zu wissen, von welcher konkreten Klasse die Objekte erzeugt wurden (z.B. Rectangle oder Circle ), so wissen wir doch, dass diese Objekte zumindest \u00fcber die Methoden perimeter() und area() verf\u00fcgen.","title":"Testen der Klassen"},{"location":"abstrakt/#beispiele-aus-den-java-paketen","text":"In Java finden sich sehr viele abstrakte Klassen. Wir betrachten im Folgenden einige, zu denen wir bereits einen Bezug haben.","title":"Beispiele aus den Java-Paketen"},{"location":"abstrakt/#die-abstrakte-klasse-number","text":"Die Klasse Number aus dem java.lang -Paket ist eine abstrakte Klasse. In dieser Klasse sind folgende abstrakte Methoden definiert: abstract double doubleValue() abstract float floatValue() abstract int intValue() abstract long longValue() Alle numerischen Wrapper-Klassen erben von Number , d.h. die Klassen Byte , Double , Float , Integer , Long und Short sind von Number abgeleitet. Das bedeutet, dass alle Objekte dieser konkreten Wrapper-Klassen auch vom Typ Number sind und somit die Methoden doubleValue() , floatValue() , intValue() und longValue() als Eigenschaften besitzen. Wir k\u00f6nnen also f\u00fcr alle solche Objekte diese Methoden aufrufen.","title":"Die abstrakte Klasse Number"},{"location":"abstrakt/#abstrakte-klassen-fur-collections","text":"Beispiele f\u00fcr abstrakte Klassen finden wir auch im java.util -Paket f\u00fcr die Collections. Beispielsweise definiert die abstrakte Klasse AbstractCollection eine Reihe uns bereits bekannter Methoden, wie z.B. add() , addAll() , clear() , contains() , isEmpty() , iterator() , remove() usw. Alle Klassen, die von dieser Klasse erben, wie z.B. AbstractList und AbstractSet verf\u00fcgen also ebenfalls \u00fcber diese Methoden. Beachten Sie, dass diese beiden Klassen AbstractList und AbstractSet ebenfalls abstrakt sind! Von AbstractSet erben z.B. die Klassen HashSet , TreeSet und EnumSet . Erst von diesen konkreten Klassen k\u00f6nnen tats\u00e4chlich Objekte erzeugt werden. Alle diese Objekte besitzen aber (nat\u00fcrlich) die bereits in AbstractCollection definierten Methoden. Success Wir kennen jetzt abstrakte Klassen. Abstrakte Klassen sind Klassen, die abstrakte Methoden enthalten. Abstrakte Methoden sind Methoden, die nicht implementiert sind. Von abstrakten Klassen k\u00f6nnen wir keine Objekte erzeugen. Abstrakte Klassen dienen uns als Typen und wir k\u00f6nnen von abstrakten Klassen erben. Eine Klasse, die von einer abstrakten Klasse erbt, muss die geerbten abstrakten Methoden implementieren (oder sie ist selbst wieder abstrakt). Alle Klassen, die von einer abstrakten Klasse erben, implementieren also die Methoden genau so, wie sie von der abstrakten Klasse vorgegeben wurden, also mit der Methodensignatur (Name der Methode, Parameter, R\u00fcckgabetyp und Sichtbarkeitsmodifizierer). Jedes Objekt einer Klasse, welche von der abstrakten Klasse geerbt hat, ist auch vom Typ der abstrakten Klasse.","title":"Abstrakte Klassen f\u00fcr Collections"},{"location":"aufgaben/","text":"Aufgaben \u00b6 Aufgabe 1 (W\u00fcrfelspiel) \u00b6 Aufgabe 1 Vorbereitung (Selbstudium) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Rufen Sie jeweils die statischen Methoden showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() auf und werten Sie jeweils die Nutzereingabe aus (Bei showInputDialog() ist die R\u00fcckgabe ein String , ansonsten ist die R\u00fcckgabe ein int , der mit folgenden Optionen verglichen werden kann: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION Erstellen Sie insbesondere folgenden Dialog und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Committen und pushen Sie Ihre L\u00f6sung nach GitHub (oder Ihrem Git-Diensteanbieter). eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 1 Spiel.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package aufgaben.aufgabe1 ; import javax.swing.JOptionPane ; public class Spiel { public static int siegPunkte ; private Spieler [] spieler ; Spiel () { int anzSpieler = 0 ; int siegPunkte = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Anzahl Spieler :\" ); inputOk = true ; anzSpieler = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } inputOk = false ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Siegpunkte :\" ); inputOk = true ; siegPunkte = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; namenErmitteln (); } Spiel ( int siegPunkte , int anzSpieler ) { Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; /* Spielernamen sind A, B, C ... char name = 'A'; for(int i=0; i<spieler.length; i++) { spieler[i] = new Spieler(String.valueOf(name)); name ++; } */ /* Spielernamen werden eingegeben * wenn man namenErmitteln() auskommentiert, * kann man die obige for-Schleife nehmen, damit * man nicht immer die Spielernamen eingeben muss * - zum Testen */ namenErmitteln (); } private void namenErmitteln () { String name = \"\" ; for ( int i = 0 ; i < spieler . length ; i ++ ) { name = JOptionPane . showInputDialog ( \"Name des Spielers \" + ( i + 1 ) + \" :\" ); spieler [ i ] = new Spieler ( name ); } } public void spielen () { int index = 0 ; boolean gewonnen = false ; while ( ! gewonnen ) { gewonnen = spieler [ index ] . wuerfeln (); index = ( index < spieler . length - 1 ) ? index + 1 : 0 ; } } public static void main ( String [] args ) { //Spiel spiel = new Spiel(30, 3); Spiel spiel = new Spiel (); spiel . spielen (); } } Spieler.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package aufgaben.aufgabe1 ; import java.util.Random ; import javax.swing.JOptionPane ; public class Spieler { private String name ; private int aktStand ; private Random r ; Spieler ( String name ) { aktStand = 0 ; this . name = name ; r = new Random (); } public int getAktStand () { return this . aktStand ; } public boolean wuerfeln () { System . out . printf ( \"%n%nSpieler %s ist an der Reihe (bisher %d Punkte) %n ----------------------------------------- %n\" , this . name , this . aktStand ); int reihe = 0 ; int wurf = 0 ; boolean ende = false ; while ( ! ende ) { wurf = r . nextInt ( 6 ) + 1 ; System . out . printf ( \"%s hat eine %d gewuerfelt %n\" , this . name , wurf ); if ( wurf == 6 ) { System . out . printf ( \"Versuch zu Ende %n Aktueller Spielstand von %s : %d Punkte %n Der naechste Spieler ist dran%n\" , this . name , this . aktStand ); ende = true ; } else if ( aktStand + reihe + wurf >= Spiel . siegPunkte ) { System . out . printf ( \"%s hat insgesamt %d Punkte und somit gewonnen !!!\" , this . name , ( aktStand + reihe + wurf )); return true ; } else // eine 1..5 gewuerfelt und noch nicht gewonnen { reihe += wurf ; System . out . printf ( \"in diesem Versuch bisher %d Punkte -- insgesamt %d Punkte %n\" , reihe , ( aktStand + reihe )); int dialogResult = JOptionPane . showConfirmDialog ( null , this . name + \", wollen Sie weiter wuerfeln? \" , \"Weiter wuerfeln?\" , JOptionPane . YES_NO_OPTION ); ende = ! ( dialogResult == JOptionPane . YES_OPTION ); if ( ende ) { aktStand += reihe ; } } } return false ; } } Aufgabe 2 (MyInteger) \u00b6 Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Committen und pushen Sie Ihre L\u00f6sung nach GitHub (oder Ihrem Git-Diensteanbieter). eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 2 MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 package aufgaben.aufgabe2 ; public class MyInteger { public static final int MAX_VALUE = 2147483647 ; public static final int MIN_VALUE = - 2147483648 ; private int value ; public MyInteger ( int value ) { this . value = value ; } public MyInteger ( String s ) throws IllegalArgumentException { this . value = parseInt ( s ); } private static boolean isDigit ( char c ) { return ( c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' ); } private static int charToInt ( char c ) { int asciivalue = c ; int intvalue = asciivalue - 48 ; // 0 ist 048 bis 9 ist 057 return intvalue ; } public static int parseInt ( String s ) throws IllegalArgumentException { boolean negativ = false ; if ( s . length () == 0 ) throw new IllegalArgumentException ( \"leer\" ); // pruefe, ob erstes Zeichen + oder - // merken und weiter mit Rest if ( s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); else if ( s . charAt ( 0 ) == '-' ) { s = s . substring ( 1 ); negativ = true ; } if ( s . length () == 0 ) throw new IllegalArgumentException ( \"nur '+' bzw. '-' --> keine Zahl\" ); // entferne f\u00fchrende Nullen while ( s . charAt ( 0 ) == '0' ) { s = s . substring ( 1 ); } for ( int i = 0 ; i < s . length (); i ++ ) { if ( ! isDigit ( s . charAt ( i ))) throw new IllegalArgumentException ( \"keine Zahl!\" ); } int exponent = 0 ; int zahl = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; i -- ) { zahl = zahl + charToInt ( s . charAt ( i )) * ( int ) Math . pow ( 10 , exponent ); exponent ++ ; } if ( negativ ) return - zahl ; else return zahl ; } public int intValue () { return this . value ; } public double doubleValue () { return this . value ; } public static MyInteger valueOf ( String s ) throws IllegalArgumentException { return new MyInteger ( s ); } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; MyInteger otherInt = ( MyInteger ) other ; return ( this . value == otherInt . value ); } @Override public int hashCode () { return this . value ; } @Override public String toString () { return value + \"\" ; } public static int compare ( int x , int y ) { return ( x < y ) ? - 1 : (( x == y ) ? 0 : 1 ); } public int compareTo ( MyInteger otherMyInteger ) { return compare ( this . value , otherMyInteger . value ); } } MyIntegerMain.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 package aufgaben.aufgabe2 ; public class MyIntegerMain { public static void main ( String [] args ) { MyInteger mi1 = null , mi2 = null , mi3 = null , mi4 = null , mi5 = null , mi6 = null , mi7 = null , mi8 = null , mi9 = null , mi10 = null ; try { mi1 = new MyInteger ( \"-2147483648\" ); System . out . println ( mi1 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi2 = new MyInteger ( \"-00002147483648\" ); System . out . println ( mi2 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi3 = new MyInteger ( \"hallo\" ); System . out . println ( mi3 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi4 = new MyInteger ( - 2147483648 ); try { mi5 = MyInteger . valueOf ( \"-2147483648\" ); System . out . println ( mi5 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi6 = MyInteger . valueOf ( \"-00002147483648\" ); System . out . println ( mi6 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi7 = MyInteger . valueOf ( \"hallo\" ); System . out . println ( mi7 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi8 = MyInteger . valueOf ( - 2147483648 ); try { mi9 = MyInteger . valueOf ( \"\" ); System . out . println ( mi9 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi10 = MyInteger . valueOf ( \"+\" ); System . out . println ( mi10 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } System . out . println ( \"mi1 equals mi2 ? : \" + mi1 . equals ( mi2 )); System . out . println ( \"mi1 equals mi3 ? : \" + mi1 . equals ( mi3 )); System . out . println ( \"mi1 equals mi4 ? : \" + mi1 . equals ( mi4 )); System . out . println ( \"mi1 equals mi5 ? : \" + mi1 . equals ( mi5 )); System . out . println ( \"mi1 equals mi6 ? : \" + mi1 . equals ( mi6 )); System . out . println ( \"mi1 equals mi7 ? : \" + mi1 . equals ( mi7 )); System . out . println ( \"mi1 equals mi8 ? : \" + mi1 . equals ( mi8 )); System . out . println ( \"mi1 equals mi9 ? : \" + mi1 . equals ( mi9 )); System . out . println ( \"mi1 equals mi10 ? : \" + mi1 . equals ( mi10 )); System . out . println ( \"hashCode mi1 : \" + mi1 . hashCode ()); System . out . println ( \"hashCode mi2 : \" + mi2 . hashCode ()); try { System . out . println ( \"hashCode mi3 : \" + mi3 . hashCode ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"hashCode mi4 : \" + mi4 . hashCode ()); System . out . println ( \"intValue mi1 : \" + mi1 . intValue ()); System . out . println ( \"intValue mi2 : \" + mi2 . intValue ()); try { System . out . println ( \"intValue mi3 : \" + mi3 . intValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"intValue mi4 : \" + mi4 . intValue ()); System . out . println ( \"doubleValue mi1 : \" + mi1 . doubleValue ()); System . out . println ( \"doubleValue mi2 : \" + mi2 . doubleValue ()); try { System . out . println ( \"doubleValue mi3 : \" + mi3 . doubleValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"doubleValue mi4 : \" + mi4 . doubleValue ()); } } MyIntegerTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package aufgaben.aufgabe2 ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.Test ; class MyIntegerTest { static MyInteger mi1 , mi2 , mi3 , mi4 , mi5 , mi6 , mi7 ; @BeforeAll public static void setUpBeforeClass () throws Exception { mi1 = new MyInteger ( \"-2147483648\" ); mi2 = new MyInteger ( \"+2147483647\" ); mi3 = new MyInteger ( - 1 ); mi4 = new MyInteger ( 1 ); mi5 = new MyInteger ( 0 ); mi6 = new MyInteger ( \"-1\" ); mi7 = new MyInteger ( 2147483647 ); } @Test void testHashCode () { assertTrue ( mi2 . hashCode () == mi7 . hashCode (), \" hashCode of mi2 and mi7 should be equal\" ); assertEquals ( - 2147483648 , mi1 . hashCode (), \"hashCode of mi1 should be -2147483648\" ); assertEquals ( 0 , mi5 . hashCode (), \"hashCode of mi5 should be 0\" ); } @Test void testMyIntegerInt () { assertNotNull ( mi4 , \"mi4 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testMyIntegerString () { assertNotNull ( mi1 , \"mi1 should be not null\" ); assertNotNull ( mi2 , \"mi2 should be not null\" ); assertNotNull ( mi6 , \"mi6 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testParseInt () { assertEquals ( - 2147483648 , MyInteger . parseInt ( \"-2147483648\" ), \"should be -2147483648\" ); assertEquals ( + 2147483647 , MyInteger . parseInt ( \"+00002147483647\" ), \"should be +2147483647\" ); assertEquals ( - 1 , MyInteger . parseInt ( \"-0000001\" ), \"should be -1\" ); } @Test void testIntValue () { assertEquals ( - 2147483648 , mi1 . intValue (), \"should be -2147483648\" ); assertEquals ( + 2147483647 , mi2 . intValue (), \"should be +2147483647\" ); assertEquals ( + 2147483647 , mi7 . intValue (), \"should be +2147483647\" ); } @Test void testDoubleValue () { assertEquals ( - 2147483648.0 , mi1 . doubleValue (), \"should be -2147483648.0\" ); assertEquals ( + 2147483647.0 , mi2 . doubleValue (), \"should be +2147483647.0\" ); assertEquals ( + 2147483647.0 , mi7 . doubleValue (), \"should be +2147483647.0\" ); } @Test void testValueOfString () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( \"-2147483648\" )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi7\" ); } @Test void testValueOfInt () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( - 2147483648 )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi7\" ); } @Test void testEqualsObject () { assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); assertFalse ( mi3 . equals ( mi4 ), \"mi3 and mi4 should not be equal\" ); assertFalse ( mi3 . equals ( mi5 ), \"mi3 and mi5 should not be equal\" ); } @Test void testToString () { assertEquals ( \"-2147483648\" , mi1 . toString (), \"should be '-2147483648'\" ); assertEquals ( \"2147483647\" , mi2 . toString (), \"should be '2147483647' mi2\" ); assertEquals ( \"2147483647\" , mi7 . toString (), \"should be '2147483647' mi7\" ); } @Test void testCompare () { assertTrue ( MyInteger . compare ( 5 , 4 ) > 0 , \"5,4 should be > 0\" ); assertTrue ( MyInteger . compare ( 4 , 4 ) == 0 , \"4,4 should be == 0\" ); assertTrue ( MyInteger . compare ( 4 , 5 ) < 0 , \"4,5 should be < 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MIN_VALUE ) > 0 , \"MAX,MIN should be > 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MAX_VALUE ) == 0 , \"MAX,MAX should be == 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MIN_VALUE , MyInteger . MAX_VALUE ) < 0 , \"MIN,MAX should be > 0\" ); } @Test void testCompareTo () { assertTrue ( mi1 . compareTo ( mi2 ) < 0 , \"mi1, mi2 should be < 0\" ); assertTrue ( mi2 . compareTo ( mi1 ) > 0 , \"mi2, mi1 should be > 0\" ); assertTrue ( mi2 . compareTo ( mi7 ) == 0 , \"mi2, mi7 should be == 0\" ); assertTrue ( mi3 . compareTo ( mi6 ) == 0 , \"mi3, mi6 should be == 0\" ); } } Aufgabe 3 (Solitaire) \u00b6 Aufgabe 3 Information und Vorbereitung Wir beginnen, ein Englisches Solit\u00e4r zu programmieren. Einige kennen es auch als Steckhalma. Ziel des Spiels ist, alle Steine bis auf einen (der am besten in der Mitte \u00fcbrig bleibt), zu entfernen. Ein Zug ist wie folgt: ein Stein springt \u00fcber einen anderen Stein und der \u00fcbersprungene Stein wird entfernt. Es gibt viele L\u00f6sungen daf\u00fcr. Einige Klassen sind bereits gegeben: Klasse Point.java package aufgaben.aufgabe3 ; /* * ein Point repreasentiert eine Position * im Spielfeld, bestehend aus der Nummer * fuer die Zeile (row) und der Nummer * fuer die Spalte (col) */ public class Point { private int row ; private int col ; /* * Konstruktor zur Erzeugung einer * Position bestehend aus row und col */ public Point ( int row , int col ) { this . row = row ; this . col = col ; } public int getRow () { return this . row ; } public int getCol () { return this . col ; } @Override public String toString () { return \"(\" + this . row + \",\" + this . col + \")\" ; } } Klasse Move.java ```java package aufgaben.aufgabe3; /* * diese Klasse repraesentiert einen Zug * Variablen sind Point from * und Point to * es wird nicht geprueft, ob der Zug ueberhaupt * moeglich ist */ public class Move { private Point from; private Point to; /* * ein Zug von dem from-Point (fromRow,fromCol) * zum to-Point (toRow,toCol) */ public Move(int fromRow, int fromCol, int toRow, int toCol) { this.from = new Point(fromRow, fromCol); this.to = new Point(toRow, toCol); } /* * in dem Konstruktor werden in this.from und this.to nicht einfach * die Referenzen von from und to gespeichert, sondern davon Kopien * erstellt, damit das Programm robuster gegen das Aendern von * Referenzen ist */ public Move(Point from, Point to) { this.from = new Point(from.getRow(), from.getCol()); this.to = new Point(to.getRow(), to.getCol()); } /* * der Getter fuer den Point from gibt keine Referenz auf * den Point from zurueck, sondern eine Kopie (einen Klon) * von from --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getFrom() { return new Point(this.from.getRow(), this.from.getCol()); } /* * der Getter fuer den Point to gibt keine Referenz auf * den Point to zurueck, sondern eine Kopie (einen Klon) * von to --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getTo() { return new Point(this.to.getRow(), this.to.getCol()); } } Klasse Moves.java package aufgaben.aufgabe3 ; /* * diese Klasse repraesentiert eine Folge * von Zuegen (Move), die in einem Array * moves gespeichert sind */ public class Moves { private Move [] moves ; /* * der Konstruktor erstellt ein leeres moves-Array * (d.h. noch keine Zuege (Moves) gespeichert) */ public Moves () { this . moves = new Move [ 0 ] ; } /* * der Konstruktor erstellt ein moves-Array mit einem * Move - dem erste Zug (firstMove) */ public Moves ( Move firstMove ) { this . moves = new Move [ 1 ] ; this . moves [ 0 ] = firstMove ; } /* * Anzahl der bisher gespeicherten Zuege */ public int getLength () { return this . moves . length ; } /* * fuegt einen Zug (nextMove) zum moves-Array hinzu * dazu muss das moves-Array um 1 laenger sein als zuvor * es wird eine Kopie aller Zuege erstellt und dann * der nextMove hinzugefuegt */ public void addMove ( Move nextMove ) { Move [] newMoves = new Move [ this . moves . length + 1 ] ; for ( int index = 0 ; index < this . moves . length ; index ++ ) { newMoves [ index ] = this . moves [ index ] ; } newMoves [ newMoves . length - 1 ] = new Move ( nextMove . getFrom (), nextMove . getTo ()); this . moves = newMoves ; } /* * gibt den Move zurueck, der im moves-Array unter dem Index index * gespeichert ist; * kann sein, dass index kein korrekter Index im moves-Array ist, * dann wird eine IllegalArgumentException geworfen */ public Move getMoveAtIndex ( int index ) throws IllegalArgumentException { try { return this . moves [ index ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"kein gueltiger Index!\" ); } } /* * Ausgabe aller im moves-Array gespeicherten Zuege * wird nur zum Debuggen benoetigt */ public void printMoves () { System . out . printf ( \"%n---%n\" ); for ( int index = 0 ; index < this . moves . length ; index ++ ) { Move move = this . moves [ index ] ; Point from = move . getFrom (); Point to = move . getTo (); System . out . println ( from . toString () + \" --> \" + to . toString ()); } System . out . printf ( \"%n---%n%n\" ); } } enum State.java package aufgaben.aufgabe3 ; /* * FREE - der Platz ist ein Spielfeld, aber kein Spielstein drauf * USED - der Platz ist ein Spielfeld mit Spielstein drauf * NOT - der Platz gehoert nicht zum Spielfeld */ public enum State { FREE , USED , NOT } Aufgabe Bef\u00fcllen Sie die Klasse Solitaire.java , wie in den Kommentaren beschrieben: Klasse Solitaire.java package aufgaben.aufgabe3.loesung ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } /* * Geben Sie das Spielfeld aus! Am Anfang sollte auf der * Konsole so ein Bild erscheinen: * o o o * o o o * o o o o o o o * o o o o o o * o o o o o o o * o o o * o o o * */ public void print () { } /* * diese Methode gibt ein true zurueck, wenn von der * uebergebenen Position (row,col) ein Zug moeglich ist * d.h. * 1. auf der angegebenen Position muss ein Stein sein * 2. zwei Steine weiter (oben, unten, rechts oder links) * darf kein Stein sein * 3. dazwischen muss ein Stein sein */ public boolean possibleFrom ( int row , int col ) { return false ; } /* * diese Methode gibt alle Positionen (Point) zurueck, * AUF die von (fromRow,fromCol) aus gesprungen werden * kann */ public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; // naechste Zeile muss entfernt werden! return null ; } /* * diese Methode erzeugt ein Moves-Objekt * in dieses Moves-Objekt werden mithilfe der * Objektmethode addMove() (aus Moves) alle * moeglichen Zuege hinzugefuegt * (moeglich im aktuellen Zustand von field[][]) */ public Moves possibleMoves () { Moves possibleMoves = new Moves (); // next line for debugging possibleMoves . printMoves (); return possibleMoves ; } /* * gibt ein true zurueck, wenn im aktuellen Zustand * von field[][] ueberhaupt noch ein Zug moeglich ist * sonst false */ public boolean movePossible () { return false ; } /* * ruft die Methode move(Move move) auf, * wenn ein Zug moeglich ist (dann true zurueck) * sonst false */ public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; /* * hier einen moeglichen Zug ausfuehren * den ersten, den Sie finden (siehe * possibleMoves() ) */ return true ; } /* * hier wird der Zug Move move ausgefuehrt * nach dem Zug ist * 1. die from-Position leer * 2. die to-Position mit einem Stein besetzt * 3. dazwischen leer (Stein wird \"entfernt\") * falls Zug nicht moeglich, wird eine * IllegalArgumentException geworfen */ public void move ( Move move ) throws IllegalArgumentException { } } Sie k\u00f6nnen selbstverst\u00e4ndlich beliebig viele weitere (Hilfs-)Methoden hinzuf\u00fcgen. Testen Sie Ihr Spiel in einer Testklasse . F\u00fchren Sie einige Z\u00fcge aus und geben danach immer das Spielfeld auf die Konsole aus. Die Konsole k\u00f6nnte z.B. dann so aussehen: m\u00f6gliche Konsolenausgaben o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,1 ) --> ( 2 ,3 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 2 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,2 ) --> ( 2 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 0 ,2 ) ( 2 ,3 ) --> ( 2 ,1 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,3 ) --> ( 2 ,1 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,0 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,2 ) --> ( 2 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,6 ) --> ( 2 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,4 ) --> ( 2 ,4 ) --- o o o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 3 ,1 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o --- ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 2 ,4 ) ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o o --- ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o --- ( 3 ,3 ) --> ( 3 ,5 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o --- ( 4 ,5 ) --> ( 2 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 2 ,6 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o --- ( 4 ,1 ) --> ( 4 ,3 ) ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o o --- ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 4 ,4 ) --> ( 4 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) ( 6 ,2 ) --> ( 4 ,2 ) --- o o o o o o o o o o --- ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o --- ( 5 ,4 ) --> ( 5 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o --- ( 4 ,2 ) --> ( 6 ,2 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o o o o o o o Dabei steht z.B. --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- f\u00fcr die in dem Zustand dar\u00fcber m\u00f6glichen Z\u00fcge. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 3 Solitaire.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 package aufgaben.aufgabe3 ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( this . field [ row ][ col ] == State . USED ) System . out . print ( \"o \" ); else System . out . print ( \" \" ); } System . out . println (); } System . out . println (); } public boolean possibleFrom ( int row , int col ) { if ( row >= 0 && row < 7 && col >= 0 && col < 7 && this . field [ row ][ col ] == State . USED ) { // up ? if ( row > 1 && this . field [ row - 1 ][ col ] == State . USED && this . field [ row - 2 ][ col ] == State . FREE ) return true ; // down ? if ( row < 5 && this . field [ row + 1 ][ col ] == State . USED && this . field [ row + 2 ][ col ] == State . FREE ) return true ; // right ? if ( col < 5 && this . field [ row ][ col + 1 ] == State . USED && this . field [ row ][ col + 2 ] == State . FREE ) return true ; // left ? if ( col > 1 && this . field [ row ][ col - 1 ] == State . USED && this . field [ row ][ col - 2 ] == State . FREE ) return true ; } return false ; } public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; // there is at least one To-Point int nrOfPossibleTos = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) nrOfPossibleTos ++ ; Point [] tos = new Point [ nrOfPossibleTos ] ; int index = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow - 2 , fromCol ); if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow + 2 , fromCol ); if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol + 2 ); if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol - 2 ); return tos ; } public Moves possibleMoves () { Moves possibleMoves = new Moves (); for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) { Point [] tos = this . possibleTo ( row , col ); Point from = new Point ( row , col ); for ( int index = 0 ; index < tos . length ; index ++ ) { possibleMoves . addMove ( new Move ( from , tos [ index ] )); } } } } // next line for debug possibleMoves . printMoves (); return possibleMoves ; } public boolean movePossible () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) return true ; } } return false ; } public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; else { Moves possibleMoves = this . possibleMoves (); try { Move move = possibleMoves . getMoveAtIndex ( 0 ); this . move ( move ); return true ; } catch ( IllegalArgumentException e ) { System . out . println ( \"Zug nicht moeglich! Index : 0\" ); return false ; } } } public void move ( Move move ) throws IllegalArgumentException { Point from = move . getFrom (); Point to = move . getTo (); int fromRow = from . getRow (); int fromCol = from . getCol (); int toRow = to . getRow (); int toCol = to . getCol (); int middleRow = ( fromRow + toRow ) / 2 ; int middleCol = ( fromCol + toCol ) / 2 ; try { this . field [ fromRow ][ fromCol ] = State . FREE ; this . field [ middleRow ][ middleCol ] = State . FREE ; this . field [ toRow ][ toCol ] = State . USED ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"Zug nicht moeglich! (\" + fromRow + \", \" + fromCol + \") --> \" + \"( \" + toRow + \", \" + toCol + \") \" ); } } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package aufgaben.aufgabe3 ; public class Testklasse { public static void main ( String [] args ) { Solitaire s = new Solitaire (); s . print (); while ( s . moveFirstPossible ()) { s . print (); } s . print (); } } Aufgabe 4 (test-driven development) \u00b6 Aufgabe 4 Implementieren Sie eine Methode public static int singleNumber(int[] nums) durch testgetriebene Entwicklung. F\u00fcr nums soll Folgendes gelten: es ist nicht leer, d.h. 1 <= nums.length , jede Zahl in nums ist genau zwei Mal in nums enthalten, bis auf eine - diese existiert nur genau ein Mal in nums Die Methode gibt die Zahl zur\u00fcck, die nur genau ein Mal in nums enthalten ist. Bsp.: // Beispiel 1 Input: nums = [ 2 ,2,1 ] Output: 1 // Beispiel 2 Input: nums = [ 4 ,1,2,1,2 ] Output: 4 // Beispiel 3 Input: nums = [ 1 ] Output: 1 Sie k\u00f6nnen beliebig viele weitere Methoden implementieren, die Ihnen helfen. Diese m\u00fcssen aber auch testgetrieben entwickelt werden. Pushen Sie alle Klassen (also nat\u00fcrlich auch die Testklasse) in Ihr Remote-Repository. Aufgabe 5 (Operationen \u00fcber Mengen) \u00b6 Aufgabe 5 Implementieren Sie eine Klasse SetOperations . Erstellen Sie drei Objektvariablen (z.B. numbers1 , numbers2 und both ) vom Typ Set<Integer> . Erzeugen Sie f\u00fcr diese Objektvariablen TreeSet -Objekte. Erstellen Sie eine Objektmethode fill() . In dieser Methode sollen die beiden Sets numbers1 und numbers2 mit Zufallszahlen aus dem Wertebereich 0..99 bef\u00fcllt werden. Erzeugen Sie jeweils 100 Zufallszahlen (die number s-Sets werden dann aber jeweils weniger als 100 Eintr\u00e4ge haben, da doppelte Elemente nicht aufgenommen werden.) Beachten Sie, dass die nextInt() -Methode ein int zur\u00fcckliefert. Dieses int muss zun\u00e4chst in ein Integer -Objekt umgewandelt werden ( Integer.valueOf(int) ) und dieses Integer -Objekt wird dann dem Set hinzugef\u00fcgt (wenn es nicht schon enthalten ist). Erstellen Sie eine Objektmethode fillBothUnion() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einer Vereinigung der Mengen numbers1 und numbers2 entspricht. F\u00fcr Methoden auf Mengen siehe z.B. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html . Erstellen Sie eine Objektmethode fillBothIntersection() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einem Schnitt der Mengen numbers1 und numbers2 entspricht. Erstellen Sie eine Objektmethode fillBothDifference() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both der Differenz der Menge numbers1 minus der Menge numbers2 entspricht. Schreiben Sie eine Methode print() so, dass jede Menge als ein Quadrat (10x10) aus Punkten auf der Konsole erscheint. Es wird ein Punkt gezeichnet, wenn die entsprechende Zahl (die 100 Punkte bilden die Zahlen 0..99 ab) in der Menge enthalten ist und es wird kein Punkt gezeichnet, wenn die Zahl nicht vorhanden ist. (Anstelle von Punkten k\u00f6nnen Sie auch jedes beliebige Zeichen ( o, *, #, x, ... ) verwenden). Gestalten Sie die Ausgabe so, dass die drei Mengen numbers1 , numbers2 und both nebeneinander auf der Konsole erscheinen. Testen Sie alle drei Methoden fillBothUnion() , fillBothIntersection() und fillBothDifference() . Die Ausgabe k\u00f6nnte wie folgt sein ( A stellt die Menge numbers1 dar, B die Menge numbers2 und rechts ist jeweils die both -Menge dargestellt): Tipps : F\u00fcr die schwarzen Punkte habe ich das Character '\\u25cf' verwendet (ein passendes Leerzeichen dazu ist '\\u2009' ). Das Zeichen f\u00fcr die Vereinigung ist '\\u222a' und f\u00fcr den Schnitt '\\u2229' . Schauen Sie sich auch im Skript Mengenoperationen an. Aufgabe 6 (Maps) \u00b6 Aufgabe 6 Testen Sie folgenden Code: long a = 1000 ; Integer b = 1000 ; Integer c = 1000 ; System . out . println ( a == b ); System . out . println ( b == c ); Was stellen Sie fest und warum? \u00c4ndern Sie den Vergleich der Variablen b und c so, dass true ausgegeben wird. Die ersten drei Zeilen bleiben dabei unver\u00e4ndert. Sie ben\u00f6tigen also einen anderen Vergleich als b == c . Erstellen Sie eine Klasse PizzaMenu . Erzeugen Sie darin eine HashMap und f\u00fcgen Sie folgende Pizzen mit ihren Preisen ein: Pizza Preis Margherita 7,00 Veggie 7,50 Salami 8,50 Schinken 8,50 Schreiben Sie eine Methode public static boolean existingPizza(Map<String,Double> menu, String pizza) , die testet, ob eine eingegebene Pizza im Men\u00fc existiert. Schreiben Sie eine Methode public static void printPrice(Map<String,Double> menu, String pizza) , die f\u00fcr eine eingegebene Pizza den Preis ausgibt. Verwenden Sie dazu existingPizza() . Beispielausgabe: Salami: 8 .50 Euro Hawaii: Diese Pizza gibt es nicht. Schreiben Sie eine printMenu() -Methode, die ausgibt, wie viele Pizzen es im Men\u00fc gibt. Wenn das Men\u00fc nicht leer ist, sollen zudem alle Pizzen mit ihrem Preis ausgegeben werden. Beispielausgabe: // Beispiel fuer leeres Menue ############## Das Menu enth\u00e4lt 0 Pizzen. ############## // Beispiel fuer Menue ############## Das Menu enth\u00e4lt 4 Pizzen. Pizza Margherita: 7 .00 Euro Pizza Salami: 8 .50 Euro Pizza Schinken: 8 .50 Euro Pizza Veggie: 7 .50 Euro ############## \u00c4ndern Sie den Preis der Schinken -Pizza in der HashMap zu 8,20 . Schreiben Sie eine Methode public static void affordablePizza(Map<String,Double> menu, double maxPrice) , die alle Pizzen ausgibt, die man sich f\u00fcr einen bestimmten Betrag leisten kann. Beispielausgabe: Eingegebener Betrag: 4 .0 Euro Leider gibt es zu diesem Preis keine Pizza. Eingegebener Betrag: 8 .0 Euro M\u00f6gliche Pizzen: [ Margherita, Veggie ] Das Menu wird \u00fcberarbeitet, l\u00f6schen Sie daher alle Eintr\u00e4ge. F\u00fcllen Sie das Men\u00fc anschlie\u00dfend mit diesen neuen Pizzen: Pizza Preis Verde 7,00 Hawaii 8,20 Tradizionale 8,50 Legen Sie ein zweites Men\u00fc an und kopieren Sie alle Eintr\u00e4ge aus dem ersten Men\u00fc hinein. L\u00f6schen Sie im zweiten Men\u00fc die Pizza Hawaii und geben Sie die Namen aller noch verf\u00fcgbaren Pizzen aus. Finden Sie in Ihrem Code ein Beispiel f\u00fcr Auto-Boxing und schreiben Sie einen entsprechenden Kommentar.","title":"Aufgaben"},{"location":"aufgaben/#aufgaben","text":"","title":"Aufgaben"},{"location":"aufgaben/#aufgabe-1-wurfelspiel","text":"Aufgabe 1 Vorbereitung (Selbstudium) Informieren Sie sich \u00fcber die Klasse JOptionPane aus dem Paket javax.swing (z.B. hier oder hier oder hier ) Sollten Sie mit dem Java-Modulsystem arbeiten, d.h. sollten Sie in Ihrem Java-Projekt eine Datei module-info.java haben, dann m\u00fcssen Sie in diese Datei (in den Anweisungsblock) die Anweisung requires java.desktop; einf\u00fcgen - das ist das Modul, in dem sich das Paket javax.swing befindet. Rufen Sie jeweils die statischen Methoden showConfirmDialog() , showInputDialog() , showMessageDialog() und showOptionDialog() auf und werten Sie jeweils die Nutzereingabe aus (Bei showInputDialog() ist die R\u00fcckgabe ein String , ansonsten ist die R\u00fcckgabe ein int , der mit folgenden Optionen verglichen werden kann: JOptionPane.YES_OPTION , JOptionPane.NO_OPTION , JOptionPane.CANCEL_OPTION , JOptionPane.OK_OPTION , JOptionPane.CLOSED_OPTION Erstellen Sie insbesondere folgenden Dialog und pr\u00fcfen Sie, ob der Nein - oder der Ja -Button gedr\u00fcckt wurde (im Beispiel steht A f\u00fcr den Namen eines Spielers \u2013 siehe Aufgabe unten): Aufgabe Implementieren Sie folgendes W\u00fcrfelspiel: An dem Spiel k\u00f6nnen beliebig viele Spieler teilnehmen. Die Spieler sind nacheinander an der Reihe. Wenn ein Spieler an der Reihe ist, dann befindet er sich in einem Versuch . In einem Versuch kann der Spieler so lange w\u00fcrfeln, bis er entweder eine 6 w\u00fcrfelt oder er den Versuch freiwillig beendet. Hat der Spieler eine 6 gew\u00fcrfelt, wird der gesamte Versuch mit 0 Punkten bewertet. Hat der Spieler den Versuch freiwillig beendet, wird die in dem Versuch erzielte Summe aus sein Punktekonto addiert (gespeichert). Der Spieler, der zuerst eine bestimmte Punktzahl (z.B. 20 ) erreicht hat, hat gewonnen. Beispiel mit zwei Spielern A und B bis Gesamtpunktzahl 20 : Committen und pushen Sie Ihre L\u00f6sung nach GitHub (oder Ihrem Git-Diensteanbieter). eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 1 Spiel.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 package aufgaben.aufgabe1 ; import javax.swing.JOptionPane ; public class Spiel { public static int siegPunkte ; private Spieler [] spieler ; Spiel () { int anzSpieler = 0 ; int siegPunkte = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Anzahl Spieler :\" ); inputOk = true ; anzSpieler = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } inputOk = false ; while ( ! inputOk ) { try { input = JOptionPane . showInputDialog ( \"Siegpunkte :\" ); inputOk = true ; siegPunkte = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; namenErmitteln (); } Spiel ( int siegPunkte , int anzSpieler ) { Spiel . siegPunkte = siegPunkte ; spieler = new Spieler [ anzSpieler ] ; /* Spielernamen sind A, B, C ... char name = 'A'; for(int i=0; i<spieler.length; i++) { spieler[i] = new Spieler(String.valueOf(name)); name ++; } */ /* Spielernamen werden eingegeben * wenn man namenErmitteln() auskommentiert, * kann man die obige for-Schleife nehmen, damit * man nicht immer die Spielernamen eingeben muss * - zum Testen */ namenErmitteln (); } private void namenErmitteln () { String name = \"\" ; for ( int i = 0 ; i < spieler . length ; i ++ ) { name = JOptionPane . showInputDialog ( \"Name des Spielers \" + ( i + 1 ) + \" :\" ); spieler [ i ] = new Spieler ( name ); } } public void spielen () { int index = 0 ; boolean gewonnen = false ; while ( ! gewonnen ) { gewonnen = spieler [ index ] . wuerfeln (); index = ( index < spieler . length - 1 ) ? index + 1 : 0 ; } } public static void main ( String [] args ) { //Spiel spiel = new Spiel(30, 3); Spiel spiel = new Spiel (); spiel . spielen (); } } Spieler.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 package aufgaben.aufgabe1 ; import java.util.Random ; import javax.swing.JOptionPane ; public class Spieler { private String name ; private int aktStand ; private Random r ; Spieler ( String name ) { aktStand = 0 ; this . name = name ; r = new Random (); } public int getAktStand () { return this . aktStand ; } public boolean wuerfeln () { System . out . printf ( \"%n%nSpieler %s ist an der Reihe (bisher %d Punkte) %n ----------------------------------------- %n\" , this . name , this . aktStand ); int reihe = 0 ; int wurf = 0 ; boolean ende = false ; while ( ! ende ) { wurf = r . nextInt ( 6 ) + 1 ; System . out . printf ( \"%s hat eine %d gewuerfelt %n\" , this . name , wurf ); if ( wurf == 6 ) { System . out . printf ( \"Versuch zu Ende %n Aktueller Spielstand von %s : %d Punkte %n Der naechste Spieler ist dran%n\" , this . name , this . aktStand ); ende = true ; } else if ( aktStand + reihe + wurf >= Spiel . siegPunkte ) { System . out . printf ( \"%s hat insgesamt %d Punkte und somit gewonnen !!!\" , this . name , ( aktStand + reihe + wurf )); return true ; } else // eine 1..5 gewuerfelt und noch nicht gewonnen { reihe += wurf ; System . out . printf ( \"in diesem Versuch bisher %d Punkte -- insgesamt %d Punkte %n\" , reihe , ( aktStand + reihe )); int dialogResult = JOptionPane . showConfirmDialog ( null , this . name + \", wollen Sie weiter wuerfeln? \" , \"Weiter wuerfeln?\" , JOptionPane . YES_NO_OPTION ); ende = ! ( dialogResult == JOptionPane . YES_OPTION ); if ( ende ) { aktStand += reihe ; } } } return false ; } }","title":"Aufgabe 1 (W\u00fcrfelspiel)"},{"location":"aufgaben/#aufgabe-2-myinteger","text":"Aufgabe 2 Vorbereitung (Selbstudium) Eine statische Variable wird mit dem Schl\u00fcsselwort static deklariert, also z.B. static int myVariable = 0; . Der Zugriff auf eine solche statische Variable erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Variable myVariable wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Variable \u00fcber MyClass.myVariable . F\u00fcr Objektvariablen gilt, dass jedes Objekt seine eigene(n) Objektvariable(n) hat. Statische Variablen gibt es in der Klasse genau einmal. Alle Objekte \"teilen\" sich eine statische Variable. Eine statische Variable hei\u00dft deshalb auch Klassenvariable . Eine statische Methode wird ebenfalls mit dem Schl\u00fcsselwort static deklariert, also z.B. public static void myMethod() {} . Der Zugriff auf eine solche statische Methode erfolgt nicht \u00fcber eine Referenzvariable, sondern \u00fcber den Klassennamen. Angenommen, die Methode myMethod() wurde in der Klasse MyClass deklariert, dann erfolgt der Zugriff auf die Methode \u00fcber MyClass.myMethod() . Wir kennen solche Methoden bereits, z.B. sind alle Methoden aus der Klasse Math statisch und wir k\u00f6nnen sie z.B. mit Math.sqrt(value) oder Math.abs(value) aufrufen. siehe z.B. hier oder hier oder hier Info : Die Klasse MyInteger ist eine sogenannte Wrapper -Klasse. Die Idee ist, dass MyInteger eine objektorientierte H\u00fclle um den int -Typ darstellt. Implementieren Sie die Klasse MyInteger . Diese Klasse hat folgende Eigenschaften: Statische Konstanten vom Typ int MAX_VALUE und MIN_VALUE , welche als Wert die gr\u00f6\u00dfte bzw. kleinste int -Zahl enthalten. Eine private Objektvariable value vom Typ int . (Dieser value hat jetzt eine \"objektorientierte\" H\u00fclle: MyInteger ). Eine statische Methode parseInt(String s) , die den \u00fcbergebenen String s als int -Zahl zur\u00fcckgibt, wenn s einer Zahl entspricht. Wenn nicht, wirft die Methode eine IllegalArgumentException . Beachten Sie: a. s kann mit + oder \u2013 beginnen, b. s kann f\u00fchrende Nullen aufweisen, c. die L\u00e4nge von s kann mit s.length() ermittelt und jedes einzelne Zeichen aus s kann mit s.charAt(index) betrachtet werden. d. Ist s leer, wird eine IllegalArgumentException geworfen und wenn s keiner Zahl entspricht auch. e. Die Exception wird nur weitergereicht, nicht hier behandelt. Zwei Konstruktoren MyInteger(int value) und MyInteger(String s) , die jeweils die Objektvariable value initialisieren. Der zweite Konstruktor verwendet parseInt(String) und kann ebenfalls eine IllegalArgumentException werfen (reicht die Exception von parseInt(String) weiter). Eine Objektmethode intValue() , die den Wert von value zur\u00fcckgibt. Eine Objektmethode doubleValue() , die den Wert von value als double zur\u00fcckgibt. Eine statische Methode valueOf(String s) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt (und evtl. eine IllegalArgumentException wirft). Eine statische Methode valueOf(int value) , die ein Objekt von MyInteger erzeugt und zur\u00fcckgibt. \u00dcberschreiben Sie au\u00dferdem die Methoden equals() und toString() ( Zusatz: auch hashCode() \u00fcberschreiben). Testen Sie Ihre Klasse ausf\u00fchrlich in einer Testklasse mit main() -Methode. Committen und pushen Sie Ihre L\u00f6sung nach GitHub (oder Ihrem Git-Diensteanbieter). eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 2 MyInteger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 package aufgaben.aufgabe2 ; public class MyInteger { public static final int MAX_VALUE = 2147483647 ; public static final int MIN_VALUE = - 2147483648 ; private int value ; public MyInteger ( int value ) { this . value = value ; } public MyInteger ( String s ) throws IllegalArgumentException { this . value = parseInt ( s ); } private static boolean isDigit ( char c ) { return ( c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' ); } private static int charToInt ( char c ) { int asciivalue = c ; int intvalue = asciivalue - 48 ; // 0 ist 048 bis 9 ist 057 return intvalue ; } public static int parseInt ( String s ) throws IllegalArgumentException { boolean negativ = false ; if ( s . length () == 0 ) throw new IllegalArgumentException ( \"leer\" ); // pruefe, ob erstes Zeichen + oder - // merken und weiter mit Rest if ( s . charAt ( 0 ) == '+' ) s = s . substring ( 1 ); else if ( s . charAt ( 0 ) == '-' ) { s = s . substring ( 1 ); negativ = true ; } if ( s . length () == 0 ) throw new IllegalArgumentException ( \"nur '+' bzw. '-' --> keine Zahl\" ); // entferne f\u00fchrende Nullen while ( s . charAt ( 0 ) == '0' ) { s = s . substring ( 1 ); } for ( int i = 0 ; i < s . length (); i ++ ) { if ( ! isDigit ( s . charAt ( i ))) throw new IllegalArgumentException ( \"keine Zahl!\" ); } int exponent = 0 ; int zahl = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; i -- ) { zahl = zahl + charToInt ( s . charAt ( i )) * ( int ) Math . pow ( 10 , exponent ); exponent ++ ; } if ( negativ ) return - zahl ; else return zahl ; } public int intValue () { return this . value ; } public double doubleValue () { return this . value ; } public static MyInteger valueOf ( String s ) throws IllegalArgumentException { return new MyInteger ( s ); } public static MyInteger valueOf ( int value ) { return new MyInteger ( value ); } @Override public boolean equals ( Object other ) { if ( other == null ) return false ; if ( this == other ) return true ; if ( this . getClass () != other . getClass ()) return false ; MyInteger otherInt = ( MyInteger ) other ; return ( this . value == otherInt . value ); } @Override public int hashCode () { return this . value ; } @Override public String toString () { return value + \"\" ; } public static int compare ( int x , int y ) { return ( x < y ) ? - 1 : (( x == y ) ? 0 : 1 ); } public int compareTo ( MyInteger otherMyInteger ) { return compare ( this . value , otherMyInteger . value ); } } MyIntegerMain.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 package aufgaben.aufgabe2 ; public class MyIntegerMain { public static void main ( String [] args ) { MyInteger mi1 = null , mi2 = null , mi3 = null , mi4 = null , mi5 = null , mi6 = null , mi7 = null , mi8 = null , mi9 = null , mi10 = null ; try { mi1 = new MyInteger ( \"-2147483648\" ); System . out . println ( mi1 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi2 = new MyInteger ( \"-00002147483648\" ); System . out . println ( mi2 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi3 = new MyInteger ( \"hallo\" ); System . out . println ( mi3 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi4 = new MyInteger ( - 2147483648 ); try { mi5 = MyInteger . valueOf ( \"-2147483648\" ); System . out . println ( mi5 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi6 = MyInteger . valueOf ( \"-00002147483648\" ); System . out . println ( mi6 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi7 = MyInteger . valueOf ( \"hallo\" ); System . out . println ( mi7 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } mi8 = MyInteger . valueOf ( - 2147483648 ); try { mi9 = MyInteger . valueOf ( \"\" ); System . out . println ( mi9 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } try { mi10 = MyInteger . valueOf ( \"+\" ); System . out . println ( mi10 . intValue ()); } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } System . out . println ( \"mi1 equals mi2 ? : \" + mi1 . equals ( mi2 )); System . out . println ( \"mi1 equals mi3 ? : \" + mi1 . equals ( mi3 )); System . out . println ( \"mi1 equals mi4 ? : \" + mi1 . equals ( mi4 )); System . out . println ( \"mi1 equals mi5 ? : \" + mi1 . equals ( mi5 )); System . out . println ( \"mi1 equals mi6 ? : \" + mi1 . equals ( mi6 )); System . out . println ( \"mi1 equals mi7 ? : \" + mi1 . equals ( mi7 )); System . out . println ( \"mi1 equals mi8 ? : \" + mi1 . equals ( mi8 )); System . out . println ( \"mi1 equals mi9 ? : \" + mi1 . equals ( mi9 )); System . out . println ( \"mi1 equals mi10 ? : \" + mi1 . equals ( mi10 )); System . out . println ( \"hashCode mi1 : \" + mi1 . hashCode ()); System . out . println ( \"hashCode mi2 : \" + mi2 . hashCode ()); try { System . out . println ( \"hashCode mi3 : \" + mi3 . hashCode ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"hashCode mi4 : \" + mi4 . hashCode ()); System . out . println ( \"intValue mi1 : \" + mi1 . intValue ()); System . out . println ( \"intValue mi2 : \" + mi2 . intValue ()); try { System . out . println ( \"intValue mi3 : \" + mi3 . intValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"intValue mi4 : \" + mi4 . intValue ()); System . out . println ( \"doubleValue mi1 : \" + mi1 . doubleValue ()); System . out . println ( \"doubleValue mi2 : \" + mi2 . doubleValue ()); try { System . out . println ( \"doubleValue mi3 : \" + mi3 . doubleValue ()); } catch ( NullPointerException e ) { System . out . println ( \"Objekt existiert nicht!\" ); } System . out . println ( \"doubleValue mi4 : \" + mi4 . doubleValue ()); } } MyIntegerTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 package aufgaben.aufgabe2 ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.Test ; class MyIntegerTest { static MyInteger mi1 , mi2 , mi3 , mi4 , mi5 , mi6 , mi7 ; @BeforeAll public static void setUpBeforeClass () throws Exception { mi1 = new MyInteger ( \"-2147483648\" ); mi2 = new MyInteger ( \"+2147483647\" ); mi3 = new MyInteger ( - 1 ); mi4 = new MyInteger ( 1 ); mi5 = new MyInteger ( 0 ); mi6 = new MyInteger ( \"-1\" ); mi7 = new MyInteger ( 2147483647 ); } @Test void testHashCode () { assertTrue ( mi2 . hashCode () == mi7 . hashCode (), \" hashCode of mi2 and mi7 should be equal\" ); assertEquals ( - 2147483648 , mi1 . hashCode (), \"hashCode of mi1 should be -2147483648\" ); assertEquals ( 0 , mi5 . hashCode (), \"hashCode of mi5 should be 0\" ); } @Test void testMyIntegerInt () { assertNotNull ( mi4 , \"mi4 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testMyIntegerString () { assertNotNull ( mi1 , \"mi1 should be not null\" ); assertNotNull ( mi2 , \"mi2 should be not null\" ); assertNotNull ( mi6 , \"mi6 should be not null\" ); assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); } @Test void testParseInt () { assertEquals ( - 2147483648 , MyInteger . parseInt ( \"-2147483648\" ), \"should be -2147483648\" ); assertEquals ( + 2147483647 , MyInteger . parseInt ( \"+00002147483647\" ), \"should be +2147483647\" ); assertEquals ( - 1 , MyInteger . parseInt ( \"-0000001\" ), \"should be -1\" ); } @Test void testIntValue () { assertEquals ( - 2147483648 , mi1 . intValue (), \"should be -2147483648\" ); assertEquals ( + 2147483647 , mi2 . intValue (), \"should be +2147483647\" ); assertEquals ( + 2147483647 , mi7 . intValue (), \"should be +2147483647\" ); } @Test void testDoubleValue () { assertEquals ( - 2147483648.0 , mi1 . doubleValue (), \"should be -2147483648.0\" ); assertEquals ( + 2147483647.0 , mi2 . doubleValue (), \"should be +2147483647.0\" ); assertEquals ( + 2147483647.0 , mi7 . doubleValue (), \"should be +2147483647.0\" ); } @Test void testValueOfString () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( \"-2147483648\" )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( \"2147483647\" )), \"should be equal to mi7\" ); } @Test void testValueOfInt () { assertTrue ( mi1 . equals ( MyInteger . valueOf ( - 2147483648 )), \"should be equal to mi1\" ); assertTrue ( mi2 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi2\" ); assertTrue ( mi7 . equals ( MyInteger . valueOf ( 2147483647 )), \"should be equal to mi7\" ); } @Test void testEqualsObject () { assertTrue ( mi3 . equals ( mi6 ), \"mi3 and mi6 should be equal\" ); assertTrue ( mi7 . equals ( mi2 ), \"mi7 and mi2 should be equal\" ); assertFalse ( mi3 . equals ( mi4 ), \"mi3 and mi4 should not be equal\" ); assertFalse ( mi3 . equals ( mi5 ), \"mi3 and mi5 should not be equal\" ); } @Test void testToString () { assertEquals ( \"-2147483648\" , mi1 . toString (), \"should be '-2147483648'\" ); assertEquals ( \"2147483647\" , mi2 . toString (), \"should be '2147483647' mi2\" ); assertEquals ( \"2147483647\" , mi7 . toString (), \"should be '2147483647' mi7\" ); } @Test void testCompare () { assertTrue ( MyInteger . compare ( 5 , 4 ) > 0 , \"5,4 should be > 0\" ); assertTrue ( MyInteger . compare ( 4 , 4 ) == 0 , \"4,4 should be == 0\" ); assertTrue ( MyInteger . compare ( 4 , 5 ) < 0 , \"4,5 should be < 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MIN_VALUE ) > 0 , \"MAX,MIN should be > 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MAX_VALUE , MyInteger . MAX_VALUE ) == 0 , \"MAX,MAX should be == 0\" ); assertTrue ( MyInteger . compare ( MyInteger . MIN_VALUE , MyInteger . MAX_VALUE ) < 0 , \"MIN,MAX should be > 0\" ); } @Test void testCompareTo () { assertTrue ( mi1 . compareTo ( mi2 ) < 0 , \"mi1, mi2 should be < 0\" ); assertTrue ( mi2 . compareTo ( mi1 ) > 0 , \"mi2, mi1 should be > 0\" ); assertTrue ( mi2 . compareTo ( mi7 ) == 0 , \"mi2, mi7 should be == 0\" ); assertTrue ( mi3 . compareTo ( mi6 ) == 0 , \"mi3, mi6 should be == 0\" ); } }","title":"Aufgabe 2 (MyInteger)"},{"location":"aufgaben/#aufgabe-3-solitaire","text":"Aufgabe 3 Information und Vorbereitung Wir beginnen, ein Englisches Solit\u00e4r zu programmieren. Einige kennen es auch als Steckhalma. Ziel des Spiels ist, alle Steine bis auf einen (der am besten in der Mitte \u00fcbrig bleibt), zu entfernen. Ein Zug ist wie folgt: ein Stein springt \u00fcber einen anderen Stein und der \u00fcbersprungene Stein wird entfernt. Es gibt viele L\u00f6sungen daf\u00fcr. Einige Klassen sind bereits gegeben: Klasse Point.java package aufgaben.aufgabe3 ; /* * ein Point repreasentiert eine Position * im Spielfeld, bestehend aus der Nummer * fuer die Zeile (row) und der Nummer * fuer die Spalte (col) */ public class Point { private int row ; private int col ; /* * Konstruktor zur Erzeugung einer * Position bestehend aus row und col */ public Point ( int row , int col ) { this . row = row ; this . col = col ; } public int getRow () { return this . row ; } public int getCol () { return this . col ; } @Override public String toString () { return \"(\" + this . row + \",\" + this . col + \")\" ; } } Klasse Move.java ```java package aufgaben.aufgabe3; /* * diese Klasse repraesentiert einen Zug * Variablen sind Point from * und Point to * es wird nicht geprueft, ob der Zug ueberhaupt * moeglich ist */ public class Move { private Point from; private Point to; /* * ein Zug von dem from-Point (fromRow,fromCol) * zum to-Point (toRow,toCol) */ public Move(int fromRow, int fromCol, int toRow, int toCol) { this.from = new Point(fromRow, fromCol); this.to = new Point(toRow, toCol); } /* * in dem Konstruktor werden in this.from und this.to nicht einfach * die Referenzen von from und to gespeichert, sondern davon Kopien * erstellt, damit das Programm robuster gegen das Aendern von * Referenzen ist */ public Move(Point from, Point to) { this.from = new Point(from.getRow(), from.getCol()); this.to = new Point(to.getRow(), to.getCol()); } /* * der Getter fuer den Point from gibt keine Referenz auf * den Point from zurueck, sondern eine Kopie (einen Klon) * von from --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getFrom() { return new Point(this.from.getRow(), this.from.getCol()); } /* * der Getter fuer den Point to gibt keine Referenz auf * den Point to zurueck, sondern eine Kopie (einen Klon) * von to --> Referenzen koennen \"verbogen\" werden, aber * die Kopien bleiben unveraendert */ public Point getTo() { return new Point(this.to.getRow(), this.to.getCol()); } } Klasse Moves.java package aufgaben.aufgabe3 ; /* * diese Klasse repraesentiert eine Folge * von Zuegen (Move), die in einem Array * moves gespeichert sind */ public class Moves { private Move [] moves ; /* * der Konstruktor erstellt ein leeres moves-Array * (d.h. noch keine Zuege (Moves) gespeichert) */ public Moves () { this . moves = new Move [ 0 ] ; } /* * der Konstruktor erstellt ein moves-Array mit einem * Move - dem erste Zug (firstMove) */ public Moves ( Move firstMove ) { this . moves = new Move [ 1 ] ; this . moves [ 0 ] = firstMove ; } /* * Anzahl der bisher gespeicherten Zuege */ public int getLength () { return this . moves . length ; } /* * fuegt einen Zug (nextMove) zum moves-Array hinzu * dazu muss das moves-Array um 1 laenger sein als zuvor * es wird eine Kopie aller Zuege erstellt und dann * der nextMove hinzugefuegt */ public void addMove ( Move nextMove ) { Move [] newMoves = new Move [ this . moves . length + 1 ] ; for ( int index = 0 ; index < this . moves . length ; index ++ ) { newMoves [ index ] = this . moves [ index ] ; } newMoves [ newMoves . length - 1 ] = new Move ( nextMove . getFrom (), nextMove . getTo ()); this . moves = newMoves ; } /* * gibt den Move zurueck, der im moves-Array unter dem Index index * gespeichert ist; * kann sein, dass index kein korrekter Index im moves-Array ist, * dann wird eine IllegalArgumentException geworfen */ public Move getMoveAtIndex ( int index ) throws IllegalArgumentException { try { return this . moves [ index ] ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"kein gueltiger Index!\" ); } } /* * Ausgabe aller im moves-Array gespeicherten Zuege * wird nur zum Debuggen benoetigt */ public void printMoves () { System . out . printf ( \"%n---%n\" ); for ( int index = 0 ; index < this . moves . length ; index ++ ) { Move move = this . moves [ index ] ; Point from = move . getFrom (); Point to = move . getTo (); System . out . println ( from . toString () + \" --> \" + to . toString ()); } System . out . printf ( \"%n---%n%n\" ); } } enum State.java package aufgaben.aufgabe3 ; /* * FREE - der Platz ist ein Spielfeld, aber kein Spielstein drauf * USED - der Platz ist ein Spielfeld mit Spielstein drauf * NOT - der Platz gehoert nicht zum Spielfeld */ public enum State { FREE , USED , NOT } Aufgabe Bef\u00fcllen Sie die Klasse Solitaire.java , wie in den Kommentaren beschrieben: Klasse Solitaire.java package aufgaben.aufgabe3.loesung ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } /* * Geben Sie das Spielfeld aus! Am Anfang sollte auf der * Konsole so ein Bild erscheinen: * o o o * o o o * o o o o o o o * o o o o o o * o o o o o o o * o o o * o o o * */ public void print () { } /* * diese Methode gibt ein true zurueck, wenn von der * uebergebenen Position (row,col) ein Zug moeglich ist * d.h. * 1. auf der angegebenen Position muss ein Stein sein * 2. zwei Steine weiter (oben, unten, rechts oder links) * darf kein Stein sein * 3. dazwischen muss ein Stein sein */ public boolean possibleFrom ( int row , int col ) { return false ; } /* * diese Methode gibt alle Positionen (Point) zurueck, * AUF die von (fromRow,fromCol) aus gesprungen werden * kann */ public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; // naechste Zeile muss entfernt werden! return null ; } /* * diese Methode erzeugt ein Moves-Objekt * in dieses Moves-Objekt werden mithilfe der * Objektmethode addMove() (aus Moves) alle * moeglichen Zuege hinzugefuegt * (moeglich im aktuellen Zustand von field[][]) */ public Moves possibleMoves () { Moves possibleMoves = new Moves (); // next line for debugging possibleMoves . printMoves (); return possibleMoves ; } /* * gibt ein true zurueck, wenn im aktuellen Zustand * von field[][] ueberhaupt noch ein Zug moeglich ist * sonst false */ public boolean movePossible () { return false ; } /* * ruft die Methode move(Move move) auf, * wenn ein Zug moeglich ist (dann true zurueck) * sonst false */ public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; /* * hier einen moeglichen Zug ausfuehren * den ersten, den Sie finden (siehe * possibleMoves() ) */ return true ; } /* * hier wird der Zug Move move ausgefuehrt * nach dem Zug ist * 1. die from-Position leer * 2. die to-Position mit einem Stein besetzt * 3. dazwischen leer (Stein wird \"entfernt\") * falls Zug nicht moeglich, wird eine * IllegalArgumentException geworfen */ public void move ( Move move ) throws IllegalArgumentException { } } Sie k\u00f6nnen selbstverst\u00e4ndlich beliebig viele weitere (Hilfs-)Methoden hinzuf\u00fcgen. Testen Sie Ihr Spiel in einer Testklasse . F\u00fchren Sie einige Z\u00fcge aus und geben danach immer das Spielfeld auf die Konsole aus. Die Konsole k\u00f6nnte z.B. dann so aussehen: m\u00f6gliche Konsolenausgaben o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,1 ) --> ( 2 ,3 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 2 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,2 ) --> ( 2 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 0 ,2 ) ( 2 ,3 ) --> ( 2 ,1 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,3 ) --> ( 2 ,1 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 1 ,3 ) ( 4 ,1 ) --> ( 2 ,1 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,0 ) --> ( 2 ,2 ) ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,2 ) --> ( 2 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 0 ,4 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) --- o o o o o o o o o o o o o o o o o o o o o o o o o --- ( 2 ,6 ) --> ( 2 ,4 ) ( 3 ,2 ) --> ( 1 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,4 ) --> ( 2 ,4 ) --- o o o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o o o o --- ( 0 ,2 ) --> ( 2 ,2 ) ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,0 ) --> ( 3 ,2 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,0 ) --> ( 2 ,0 ) ( 4 ,1 ) --> ( 2 ,1 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o o o --- ( 3 ,2 ) --> ( 1 ,2 ) ( 3 ,3 ) --> ( 3 ,1 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) --- o o o o o o o o o o o o o o o o o o o o --- ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o o o o --- ( 0 ,4 ) --> ( 2 ,4 ) ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o o --- ( 3 ,6 ) --> ( 3 ,4 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 4 ,5 ) --> ( 2 ,5 ) ( 4 ,6 ) --> ( 2 ,6 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o o o --- ( 3 ,3 ) --> ( 3 ,5 ) ( 3 ,4 ) --> ( 1 ,4 ) ( 3 ,4 ) --> ( 3 ,2 ) ( 4 ,3 ) --> ( 2 ,3 ) ( 5 ,2 ) --> ( 3 ,2 ) --- o o o o o o o o o o o o o o o o --- ( 4 ,5 ) --> ( 2 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o o --- ( 2 ,4 ) --> ( 2 ,6 ) ( 2 ,5 ) --> ( 2 ,3 ) ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) --- o o o o o o o o o o o o o --- ( 4 ,1 ) --> ( 4 ,3 ) ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o o --- ( 4 ,6 ) --> ( 4 ,4 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o o o --- ( 4 ,3 ) --> ( 4 ,5 ) ( 4 ,4 ) --> ( 4 ,2 ) ( 5 ,3 ) --> ( 3 ,3 ) ( 5 ,4 ) --> ( 3 ,4 ) ( 6 ,2 ) --> ( 4 ,2 ) --- o o o o o o o o o o --- ( 6 ,2 ) --> ( 4 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) --- o o o o o o o o o --- ( 5 ,4 ) --> ( 5 ,2 ) ( 6 ,3 ) --> ( 4 ,3 ) ( 6 ,4 ) --> ( 4 ,4 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o --- ( 4 ,2 ) --> ( 6 ,2 ) ( 5 ,2 ) --> ( 3 ,2 ) ( 6 ,4 ) --> ( 6 ,2 ) --- o o o o o o o o o o o o o o Dabei steht z.B. --- ( 1 ,3 ) --> ( 3 ,3 ) ( 3 ,1 ) --> ( 3 ,3 ) ( 3 ,5 ) --> ( 3 ,3 ) ( 5 ,3 ) --> ( 3 ,3 ) --- f\u00fcr die in dem Zustand dar\u00fcber m\u00f6glichen Z\u00fcge. eine m\u00f6gliche L\u00f6sung f\u00fcr Aufgabe 3 Solitaire.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 package aufgaben.aufgabe3 ; public class Solitaire { private Moves game ; private State [][] field ; public Solitaire () { this . game = new Moves (); this . field = new State [ 7 ][ 7 ] ; for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if (( row < 2 || row > 4 ) && ( col < 2 || col > 4 )) { this . field [ row ][ col ] = State . NOT ; } else { this . field [ row ][ col ] = State . USED ; } } } this . field [ 3 ][ 3 ] = State . FREE ; } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( this . field [ row ][ col ] == State . USED ) System . out . print ( \"o \" ); else System . out . print ( \" \" ); } System . out . println (); } System . out . println (); } public boolean possibleFrom ( int row , int col ) { if ( row >= 0 && row < 7 && col >= 0 && col < 7 && this . field [ row ][ col ] == State . USED ) { // up ? if ( row > 1 && this . field [ row - 1 ][ col ] == State . USED && this . field [ row - 2 ][ col ] == State . FREE ) return true ; // down ? if ( row < 5 && this . field [ row + 1 ][ col ] == State . USED && this . field [ row + 2 ][ col ] == State . FREE ) return true ; // right ? if ( col < 5 && this . field [ row ][ col + 1 ] == State . USED && this . field [ row ][ col + 2 ] == State . FREE ) return true ; // left ? if ( col > 1 && this . field [ row ][ col - 1 ] == State . USED && this . field [ row ][ col - 2 ] == State . FREE ) return true ; } return false ; } public Point [] possibleTo ( int fromRow , int fromCol ) { if ( ! possibleFrom ( fromRow , fromCol )) return new Point [ 0 ] ; // there is at least one To-Point int nrOfPossibleTos = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) nrOfPossibleTos ++ ; if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) nrOfPossibleTos ++ ; Point [] tos = new Point [ nrOfPossibleTos ] ; int index = 0 ; if ( fromRow > 1 && this . field [ fromRow - 1 ][ fromCol ] == State . USED && this . field [ fromRow - 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow - 2 , fromCol ); if ( fromRow < 5 && this . field [ fromRow + 1 ][ fromCol ] == State . USED && this . field [ fromRow + 2 ][ fromCol ] == State . FREE ) tos [ index ++] = new Point ( fromRow + 2 , fromCol ); if ( fromCol < 5 && this . field [ fromRow ][ fromCol + 1 ] == State . USED && this . field [ fromRow ][ fromCol + 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol + 2 ); if ( fromCol > 1 && this . field [ fromRow ][ fromCol - 1 ] == State . USED && this . field [ fromRow ][ fromCol - 2 ] == State . FREE ) tos [ index ++] = new Point ( fromRow , fromCol - 2 ); return tos ; } public Moves possibleMoves () { Moves possibleMoves = new Moves (); for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) { Point [] tos = this . possibleTo ( row , col ); Point from = new Point ( row , col ); for ( int index = 0 ; index < tos . length ; index ++ ) { possibleMoves . addMove ( new Move ( from , tos [ index ] )); } } } } // next line for debug possibleMoves . printMoves (); return possibleMoves ; } public boolean movePossible () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( possibleFrom ( row , col )) return true ; } } return false ; } public boolean moveFirstPossible () { if ( ! movePossible ()) return false ; else { Moves possibleMoves = this . possibleMoves (); try { Move move = possibleMoves . getMoveAtIndex ( 0 ); this . move ( move ); return true ; } catch ( IllegalArgumentException e ) { System . out . println ( \"Zug nicht moeglich! Index : 0\" ); return false ; } } } public void move ( Move move ) throws IllegalArgumentException { Point from = move . getFrom (); Point to = move . getTo (); int fromRow = from . getRow (); int fromCol = from . getCol (); int toRow = to . getRow (); int toCol = to . getCol (); int middleRow = ( fromRow + toRow ) / 2 ; int middleCol = ( fromCol + toCol ) / 2 ; try { this . field [ fromRow ][ fromCol ] = State . FREE ; this . field [ middleRow ][ middleCol ] = State . FREE ; this . field [ toRow ][ toCol ] = State . USED ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( \"Zug nicht moeglich! (\" + fromRow + \", \" + fromCol + \") --> \" + \"( \" + toRow + \", \" + toCol + \") \" ); } } } Testklasse.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package aufgaben.aufgabe3 ; public class Testklasse { public static void main ( String [] args ) { Solitaire s = new Solitaire (); s . print (); while ( s . moveFirstPossible ()) { s . print (); } s . print (); } }","title":"Aufgabe 3 (Solitaire)"},{"location":"aufgaben/#aufgabe-4-test-driven-development","text":"Aufgabe 4 Implementieren Sie eine Methode public static int singleNumber(int[] nums) durch testgetriebene Entwicklung. F\u00fcr nums soll Folgendes gelten: es ist nicht leer, d.h. 1 <= nums.length , jede Zahl in nums ist genau zwei Mal in nums enthalten, bis auf eine - diese existiert nur genau ein Mal in nums Die Methode gibt die Zahl zur\u00fcck, die nur genau ein Mal in nums enthalten ist. Bsp.: // Beispiel 1 Input: nums = [ 2 ,2,1 ] Output: 1 // Beispiel 2 Input: nums = [ 4 ,1,2,1,2 ] Output: 4 // Beispiel 3 Input: nums = [ 1 ] Output: 1 Sie k\u00f6nnen beliebig viele weitere Methoden implementieren, die Ihnen helfen. Diese m\u00fcssen aber auch testgetrieben entwickelt werden. Pushen Sie alle Klassen (also nat\u00fcrlich auch die Testklasse) in Ihr Remote-Repository.","title":"Aufgabe 4 (test-driven development)"},{"location":"aufgaben/#aufgabe-5-operationen-uber-mengen","text":"Aufgabe 5 Implementieren Sie eine Klasse SetOperations . Erstellen Sie drei Objektvariablen (z.B. numbers1 , numbers2 und both ) vom Typ Set<Integer> . Erzeugen Sie f\u00fcr diese Objektvariablen TreeSet -Objekte. Erstellen Sie eine Objektmethode fill() . In dieser Methode sollen die beiden Sets numbers1 und numbers2 mit Zufallszahlen aus dem Wertebereich 0..99 bef\u00fcllt werden. Erzeugen Sie jeweils 100 Zufallszahlen (die number s-Sets werden dann aber jeweils weniger als 100 Eintr\u00e4ge haben, da doppelte Elemente nicht aufgenommen werden.) Beachten Sie, dass die nextInt() -Methode ein int zur\u00fcckliefert. Dieses int muss zun\u00e4chst in ein Integer -Objekt umgewandelt werden ( Integer.valueOf(int) ) und dieses Integer -Objekt wird dann dem Set hinzugef\u00fcgt (wenn es nicht schon enthalten ist). Erstellen Sie eine Objektmethode fillBothUnion() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einer Vereinigung der Mengen numbers1 und numbers2 entspricht. F\u00fcr Methoden auf Mengen siehe z.B. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Set.html . Erstellen Sie eine Objektmethode fillBothIntersection() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both einem Schnitt der Mengen numbers1 und numbers2 entspricht. Erstellen Sie eine Objektmethode fillBothDifference() . In dieser Methode wird die both -Menge derart bef\u00fcllt, dass both der Differenz der Menge numbers1 minus der Menge numbers2 entspricht. Schreiben Sie eine Methode print() so, dass jede Menge als ein Quadrat (10x10) aus Punkten auf der Konsole erscheint. Es wird ein Punkt gezeichnet, wenn die entsprechende Zahl (die 100 Punkte bilden die Zahlen 0..99 ab) in der Menge enthalten ist und es wird kein Punkt gezeichnet, wenn die Zahl nicht vorhanden ist. (Anstelle von Punkten k\u00f6nnen Sie auch jedes beliebige Zeichen ( o, *, #, x, ... ) verwenden). Gestalten Sie die Ausgabe so, dass die drei Mengen numbers1 , numbers2 und both nebeneinander auf der Konsole erscheinen. Testen Sie alle drei Methoden fillBothUnion() , fillBothIntersection() und fillBothDifference() . Die Ausgabe k\u00f6nnte wie folgt sein ( A stellt die Menge numbers1 dar, B die Menge numbers2 und rechts ist jeweils die both -Menge dargestellt): Tipps : F\u00fcr die schwarzen Punkte habe ich das Character '\\u25cf' verwendet (ein passendes Leerzeichen dazu ist '\\u2009' ). Das Zeichen f\u00fcr die Vereinigung ist '\\u222a' und f\u00fcr den Schnitt '\\u2229' . Schauen Sie sich auch im Skript Mengenoperationen an.","title":"Aufgabe 5 (Operationen \u00fcber Mengen)"},{"location":"aufgaben/#aufgabe-6-maps","text":"Aufgabe 6 Testen Sie folgenden Code: long a = 1000 ; Integer b = 1000 ; Integer c = 1000 ; System . out . println ( a == b ); System . out . println ( b == c ); Was stellen Sie fest und warum? \u00c4ndern Sie den Vergleich der Variablen b und c so, dass true ausgegeben wird. Die ersten drei Zeilen bleiben dabei unver\u00e4ndert. Sie ben\u00f6tigen also einen anderen Vergleich als b == c . Erstellen Sie eine Klasse PizzaMenu . Erzeugen Sie darin eine HashMap und f\u00fcgen Sie folgende Pizzen mit ihren Preisen ein: Pizza Preis Margherita 7,00 Veggie 7,50 Salami 8,50 Schinken 8,50 Schreiben Sie eine Methode public static boolean existingPizza(Map<String,Double> menu, String pizza) , die testet, ob eine eingegebene Pizza im Men\u00fc existiert. Schreiben Sie eine Methode public static void printPrice(Map<String,Double> menu, String pizza) , die f\u00fcr eine eingegebene Pizza den Preis ausgibt. Verwenden Sie dazu existingPizza() . Beispielausgabe: Salami: 8 .50 Euro Hawaii: Diese Pizza gibt es nicht. Schreiben Sie eine printMenu() -Methode, die ausgibt, wie viele Pizzen es im Men\u00fc gibt. Wenn das Men\u00fc nicht leer ist, sollen zudem alle Pizzen mit ihrem Preis ausgegeben werden. Beispielausgabe: // Beispiel fuer leeres Menue ############## Das Menu enth\u00e4lt 0 Pizzen. ############## // Beispiel fuer Menue ############## Das Menu enth\u00e4lt 4 Pizzen. Pizza Margherita: 7 .00 Euro Pizza Salami: 8 .50 Euro Pizza Schinken: 8 .50 Euro Pizza Veggie: 7 .50 Euro ############## \u00c4ndern Sie den Preis der Schinken -Pizza in der HashMap zu 8,20 . Schreiben Sie eine Methode public static void affordablePizza(Map<String,Double> menu, double maxPrice) , die alle Pizzen ausgibt, die man sich f\u00fcr einen bestimmten Betrag leisten kann. Beispielausgabe: Eingegebener Betrag: 4 .0 Euro Leider gibt es zu diesem Preis keine Pizza. Eingegebener Betrag: 8 .0 Euro M\u00f6gliche Pizzen: [ Margherita, Veggie ] Das Menu wird \u00fcberarbeitet, l\u00f6schen Sie daher alle Eintr\u00e4ge. F\u00fcllen Sie das Men\u00fc anschlie\u00dfend mit diesen neuen Pizzen: Pizza Preis Verde 7,00 Hawaii 8,20 Tradizionale 8,50 Legen Sie ein zweites Men\u00fc an und kopieren Sie alle Eintr\u00e4ge aus dem ersten Men\u00fc hinein. L\u00f6schen Sie im zweiten Men\u00fc die Pizza Hawaii und geben Sie die Namen aller noch verf\u00fcgbaren Pizzen aus. Finden Sie in Ihrem Code ein Beispiel f\u00fcr Auto-Boxing und schreiben Sie einen entsprechenden Kommentar.","title":"Aufgabe 6 (Maps)"},{"location":"collections/","text":"Collections \u00b6 Um mehrere Werte oder Referenzen gleichen Typs zu speichern, haben wir bisher Arrays verwendet. Die L\u00e4nge von Arrays wird bei der Initialisierung festgelegt und l\u00e4sst sich dann nicht mehr ver\u00e4ndern. Wenn ein weiteres Element einem vollen Array hinzugef\u00fcgt werden soll, muss zun\u00e4chst ein neues Array erstellt werden, das l\u00e4nger ist als das alte und dann m\u00fcssen alle Elemente aus dem alten Array in das neue Array kopiert werden, ehe das neue Element hinzugef\u00fcgt wird. Das ist recht aufwendig. Dar\u00fcber hinaus ist es beispielsweise auch aufwendig, in Arrays Doppelungen zu vermeiden. F\u00fcr ein Element, das in ein Array eingef\u00fcgt werden soll, muss daf\u00fcr zun\u00e4chst gepr\u00fcft werden, ob es nicht bereits im Array enthalten ist. Diese Nachteile f\u00fchren dazu, dass wir uns nun mit Datenstrukturen besch\u00e4ftigen, die ebenfalls mehrere Elemente speichern k\u00f6nnen, deren Verwaltung aber nicht so aufwendig ist, wie bei Arrays. Diese Datenstrukturen hei\u00dfen Collections . Collections haben drei wesentliche Eigenschaften: Eine Collection hat keine festgelegte L\u00e4nge , d.h. es sind beliebig viele Elemente in einer Collection speicherbar. In eine Collection k\u00f6nnen nur Elemente von Referenztypen gespeichert werden, d.h. keine Wertetypen ( int , double , boolean , char , ...). Um auch solche \"Werte\" speichern zu k\u00f6nnen, werden wir Wrapper -Klassen kennenlernen. Im Gegensatz zu Arrays k\u00f6nnen in einer Collection Elemente verschiedener Referenztypen gespeichert werden. Das ist aber eher ein Problem und kein Feature. Wir werden das vermeiden, da die Verwaltung von Elementen verschiedener Typen fehleranf\u00e4llig ist. Wir werden Collections typisieren , damit sie nur Elemente eines Typs speichern kann. Arten von Collections \u00b6 Es gibt unterschiedliche Arten von Collections , welche je nach Einsatzzweck verwendet werden: Typ Struktur Zugriff Eigenschaften List Menge wahlfrei (indexbasiert) Iterator kann Elemente mehrfach enthalten Set Menge Iterator keine doppelten Elemente keine Ordnung der Elemente Map Schl\u00fcssel-Werte-Paare schl\u00fcsselbasiert Schl\u00fcssel ist eindeutig Werte k\u00f6nnen mehrfach sein Stack Stapel/Stack oberstes Element last-in-first-out-Prinzip Queue Warteschlange erstes und letztes Element first-in-first-out-Prinzip Wir werden uns in diesem Semester aber nur mit den Collections List , Set und Map besch\u00e4ftigen. Das Prinzip eines Stacks haben wir bereits kennengelernt, als wir uns \u00fcber den Methodenstack in Programmierung 1 unterhalten hatten. Ein Stack ist ein Stapel, auf den man ein Element legen kann ( pop ) und von dem man das oberste Element entfernen kann ( pop ). Mithilfe von top erh\u00e4lt man lesenden Zugriff auf das oberste Element. Auf alle anderen Elemente hat man im Stack keinen Zugriff. Eine Queue implementiert das Prinzip einer Warteschlange. Ein Element kann an das Ende einer Warteschlange angeh\u00e4ngt werden. Herausgenommen werden kann aber immer nur das Element am Anfang (dem head ) der Warteschlange. Eine Liste ( List ) ist noch am ehesten vergleichbar mit einem Array, au\u00dfer dass es keine Gr\u00f6\u00dfenbeschr\u00e4nkung gibt und dass nur Referenztypen in eine Liste gespeichert werden. In Listen werden ebenfalls Indizes verwaltet, so dass man auf die Elemente Zugriff wie in einem Array hat. Es gibt Listen, die automatisch sortiert werden. In Listen k\u00f6nnen Elemente doppelt vorkommen. Von Doppelungen in Collections wird gesprochen, wenn f\u00fcr zwei Elemente e1 und e2 gilt e1.equals(e2) == true (oder e1.hashCode() == e2.hashCode() ). Eine Menge ( Set ) hat die besondere Eigenschaft, dass sie keine Doppelungen enth\u00e4lt. Wird versucht, ein Element einer Menge hinzuzuf\u00fcgen, welches bereits in der Menge enthalten ist, dann wird das Element nicht hinzugef\u00fcgt. Deshalb gibt die add(element) -Methode f\u00fcr eine Menge ein boolean zur\u00fcck, damit erkannt werden kann, ob das Element hinzugef\u00fcgt wurde ( true ) oder nicht ( false ). Eine Map kann man sich wie eine Tablle aus zwei Spalten vorstellen. In der linken Spalte stehen Schl\u00fcssel key und in der rechten die Werte value . Jedem Schl\u00fcssel ist genau ein Wert zugeordnet. Jeder Schl\u00fcssel ist eindeutig, d.h. es gibt keine Doppelungen unter den Schl\u00fcsseln (die Schl\u00fcssel in einer Map sind eine Set ). Werte k\u00f6nnen allerdings doppelt vorkommen (haben aber jeweils einen eigenen Schl\u00fcssel). Eine kurze Entscheidungshilfe, welche Collection verwendet wird, zeigt die folgende Abbildung: Der Collection-Klassenbaum \u00b6 Leider ist die Verwaltung von Collections in Java nicht einheitlich. Das liegt daran, dass (unverst\u00e4ndlicherweise) Listen und Mengen in einer anderen Vererbungshierarchie verwaltet werden, als Maps. Wir schauen uns die Vererbungshierarchie von Collection einaml an. Darin kommen die Listen und Mengen vor, aber nicht Maps. Die \"Mutter-Klasse\" der Collections List und Set ist Collection . In der Abbildung fallen unterschiedliche Farben auf. Die gr\u00fcngef\u00e4rbten Klassen sind sogenannte Interfaces . Interfaces lernen wir sp\u00e4ter noch kennen. Ebenso wie die rotgef\u00e4rbten Klassen, bei denen es sich um abstrakte Klassen handelt. Das soll uns zun\u00e4chst nicht besonders interessieren, aber wir k\u00f6nnen uns merken, dass wir die gr\u00fcngef\u00e4rbten Klassen als Typen verwenden (insb. den Typ List f\u00fcr die Listen und den Typ Set f\u00fcr die Mengen). Wir k\u00f6nnen aber keine konkreten List -Objekte bzw. keine konkreten Set -Objekte erzeugen. Das geht nur mit dem blaugef\u00e4rbten Klassen. Das bedeutet, dass wir z.B. ein konkretes ArrayList -Objekt erzeugen werden oder ein konkretes HashSet -Objekt. Hier einige Beispiele: import java.util.ArrayList ; import java.util.HashSet ; import java.util.LinkedList ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Collections { public static void main ( String [] args ) { List l1 = new ArrayList (); List l2 = new LinkedList (); Set s1 = new HashSet (); Set s2 = new TreeSet (); } } Beachten Sie, alle Klassen aus dem java.util -Paket zu importieren! Eine Klasse List gibt es z.B. auch im java.awt -Paket! Statt alle Klassen einzeln zu importieren k\u00f6nnen Sie auch schreiben: import java.util.* ; Der * ist eine Wildcard und importiert alle Klassen aus java.util . Zur Diskussion, wann ArrayList besser ist und wann LinkedList , siehe hier . Eine Diskussion \u00fcber die Unterschiede zwischen HashSet und TreeSet finden Sie z.B. hier . Wir werden f\u00fcr Listen haupts\u00e4chlich Objekte von ArrayList erstellen und f\u00fcr Mengen haupts\u00e4chlich Objekte von HashSet . Mengen - Sets \u00b6 Wir betrachten zun\u00e4chst Mengen genauer und beginnen mit einem Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set menge = new HashSet (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } In Zeile 1 werden zun\u00e4chst alle verwendeten Klassen aus dem java.util -Paket geladen. Das sind f\u00fcr unser Beispiel Set , HashSet und Iterator . Die Iterator -Klasse wird verwendet, um durch unsere Menge menge zu laufen. Wir werden auf den Iterator gleich genauer eingehen, lernen aber bald eine einfachere L\u00f6sung kennen, um durch unsere Menge zu iterieren. In Zeile 7 wird die Menge menge erzeugt. Wir deklarieren daf\u00fcr den Typ Set und erzeugen unter Verwendung des parameterlosen Konstruktors von HashSet ein HashSet -Objekt. Die menge hat also den Compilertyp Set und mindestens den Laufzeittyp HashSet (nat\u00fcrlich noch weitere Laufzeittypen, z.B. Object ). In den Zeilen 14-17 werden der menge Elemente hinzugef\u00fcgt. Diese Elemente sind hier vom Typ String . Das Hinzuf\u00fcgen von Elementen zu einer Menge erfolgt mit der Methode add(element) . Diese Methode gibt ein boolean zur\u00fcck. Wir lassen in den Zeilen 14-17 diese R\u00fcckgabe auf die Konsole ausgeben und stellen fest, dass wir folgende Ausgaben erhalten: true true true false Die add() -Methode gibt also 3x ein true zur\u00fcck und beim vierten Aufruf ein false . Das liegt daran, dass beim vierten Aufruf von add() (Zeile 17 ) das \u00fcbergebene Element s4 nicht in die Menge menge eingef\u00fcgt wird, da sich in dieser Menge bereits ein String mit dem Wert \"zweiter\" befindet und eine Menge keine Doppelungen enthalten darf. Da s2.equals(s4) den Wert true zur\u00fcckgibt, erkennt die add() -Methode, dass bereits ein gleiches Objekt in der Menge enthalten ist und s4 wird deshalb nicht eingef\u00fcgt. In Zeile 19 lassen wir uns die Anzahl der Elemente in der Menge menge ausgeben. Dies erfolgt mithilfe der size() -Methode (in Collections ist es also nicht length() , auch nicht length und auch nicht getLength() oder getSize() , sondern size() ). Der Wert von size() in unserem Beispiel ist 3 . Der Iterator \u00b6 Mithilfe der Klasse Iterator iterieren wir durch eine Collection, d.h. wir laufen durch unsere Collection und betrachten alle Elemente aus der Collection. Die Klasse Iterator besitzt drei Objektmethoden (eigentlich vier, aber die vierte Methode soll uns zun\u00e4chst nicht interessieren): hasNext() : liefert ein true zur\u00fcck, wenn sich mindestens ein weiteres Element in der Collection befindet; wenn nicht, dann false , next() : liefert das n\u00e4chste Element aus der Iteration zur\u00fcck (und entfernt es daraus), remove() : l\u00f6scht das mit next() zur\u00fcckgegebene Element. In Zeile 21 erzeugen wir zun\u00e4chst mit der iterator() -Methode aus Set ein Objekt von Iterator . Die Referenz auf dieses Objekt nennen wir hier it . Die while() -Schleife in den Zeilen 22-25 durchl\u00e4uft nun diese Iteration, indem sie mithilfe von hasNext() pr\u00fcft, ob sich noch ein weiteres Element in der Iteration befindet und wenn ja, dann wird es mithilfe von next() aus der Iteration entnommen und in Zeile 24 auf die Konsole ausgegeben. Wir erhalten f\u00fcr unser Beispiel folgende Ausgaben: zweiter dritter erster Darin sehen wir auch, dass die Reihenfolge des Einf\u00fcgens in eine Menge nicht gewahrt wird. Wir haben die Elemente in der Reihenfolge \"erster\" , \"zweiter\" , \"dritter\" in die Menge eingef\u00fcgt, aber die Ausgabe erfolgt in der Reihenfolge \"zweiter\" , \"dritter\" , \"erster\" . Auf die Reihenfolge haben wir in Mengen keinen Einfluss! Methoden f\u00fcr Mengen \u00b6 Wir haben bereits drei Methoden f\u00fcr Mengen kennengelernt: add() , size() und iterator() . Tats\u00e4chlich sind das Methoden, die in allen Klassen zur Verf\u00fcgung stehen, die von java.util.Collection erben ( erben ist hier eigentlich nicht ganz richtig, da es sich bei java.util.Collection um ein Interface handelt, aber das soll uns hier zun\u00e4chst egal sein). Wir betrachten nun alle wesentlichen Methoden, die wir f\u00fcr Mengen und Listen zur Verf\u00fcgung haben (siehe dazu auch die Java-Dokumentation von Collection ): Methode Beschreibung boolean add(E element) F\u00fcgt Element element in die Collection ein. Gibt true zur\u00fcck, wenn Element hinzugef\u00fcgt wurde sonst false . boolean addAll(Collection c) F\u00fcgt alle Elemente der Collection c in die Collection ein. Gibt true zur\u00fcck, wenn mindestens ein Element hinzugef\u00fcgt wurde sonst false . void clear() Entfernt alle Elemente aus der Collection. boolean contains(E element) Gibt true zur\u00fcck, wenn sich element in der Collection befindet, sonst false . boolean containsAll(Collection c) Gibt true zur\u00fcck, wenn sich alle Elemente der Collection c in der Collection befinden, sonst false . boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Collection befinden, sonst false . Iterator iterator() Erzeugt einen Iterator, welcher auf das erste Element der Collection zeigt. boolean remove(Object o) Entfernt o aus der Collection und gibt true zur\u00fcck, wenn ein Element entfernt wurde, sonst false . boolean removeAll(Collection c) Entfernt alle Elemente aus c aus der Collection und gibt true zur\u00fcck, wenn mindestens ein Element entfernt wurde, sonst false . int size() Gibt die Anzahl der Elemente in der Collection zur\u00fcck. Object[] toArray() Gibt die Elemente in der Collection in einem Array-Datentyp zur\u00fcck. Der TyP E in der Tabelle ist ein Platzhalter f\u00fcr einen konkreten Typ. Bei dem Iterator sehen wir eine neue Syntax <E> . Diese lernen wir gleich kennen. E steht, wie gesagt, f\u00fcr einen beliebigen Typ. Die Typisierung wollen wir zun\u00e4chst motivieren. Typisieren \u00b6 Generell k\u00f6nnen in Collections Objekte verschiedener Typen gespeichert werden. Es w\u00e4re also m\u00f6glich, so etwas hier zu tun: Set menge = new HashSet (); menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Power einf\u00fcgen menge . add ( new Point ( 2 , 3 )); // Point einf\u00fcgen menge . add ( new Konto ()); // Konto einf\u00fcgen Das Speichern von Objekten verschiedenen Typs ist jedoch sehr fehleranf\u00e4llig und sollte unbedingt vermieden werden! Es gibt auch nicht wirklich sinnvollen Anwendungsbeispiele daf\u00fcr. Stattdessen wollen wir angeben, welcher Typ die Objekte haben sollen, die in unserer Collection gespeichert werden k\u00f6nnen. Dazu typisieren wir die Collection. Das Typisieren einer Collection erfolgt mithilfe der Diamond -Syntax: Collection<Typ> name = new KonkreteKlasse<>(); Wir typisieren die Menge menge aus dem eben gezeigten Beispiel: Set < String > menge = new HashSet <> (); // mit String typisiert - menge nimmt nur Strings auf menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Fehler - kein String menge . add ( new Point ( 2 , 3 )); // Fehler - kein String menge . add ( new Konto ()); // Fehler - kein String Wir haben menge typisiert und angegeben, dass menge nur Objekte vonm Typ String aufnehmen kann. Dazu geben wir bei der Typdeklaration Set<String> den Elemente-Typ in spitzen Klammern an. Diese spitzen Klammern werden auch in den Konstruktoraufruf eingef\u00fcgt new HashSet<>(); . Darin muss der Typ aber nicht wiederholt werden (der ist ja aus der Deklaration klar). Der Versuch, Objekte eines anderen Typs als String in die Collection einzuf\u00fcgen, scheitert bereits zur Compilezeit, d.h. das Programm l\u00e4sst sich gar nicht \u00fcbersetzen, wenn versucht wird, Objekte anderen Typs als der bei der Typisierung Angegebene einzuf\u00fcgen. Unser einf\u00fchrendes Beispiel von oben ist deshalb besser mit Typisierung: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator < String > it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } Beachten Sie, dass auch der Iterator (Zeile 21 ) typisiert wird. Die for-each-Schleife \u00b6 Wenn wir unsere Collection typisieren, haben wir auch eine einfachere M\u00f6glichkeit, durch diese zu laufen als die Verwednung des Iterators. Wir k\u00f6nnen stattdessen die for-each -Schleife verwenden. Die allgemeine Syntaxh einer solchen Schleife ist: for ( TypElement element : collection ) { } F\u00fcr unser Beispiel k\u00f6nnten wir den Iterator ersetzen durch diese Schleife: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 for ( String s : menge ) { System . out . println ( s ); } } } \u00dcbrigens: anstelle der Collection (hier: menge ) k\u00f6nnte auch ein Array stehen. Wenn Sie also vollst\u00e4ndig durch Array laufen m\u00f6chten, m\u00fcssen Sie das nicht zwingend \u00fcber alle Indizes machen, sondern k\u00f6nnen daf\u00fcr auch diese for-each -Schleife verwenden. \u00dcbung Ersetzen Sie im oberen Beispiel HashSet durch TreeSet . Erkennen Sie einen Unterschied? Listen \u00b6 Der Umgang mit Listen ist \u00e4hnlich dem Umgang mit Mengen, da beide von java.util.Collection abgeleitet sind. Deshalb stehen uns f\u00fcr Listen die gleichen Methoden zur Verf\u00fcgung, wie f\u00fcr Mengen. Listen k\u00f6nnen wir uns eher wie Arrays vorstellen. In Listen gibt es, im Unterschied zu Mengen, index-basierte Zugriffe und auch Doppelungen. Wir betrachten ein Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.* ; public class Collections { static void fillList ( List < String > list ) { for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( String . valueOf ( i )); } } static void printList ( List < String > list ) { Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . print ( it . next () + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } public static void main ( String [] args ) { List < String > list1 = new ArrayList <> (); fillList ( list1 ); printList ( list1 ); List < String > list2 = new LinkedList <> (); fillList ( list2 ); list2 . remove ( \"3\" ); // Wert! list2 . remove ( 6 ); // Index! list1 . removeAll ( list2 ); printList ( list2 ); // 0 1 2 4 5 6 8 9 printList ( list1 ); // 3 7 } } Wir erstellen uns zwei Listen list1 (Zeile 26 ) und list2 (Zeile 30 ). Beide sind vom Compilertyp List und beide sind typisiert mit String , d.h. sie k\u00f6nnen nur Strings aufnehmen. Die Methode fillList() (Zeilen 5-11 ) bef\u00fcllt die \u00fcbergebene Liste mit den Ziffern 0...9 . Da die Liste Strings erwartet, werden die int -Ziffern mithilfe von String.valueOf() in einen String umgewandelt (Zeile 9 ). Die add() -Methode f\u00fcgt die Strings hinzu (Zeile 9 ). Die Methode printList() (Zeilen 13-33 ) gibt die Elemente der \u00fcbergebenen Liste mithilfe des Iterators aus. Es wird jede Ziffer ausgegeben, gefolgt von einem Leerzeichen (Zeile 18 ). Der Aufruf von printList(list1); in Zeile 28 f\u00fchrt zu folgender Ausgabe: 0 1 2 3 4 5 6 7 8 9 End of list Die Liste list2 wird zun\u00e4chst ebenfalls mit den Ziffern 0...9 (jeweils als String ) bef\u00fcllt. Die Anweisung list2.remove(\"3\"); in Zeile 32 bewirkt, dass der Wert \"3\" aus der Liste gel\u00f6scht wird. Nach diesem L\u00f6schen enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" In Zeile 33 wird nun das Element aus der Liste gel\u00f6scht, das unter dem Index 6 gespeichert ist. Das ist das Element \"7\" . Nach dem L\u00f6schen des Elementes enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" Die Anweisung list1.removeAll(list2); in Zeile 34 bewirkt nun, dass aus list1 alle Werte gel\u00f6scht werden, die (auch) in list2 enthalten sind, also \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" . Das bewirkt, dass in list1 dann nur noch die Werte \"3\" \"7\" \u00fcbrig bleiben. Die Anweisung printList(list2); in Zeile 35 bewirkt folgende Ausgabe: 0 1 2 4 5 6 8 9 End of list Die Anweisung printList(list1); in Zeile 36 bewirkt folgende Ausgabe: 3 7 End of list Die Methode printList() h\u00e4tte anstelle den Iterator zu verwenden auch mit der for-each -Schleife implementiert werden k\u00f6nnen: 13 14 15 16 17 18 19 20 21 static void printList ( List < String > list ) { for ( String s : list ) { System . out . print ( s + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } \u00dcbung Gegeben ist folgender Code: Set < Integer > s1 = new HashSet <> (); Set < Integer > s2 = new HashSet <> (); for ( int i = 10 ; i >= 1 ; i -- ) { s1 . add ( i ); } for ( int i = 9 ; i <= 12 ; i ++ ) { s2 . add ( i ); } s1 . addAll ( s2 ); Was ist der R\u00fcckgabewert von s1.addAll(s2); und warum? Implementieren Sie die Ausgabe aller Werte von s1 und s2 . Mengenoperationen \u00b6 Angenommen, wir haben drei Mengen A , B und C , wobei alle Elemente aus C auch Elemente in A sind. Mithilfe der Methoden addAll() , removeAll() , retainAll() und containsAll() lassen sich Operationen \u00fcber Mengen beschreiben, wie die folgende Abbildung zeigt: Stack und Queue \u00b6 Wir werden uns, wie bereits erw\u00e4hnt, nicht ausf\u00fcrhlich mit Stack und Queue besch\u00e4ftigen, wollen aber hier der Vollst\u00e4ndigkeit halber, die gesonderten Methoden angeben, die diese beiden Arten von Collections betreffen: Stack \u00b6 Last-In-First-Out-Prinzip push(E element) zum Hinzuf\u00fcgen pop() entfernt oberstes Element und gibt es zur\u00fcck empty() pr\u00fcft, ob der Stack leer ist Queue \u00b6 First-In-First-Out-Prinzip add()/offer() zum Hinzuf\u00fcgen remove()/poll() entfernt vorderstes Element und gibt es zur\u00fcck element()/peek() pr\u00fcft, ob die Warteschlange leer ist Wertetypen in Collections \u00b6 Wertetypen k\u00f6nnen nicht als Typen der Elemente in Collections verwendet werden. Es sind nur Referenztypen in Collections erlaubt. F\u00fcr alle Wertetypen stehen entsprechende Wrapper -Klassen zur Verf\u00fcgung: Integer , Double , Float , Short , Byte , Long , Character , Boolean : 1 2 3 4 5 6 7 8 // Wertetypen k\u00f6nnen nicht als konkrete // Typen in Collections verwendet werden List < int > l = new ArrayList <> (); // Fehler !! // Verwendung der Wrapper-Klassen + Auto-Boxing List < Integer > l = new ArrayList <> (); l . add ( 100 ); // sogenanntes Auto-Boxing Das obere beispiel zeigt in Zeile 3 , wie es nicht geht. Die List l kann nicht mit int typisiert werden. Stattdessen muss die Wrapper -Klasse Integer verwendet werden. Wir betrachten Wrapper -Klassen im n\u00e4chsten Abschnitt.","title":"Collections"},{"location":"collections/#collections","text":"Um mehrere Werte oder Referenzen gleichen Typs zu speichern, haben wir bisher Arrays verwendet. Die L\u00e4nge von Arrays wird bei der Initialisierung festgelegt und l\u00e4sst sich dann nicht mehr ver\u00e4ndern. Wenn ein weiteres Element einem vollen Array hinzugef\u00fcgt werden soll, muss zun\u00e4chst ein neues Array erstellt werden, das l\u00e4nger ist als das alte und dann m\u00fcssen alle Elemente aus dem alten Array in das neue Array kopiert werden, ehe das neue Element hinzugef\u00fcgt wird. Das ist recht aufwendig. Dar\u00fcber hinaus ist es beispielsweise auch aufwendig, in Arrays Doppelungen zu vermeiden. F\u00fcr ein Element, das in ein Array eingef\u00fcgt werden soll, muss daf\u00fcr zun\u00e4chst gepr\u00fcft werden, ob es nicht bereits im Array enthalten ist. Diese Nachteile f\u00fchren dazu, dass wir uns nun mit Datenstrukturen besch\u00e4ftigen, die ebenfalls mehrere Elemente speichern k\u00f6nnen, deren Verwaltung aber nicht so aufwendig ist, wie bei Arrays. Diese Datenstrukturen hei\u00dfen Collections . Collections haben drei wesentliche Eigenschaften: Eine Collection hat keine festgelegte L\u00e4nge , d.h. es sind beliebig viele Elemente in einer Collection speicherbar. In eine Collection k\u00f6nnen nur Elemente von Referenztypen gespeichert werden, d.h. keine Wertetypen ( int , double , boolean , char , ...). Um auch solche \"Werte\" speichern zu k\u00f6nnen, werden wir Wrapper -Klassen kennenlernen. Im Gegensatz zu Arrays k\u00f6nnen in einer Collection Elemente verschiedener Referenztypen gespeichert werden. Das ist aber eher ein Problem und kein Feature. Wir werden das vermeiden, da die Verwaltung von Elementen verschiedener Typen fehleranf\u00e4llig ist. Wir werden Collections typisieren , damit sie nur Elemente eines Typs speichern kann.","title":"Collections"},{"location":"collections/#arten-von-collections","text":"Es gibt unterschiedliche Arten von Collections , welche je nach Einsatzzweck verwendet werden: Typ Struktur Zugriff Eigenschaften List Menge wahlfrei (indexbasiert) Iterator kann Elemente mehrfach enthalten Set Menge Iterator keine doppelten Elemente keine Ordnung der Elemente Map Schl\u00fcssel-Werte-Paare schl\u00fcsselbasiert Schl\u00fcssel ist eindeutig Werte k\u00f6nnen mehrfach sein Stack Stapel/Stack oberstes Element last-in-first-out-Prinzip Queue Warteschlange erstes und letztes Element first-in-first-out-Prinzip Wir werden uns in diesem Semester aber nur mit den Collections List , Set und Map besch\u00e4ftigen. Das Prinzip eines Stacks haben wir bereits kennengelernt, als wir uns \u00fcber den Methodenstack in Programmierung 1 unterhalten hatten. Ein Stack ist ein Stapel, auf den man ein Element legen kann ( pop ) und von dem man das oberste Element entfernen kann ( pop ). Mithilfe von top erh\u00e4lt man lesenden Zugriff auf das oberste Element. Auf alle anderen Elemente hat man im Stack keinen Zugriff. Eine Queue implementiert das Prinzip einer Warteschlange. Ein Element kann an das Ende einer Warteschlange angeh\u00e4ngt werden. Herausgenommen werden kann aber immer nur das Element am Anfang (dem head ) der Warteschlange. Eine Liste ( List ) ist noch am ehesten vergleichbar mit einem Array, au\u00dfer dass es keine Gr\u00f6\u00dfenbeschr\u00e4nkung gibt und dass nur Referenztypen in eine Liste gespeichert werden. In Listen werden ebenfalls Indizes verwaltet, so dass man auf die Elemente Zugriff wie in einem Array hat. Es gibt Listen, die automatisch sortiert werden. In Listen k\u00f6nnen Elemente doppelt vorkommen. Von Doppelungen in Collections wird gesprochen, wenn f\u00fcr zwei Elemente e1 und e2 gilt e1.equals(e2) == true (oder e1.hashCode() == e2.hashCode() ). Eine Menge ( Set ) hat die besondere Eigenschaft, dass sie keine Doppelungen enth\u00e4lt. Wird versucht, ein Element einer Menge hinzuzuf\u00fcgen, welches bereits in der Menge enthalten ist, dann wird das Element nicht hinzugef\u00fcgt. Deshalb gibt die add(element) -Methode f\u00fcr eine Menge ein boolean zur\u00fcck, damit erkannt werden kann, ob das Element hinzugef\u00fcgt wurde ( true ) oder nicht ( false ). Eine Map kann man sich wie eine Tablle aus zwei Spalten vorstellen. In der linken Spalte stehen Schl\u00fcssel key und in der rechten die Werte value . Jedem Schl\u00fcssel ist genau ein Wert zugeordnet. Jeder Schl\u00fcssel ist eindeutig, d.h. es gibt keine Doppelungen unter den Schl\u00fcsseln (die Schl\u00fcssel in einer Map sind eine Set ). Werte k\u00f6nnen allerdings doppelt vorkommen (haben aber jeweils einen eigenen Schl\u00fcssel). Eine kurze Entscheidungshilfe, welche Collection verwendet wird, zeigt die folgende Abbildung:","title":"Arten von Collections"},{"location":"collections/#der-collection-klassenbaum","text":"Leider ist die Verwaltung von Collections in Java nicht einheitlich. Das liegt daran, dass (unverst\u00e4ndlicherweise) Listen und Mengen in einer anderen Vererbungshierarchie verwaltet werden, als Maps. Wir schauen uns die Vererbungshierarchie von Collection einaml an. Darin kommen die Listen und Mengen vor, aber nicht Maps. Die \"Mutter-Klasse\" der Collections List und Set ist Collection . In der Abbildung fallen unterschiedliche Farben auf. Die gr\u00fcngef\u00e4rbten Klassen sind sogenannte Interfaces . Interfaces lernen wir sp\u00e4ter noch kennen. Ebenso wie die rotgef\u00e4rbten Klassen, bei denen es sich um abstrakte Klassen handelt. Das soll uns zun\u00e4chst nicht besonders interessieren, aber wir k\u00f6nnen uns merken, dass wir die gr\u00fcngef\u00e4rbten Klassen als Typen verwenden (insb. den Typ List f\u00fcr die Listen und den Typ Set f\u00fcr die Mengen). Wir k\u00f6nnen aber keine konkreten List -Objekte bzw. keine konkreten Set -Objekte erzeugen. Das geht nur mit dem blaugef\u00e4rbten Klassen. Das bedeutet, dass wir z.B. ein konkretes ArrayList -Objekt erzeugen werden oder ein konkretes HashSet -Objekt. Hier einige Beispiele: import java.util.ArrayList ; import java.util.HashSet ; import java.util.LinkedList ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Collections { public static void main ( String [] args ) { List l1 = new ArrayList (); List l2 = new LinkedList (); Set s1 = new HashSet (); Set s2 = new TreeSet (); } } Beachten Sie, alle Klassen aus dem java.util -Paket zu importieren! Eine Klasse List gibt es z.B. auch im java.awt -Paket! Statt alle Klassen einzeln zu importieren k\u00f6nnen Sie auch schreiben: import java.util.* ; Der * ist eine Wildcard und importiert alle Klassen aus java.util . Zur Diskussion, wann ArrayList besser ist und wann LinkedList , siehe hier . Eine Diskussion \u00fcber die Unterschiede zwischen HashSet und TreeSet finden Sie z.B. hier . Wir werden f\u00fcr Listen haupts\u00e4chlich Objekte von ArrayList erstellen und f\u00fcr Mengen haupts\u00e4chlich Objekte von HashSet .","title":"Der Collection-Klassenbaum"},{"location":"collections/#mengen-sets","text":"Wir betrachten zun\u00e4chst Mengen genauer und beginnen mit einem Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set menge = new HashSet (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } In Zeile 1 werden zun\u00e4chst alle verwendeten Klassen aus dem java.util -Paket geladen. Das sind f\u00fcr unser Beispiel Set , HashSet und Iterator . Die Iterator -Klasse wird verwendet, um durch unsere Menge menge zu laufen. Wir werden auf den Iterator gleich genauer eingehen, lernen aber bald eine einfachere L\u00f6sung kennen, um durch unsere Menge zu iterieren. In Zeile 7 wird die Menge menge erzeugt. Wir deklarieren daf\u00fcr den Typ Set und erzeugen unter Verwendung des parameterlosen Konstruktors von HashSet ein HashSet -Objekt. Die menge hat also den Compilertyp Set und mindestens den Laufzeittyp HashSet (nat\u00fcrlich noch weitere Laufzeittypen, z.B. Object ). In den Zeilen 14-17 werden der menge Elemente hinzugef\u00fcgt. Diese Elemente sind hier vom Typ String . Das Hinzuf\u00fcgen von Elementen zu einer Menge erfolgt mit der Methode add(element) . Diese Methode gibt ein boolean zur\u00fcck. Wir lassen in den Zeilen 14-17 diese R\u00fcckgabe auf die Konsole ausgeben und stellen fest, dass wir folgende Ausgaben erhalten: true true true false Die add() -Methode gibt also 3x ein true zur\u00fcck und beim vierten Aufruf ein false . Das liegt daran, dass beim vierten Aufruf von add() (Zeile 17 ) das \u00fcbergebene Element s4 nicht in die Menge menge eingef\u00fcgt wird, da sich in dieser Menge bereits ein String mit dem Wert \"zweiter\" befindet und eine Menge keine Doppelungen enthalten darf. Da s2.equals(s4) den Wert true zur\u00fcckgibt, erkennt die add() -Methode, dass bereits ein gleiches Objekt in der Menge enthalten ist und s4 wird deshalb nicht eingef\u00fcgt. In Zeile 19 lassen wir uns die Anzahl der Elemente in der Menge menge ausgeben. Dies erfolgt mithilfe der size() -Methode (in Collections ist es also nicht length() , auch nicht length und auch nicht getLength() oder getSize() , sondern size() ). Der Wert von size() in unserem Beispiel ist 3 .","title":"Mengen - Sets"},{"location":"collections/#der-iterator","text":"Mithilfe der Klasse Iterator iterieren wir durch eine Collection, d.h. wir laufen durch unsere Collection und betrachten alle Elemente aus der Collection. Die Klasse Iterator besitzt drei Objektmethoden (eigentlich vier, aber die vierte Methode soll uns zun\u00e4chst nicht interessieren): hasNext() : liefert ein true zur\u00fcck, wenn sich mindestens ein weiteres Element in der Collection befindet; wenn nicht, dann false , next() : liefert das n\u00e4chste Element aus der Iteration zur\u00fcck (und entfernt es daraus), remove() : l\u00f6scht das mit next() zur\u00fcckgegebene Element. In Zeile 21 erzeugen wir zun\u00e4chst mit der iterator() -Methode aus Set ein Objekt von Iterator . Die Referenz auf dieses Objekt nennen wir hier it . Die while() -Schleife in den Zeilen 22-25 durchl\u00e4uft nun diese Iteration, indem sie mithilfe von hasNext() pr\u00fcft, ob sich noch ein weiteres Element in der Iteration befindet und wenn ja, dann wird es mithilfe von next() aus der Iteration entnommen und in Zeile 24 auf die Konsole ausgegeben. Wir erhalten f\u00fcr unser Beispiel folgende Ausgaben: zweiter dritter erster Darin sehen wir auch, dass die Reihenfolge des Einf\u00fcgens in eine Menge nicht gewahrt wird. Wir haben die Elemente in der Reihenfolge \"erster\" , \"zweiter\" , \"dritter\" in die Menge eingef\u00fcgt, aber die Ausgabe erfolgt in der Reihenfolge \"zweiter\" , \"dritter\" , \"erster\" . Auf die Reihenfolge haben wir in Mengen keinen Einfluss!","title":"Der Iterator"},{"location":"collections/#methoden-fur-mengen","text":"Wir haben bereits drei Methoden f\u00fcr Mengen kennengelernt: add() , size() und iterator() . Tats\u00e4chlich sind das Methoden, die in allen Klassen zur Verf\u00fcgung stehen, die von java.util.Collection erben ( erben ist hier eigentlich nicht ganz richtig, da es sich bei java.util.Collection um ein Interface handelt, aber das soll uns hier zun\u00e4chst egal sein). Wir betrachten nun alle wesentlichen Methoden, die wir f\u00fcr Mengen und Listen zur Verf\u00fcgung haben (siehe dazu auch die Java-Dokumentation von Collection ): Methode Beschreibung boolean add(E element) F\u00fcgt Element element in die Collection ein. Gibt true zur\u00fcck, wenn Element hinzugef\u00fcgt wurde sonst false . boolean addAll(Collection c) F\u00fcgt alle Elemente der Collection c in die Collection ein. Gibt true zur\u00fcck, wenn mindestens ein Element hinzugef\u00fcgt wurde sonst false . void clear() Entfernt alle Elemente aus der Collection. boolean contains(E element) Gibt true zur\u00fcck, wenn sich element in der Collection befindet, sonst false . boolean containsAll(Collection c) Gibt true zur\u00fcck, wenn sich alle Elemente der Collection c in der Collection befinden, sonst false . boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Collection befinden, sonst false . Iterator iterator() Erzeugt einen Iterator, welcher auf das erste Element der Collection zeigt. boolean remove(Object o) Entfernt o aus der Collection und gibt true zur\u00fcck, wenn ein Element entfernt wurde, sonst false . boolean removeAll(Collection c) Entfernt alle Elemente aus c aus der Collection und gibt true zur\u00fcck, wenn mindestens ein Element entfernt wurde, sonst false . int size() Gibt die Anzahl der Elemente in der Collection zur\u00fcck. Object[] toArray() Gibt die Elemente in der Collection in einem Array-Datentyp zur\u00fcck. Der TyP E in der Tabelle ist ein Platzhalter f\u00fcr einen konkreten Typ. Bei dem Iterator sehen wir eine neue Syntax <E> . Diese lernen wir gleich kennen. E steht, wie gesagt, f\u00fcr einen beliebigen Typ. Die Typisierung wollen wir zun\u00e4chst motivieren.","title":"Methoden f\u00fcr Mengen"},{"location":"collections/#typisieren","text":"Generell k\u00f6nnen in Collections Objekte verschiedener Typen gespeichert werden. Es w\u00e4re also m\u00f6glich, so etwas hier zu tun: Set menge = new HashSet (); menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Power einf\u00fcgen menge . add ( new Point ( 2 , 3 )); // Point einf\u00fcgen menge . add ( new Konto ()); // Konto einf\u00fcgen Das Speichern von Objekten verschiedenen Typs ist jedoch sehr fehleranf\u00e4llig und sollte unbedingt vermieden werden! Es gibt auch nicht wirklich sinnvollen Anwendungsbeispiele daf\u00fcr. Stattdessen wollen wir angeben, welcher Typ die Objekte haben sollen, die in unserer Collection gespeichert werden k\u00f6nnen. Dazu typisieren wir die Collection. Das Typisieren einer Collection erfolgt mithilfe der Diamond -Syntax: Collection<Typ> name = new KonkreteKlasse<>(); Wir typisieren die Menge menge aus dem eben gezeigten Beispiel: Set < String > menge = new HashSet <> (); // mit String typisiert - menge nimmt nur Strings auf menge . add ( new String ( \"erster\" )); // String einf\u00fcgen menge . add ( new Power ( 2 , 4 )); // Fehler - kein String menge . add ( new Point ( 2 , 3 )); // Fehler - kein String menge . add ( new Konto ()); // Fehler - kein String Wir haben menge typisiert und angegeben, dass menge nur Objekte vonm Typ String aufnehmen kann. Dazu geben wir bei der Typdeklaration Set<String> den Elemente-Typ in spitzen Klammern an. Diese spitzen Klammern werden auch in den Konstruktoraufruf eingef\u00fcgt new HashSet<>(); . Darin muss der Typ aber nicht wiederholt werden (der ist ja aus der Deklaration klar). Der Versuch, Objekte eines anderen Typs als String in die Collection einzuf\u00fcgen, scheitert bereits zur Compilezeit, d.h. das Programm l\u00e4sst sich gar nicht \u00fcbersetzen, wenn versucht wird, Objekte anderen Typs als der bei der Typisierung Angegebene einzuf\u00fcgen. Unser einf\u00fchrendes Beispiel von oben ist deshalb besser mit Typisierung: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 Iterator < String > it = menge . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } } } Beachten Sie, dass auch der Iterator (Zeile 21 ) typisiert wird.","title":"Typisieren"},{"location":"collections/#die-for-each-schleife","text":"Wenn wir unsere Collection typisieren, haben wir auch eine einfachere M\u00f6glichkeit, durch diese zu laufen als die Verwednung des Iterators. Wir k\u00f6nnen stattdessen die for-each -Schleife verwenden. Die allgemeine Syntaxh einer solchen Schleife ist: for ( TypElement element : collection ) { } F\u00fcr unser Beispiel k\u00f6nnten wir den Iterator ersetzen durch diese Schleife: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.* ; public class Collections { public static void main ( String [] args ) { Set < String > menge = new HashSet <> (); String s1 = \"erster\" ; String s2 = \"zweiter\" ; String s3 = \"dritter\" ; String s4 = \"zweiter\" ; System . out . println ( menge . add ( s1 )); // true System . out . println ( menge . add ( s2 )); // true System . out . println ( menge . add ( s3 )); // true System . out . println ( menge . add ( s4 )); // false System . out . println ( menge . size ()); // 3 for ( String s : menge ) { System . out . println ( s ); } } } \u00dcbrigens: anstelle der Collection (hier: menge ) k\u00f6nnte auch ein Array stehen. Wenn Sie also vollst\u00e4ndig durch Array laufen m\u00f6chten, m\u00fcssen Sie das nicht zwingend \u00fcber alle Indizes machen, sondern k\u00f6nnen daf\u00fcr auch diese for-each -Schleife verwenden. \u00dcbung Ersetzen Sie im oberen Beispiel HashSet durch TreeSet . Erkennen Sie einen Unterschied?","title":"Die for-each-Schleife"},{"location":"collections/#listen","text":"Der Umgang mit Listen ist \u00e4hnlich dem Umgang mit Mengen, da beide von java.util.Collection abgeleitet sind. Deshalb stehen uns f\u00fcr Listen die gleichen Methoden zur Verf\u00fcgung, wie f\u00fcr Mengen. Listen k\u00f6nnen wir uns eher wie Arrays vorstellen. In Listen gibt es, im Unterschied zu Mengen, index-basierte Zugriffe und auch Doppelungen. Wir betrachten ein Beispiel: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.util.* ; public class Collections { static void fillList ( List < String > list ) { for ( int i = 0 ; i < 10 ; i ++ ) { list . add ( String . valueOf ( i )); } } static void printList ( List < String > list ) { Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . print ( it . next () + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } public static void main ( String [] args ) { List < String > list1 = new ArrayList <> (); fillList ( list1 ); printList ( list1 ); List < String > list2 = new LinkedList <> (); fillList ( list2 ); list2 . remove ( \"3\" ); // Wert! list2 . remove ( 6 ); // Index! list1 . removeAll ( list2 ); printList ( list2 ); // 0 1 2 4 5 6 8 9 printList ( list1 ); // 3 7 } } Wir erstellen uns zwei Listen list1 (Zeile 26 ) und list2 (Zeile 30 ). Beide sind vom Compilertyp List und beide sind typisiert mit String , d.h. sie k\u00f6nnen nur Strings aufnehmen. Die Methode fillList() (Zeilen 5-11 ) bef\u00fcllt die \u00fcbergebene Liste mit den Ziffern 0...9 . Da die Liste Strings erwartet, werden die int -Ziffern mithilfe von String.valueOf() in einen String umgewandelt (Zeile 9 ). Die add() -Methode f\u00fcgt die Strings hinzu (Zeile 9 ). Die Methode printList() (Zeilen 13-33 ) gibt die Elemente der \u00fcbergebenen Liste mithilfe des Iterators aus. Es wird jede Ziffer ausgegeben, gefolgt von einem Leerzeichen (Zeile 18 ). Der Aufruf von printList(list1); in Zeile 28 f\u00fchrt zu folgender Ausgabe: 0 1 2 3 4 5 6 7 8 9 End of list Die Liste list2 wird zun\u00e4chst ebenfalls mit den Ziffern 0...9 (jeweils als String ) bef\u00fcllt. Die Anweisung list2.remove(\"3\"); in Zeile 32 bewirkt, dass der Wert \"3\" aus der Liste gel\u00f6scht wird. Nach diesem L\u00f6schen enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" In Zeile 33 wird nun das Element aus der Liste gel\u00f6scht, das unter dem Index 6 gespeichert ist. Das ist das Element \"7\" . Nach dem L\u00f6schen des Elementes enth\u00e4lt die Liste list2 noch folgende Werte: \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" Die Anweisung list1.removeAll(list2); in Zeile 34 bewirkt nun, dass aus list1 alle Werte gel\u00f6scht werden, die (auch) in list2 enthalten sind, also \"0\" \"1\" \"2\" \"4\" \"5\" \"6\" \"8\" \"9\" . Das bewirkt, dass in list1 dann nur noch die Werte \"3\" \"7\" \u00fcbrig bleiben. Die Anweisung printList(list2); in Zeile 35 bewirkt folgende Ausgabe: 0 1 2 4 5 6 8 9 End of list Die Anweisung printList(list1); in Zeile 36 bewirkt folgende Ausgabe: 3 7 End of list Die Methode printList() h\u00e4tte anstelle den Iterator zu verwenden auch mit der for-each -Schleife implementiert werden k\u00f6nnen: 13 14 15 16 17 18 19 20 21 static void printList ( List < String > list ) { for ( String s : list ) { System . out . print ( s + \" \" ); } System . out . println (); System . out . println ( \"End of list\" ); } \u00dcbung Gegeben ist folgender Code: Set < Integer > s1 = new HashSet <> (); Set < Integer > s2 = new HashSet <> (); for ( int i = 10 ; i >= 1 ; i -- ) { s1 . add ( i ); } for ( int i = 9 ; i <= 12 ; i ++ ) { s2 . add ( i ); } s1 . addAll ( s2 ); Was ist der R\u00fcckgabewert von s1.addAll(s2); und warum? Implementieren Sie die Ausgabe aller Werte von s1 und s2 .","title":"Listen"},{"location":"collections/#mengenoperationen","text":"Angenommen, wir haben drei Mengen A , B und C , wobei alle Elemente aus C auch Elemente in A sind. Mithilfe der Methoden addAll() , removeAll() , retainAll() und containsAll() lassen sich Operationen \u00fcber Mengen beschreiben, wie die folgende Abbildung zeigt:","title":"Mengenoperationen"},{"location":"collections/#stack-und-queue","text":"Wir werden uns, wie bereits erw\u00e4hnt, nicht ausf\u00fcrhlich mit Stack und Queue besch\u00e4ftigen, wollen aber hier der Vollst\u00e4ndigkeit halber, die gesonderten Methoden angeben, die diese beiden Arten von Collections betreffen:","title":"Stack und Queue"},{"location":"collections/#stack","text":"Last-In-First-Out-Prinzip push(E element) zum Hinzuf\u00fcgen pop() entfernt oberstes Element und gibt es zur\u00fcck empty() pr\u00fcft, ob der Stack leer ist","title":"Stack"},{"location":"collections/#queue","text":"First-In-First-Out-Prinzip add()/offer() zum Hinzuf\u00fcgen remove()/poll() entfernt vorderstes Element und gibt es zur\u00fcck element()/peek() pr\u00fcft, ob die Warteschlange leer ist","title":"Queue"},{"location":"collections/#wertetypen-in-collections","text":"Wertetypen k\u00f6nnen nicht als Typen der Elemente in Collections verwendet werden. Es sind nur Referenztypen in Collections erlaubt. F\u00fcr alle Wertetypen stehen entsprechende Wrapper -Klassen zur Verf\u00fcgung: Integer , Double , Float , Short , Byte , Long , Character , Boolean : 1 2 3 4 5 6 7 8 // Wertetypen k\u00f6nnen nicht als konkrete // Typen in Collections verwendet werden List < int > l = new ArrayList <> (); // Fehler !! // Verwendung der Wrapper-Klassen + Auto-Boxing List < Integer > l = new ArrayList <> (); l . add ( 100 ); // sogenanntes Auto-Boxing Das obere beispiel zeigt in Zeile 3 , wie es nicht geht. Die List l kann nicht mit int typisiert werden. Stattdessen muss die Wrapper -Klasse Integer verwendet werden. Wir betrachten Wrapper -Klassen im n\u00e4chsten Abschnitt.","title":"Wertetypen in Collections"},{"location":"enum/","text":"Aufz\u00e4hlungstypen (enum) \u00b6 Motivation \u00b6 Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B. String Tag = \"MONTAG\" // kann auch Werte \"Dienstag\" usw. annehmen int Tag = 0 ; // Magic Number f\u00fcr \"Montag\" Das Problem: - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. Tag = \"hallo\" oder Tag=4711 , - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit Beispiel TicTacToe public class TicTacToe { int [][] field ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= 0 ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== 0 && player == 1 || player == 2 ) field [ i ][ j ]= player ; } } Zust\u00e4nde EMPTY ( 0 ), RED ( 1 ), BLACK ( 2 ) verschl\u00fcsselt \u2192 magic numbers field[i][j] k\u00f6nnte auch beliebige andere int -Werte annehmen Code nahezu unlesbar Erster Verbesserungsversuch: Konstanten \u00b6 Beispiel TicTacToe mit Konstanten public class TicTacToe { int [][] field ; static final int EMPTY = 0 ; static final int RED = 1 ; static final int BLACK = 2 ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= EMPTY ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== EMPTY && player == RED || player == BLACK ) field [ i ][ j ]= player ; } } etwas besser, aber immer noch beliebige Werte f\u00fcr field[i][j] m\u00f6glich Der Aufz\u00e4hlungstyp enum \u00b6 Anforderungen: eigener Datentyp endliche Anzahl an Zust\u00e4nden bzw. Werten leserliche Bezeichnung der Werte L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort enum Syntax: enum TypName { WERT1 , WERT2 , WERT3 }; Verwendung: - TypName nun als Datentyp verwendbar, z.B. TypName[][] - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. TypName.WERT1 Beispiel TicTacToe mit enum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } typsicher rot und schwarz \u00fcber State.RED und State.BLACK erreichbar andere Zust\u00e4nde nicht m\u00f6glich Details: \u00b6 alle enum erben implizit von java.lang.Enum enum sind Referenztypen die Konstanten (Werte) in enum sind automatisch static und final == kann verwendet werden (auch switch() ); equals() gibt es aber auch Beispiel enum 1 2 3 4 5 6 7 8 State s = State . EMPTY ; // s = 0 oder s = \"rot\" oder so geht nicht //-> typsicher switch ( s ) { case EMPTY : System . out . println ( \"leeres Feld\" ); break ; case RED : System . out . println ( \"roter Stein\" ); break ; case BLACK : System . out . println ( \"schwarzer Stein Feld\" ); break ; } Weiteres: \u00b6 auch Definition von Methoden m\u00f6glich toString() , equals() usw. aus Object k\u00f6nnen \u00fcberschrieben werden Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig) Zugriff auf das Array von Konstanten mithilfe von values() Beispiel f\u00fcr Werte mit Attributen enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } noch ein Beispiel f\u00fcr Werte mit Attributen enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } Ausf\u00fchrliches Beispiel - Skat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 package vorbereitungen.enums ; import java.util.Arrays ; import java.util.Random ; public class Skat { Karte [] p1 ; Karte [] p2 ; Karte [] p3 ; Karte [] skat ; enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } class Karte { Karten k ; Farben f ; Karte ( Karten k , Farben f ) { this . k = k ; this . f = f ; } @Override public Karte clone () { return new Karte ( this . k , this . f ); } @Override public String toString () { return f . toString () + k . toString () + \" \" ; } } class Deck { Karte [] deck ; Deck () { deck = new Karte [ 32 ] ; int index = 0 ; for ( Farben f : Farben . values ()) { for ( Karten k : Karten . values ()) { deck [ index ++] = new Karte ( k , f ); } } } @Override public String toString () { String s = \"\" ; for ( int i = 0 ; i < deck . length ; i ++ ) { s += deck [ i ] . f . toString () + deck [ i ] . k . toString () + \" \" ; if ( i == 7 || i == 15 || i == 23 || i == 31 ) s += \"\\n\" ; } return s ; } public void print () { System . out . println ( this . toString ()); } } Skat () { p1 = new Karte [ 8 ] ; p2 = new Karte [ 8 ] ; p3 = new Karte [ 8 ] ; skat = new Karte [ 2 ] ; } boolean existsFalse ( boolean [] b ) { for ( int i = 0 ; i < b . length ; i ++ ) { if ( ! b [ i ] ) return true ; } return false ; } public void geben () { Deck d = new Deck (); Random r = new Random (); boolean [] b = new boolean [ 32 ] ; Arrays . fill ( b , false ); int indexP1 = 0 , indexP2 = 0 , indexP3 = 0 , indexSkat = 0 ; int zz = r . nextInt ( 32 ); while ( existsFalse ( b )) { while ( b [ zz ] ) { zz = r . nextInt ( 32 ); } b [ zz ] = true ; if ( indexP1 < 8 ) { p1 [ indexP1 ++] = d . deck [ zz ] . clone (); } else if ( indexP2 < 8 ) { p2 [ indexP2 ++] = d . deck [ zz ] . clone (); } else if ( indexP3 < 8 ) { p3 [ indexP3 ++] = d . deck [ zz ] . clone (); } else if ( indexSkat < 2 ) { skat [ indexSkat ++] = d . deck [ zz ] . clone (); } } } public void sortieren () { } public void print () { System . out . print ( \"Spieler 1 : \" ); for ( Karte k : p1 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 2 : \" ); for ( Karte k : p2 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 3 : \" ); for ( Karte k : p3 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Skat : \" ); for ( Karte k : skat ) System . out . print ( k . toString () + \" \" ); System . out . println (); } public static void main ( String [] args ) { Skat s = new Skat (); s . geben (); s . print (); } } N\u00fctzliche Links f\u00fcr enums \u00b6 Oracle Docs W3Schools Java enums - so geht's Enums Java Tutorial - Enums (youtube)","title":"Aufz\u00e4hlungstypen"},{"location":"enum/#aufzahlungstypen-enum","text":"","title":"Aufz\u00e4hlungstypen (enum)"},{"location":"enum/#motivation","text":"Angenommen, Sie wollen mithilfe einer Variablen eine festgelegte Menge an Zust\u00e4nden beschreiben, z.B. String Tag = \"MONTAG\" // kann auch Werte \"Dienstag\" usw. annehmen int Tag = 0 ; // Magic Number f\u00fcr \"Montag\" Das Problem: - die Variablen k\u00f6nnen auch beliebige andere Werte (aus dem jeweiligen Wertebereich) annehmen, z.B. Tag = \"hallo\" oder Tag=4711 , - Magic Numbers sollen vermieden werden \u2192 meistens schlechte Lesbarkeit Beispiel TicTacToe public class TicTacToe { int [][] field ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= 0 ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== 0 && player == 1 || player == 2 ) field [ i ][ j ]= player ; } } Zust\u00e4nde EMPTY ( 0 ), RED ( 1 ), BLACK ( 2 ) verschl\u00fcsselt \u2192 magic numbers field[i][j] k\u00f6nnte auch beliebige andere int -Werte annehmen Code nahezu unlesbar","title":"Motivation"},{"location":"enum/#erster-verbesserungsversuch-konstanten","text":"Beispiel TicTacToe mit Konstanten public class TicTacToe { int [][] field ; static final int EMPTY = 0 ; static final int RED = 1 ; static final int BLACK = 2 ; TicTacToe () { field = new int [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= EMPTY ; } void makeMove ( int i , int j , int player ) { if ( field [ i ][ j ]== EMPTY && player == RED || player == BLACK ) field [ i ][ j ]= player ; } } etwas besser, aber immer noch beliebige Werte f\u00fcr field[i][j] m\u00f6glich","title":"Erster Verbesserungsversuch: Konstanten"},{"location":"enum/#der-aufzahlungstyp-enum","text":"Anforderungen: eigener Datentyp endliche Anzahl an Zust\u00e4nden bzw. Werten leserliche Bezeichnung der Werte L\u00f6sung: - Enumerations (sog. Aufz\u00e4hlungstypen) - Schl\u00fcsselwort enum Syntax: enum TypName { WERT1 , WERT2 , WERT3 }; Verwendung: - TypName nun als Datentyp verwendbar, z.B. TypName[][] - Zugriff auf Werte \u00fcber statische Punktschreibweise, z.B. TypName.WERT1 Beispiel TicTacToe mit enum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } typsicher rot und schwarz \u00fcber State.RED und State.BLACK erreichbar andere Zust\u00e4nde nicht m\u00f6glich","title":"Der Aufz\u00e4hlungstyp enum"},{"location":"enum/#details","text":"alle enum erben implizit von java.lang.Enum enum sind Referenztypen die Konstanten (Werte) in enum sind automatisch static und final == kann verwendet werden (auch switch() ); equals() gibt es aber auch Beispiel enum 1 2 3 4 5 6 7 8 State s = State . EMPTY ; // s = 0 oder s = \"rot\" oder so geht nicht //-> typsicher switch ( s ) { case EMPTY : System . out . println ( \"leeres Feld\" ); break ; case RED : System . out . println ( \"roter Stein\" ); break ; case BLACK : System . out . println ( \"schwarzer Stein Feld\" ); break ; }","title":"Details:"},{"location":"enum/#weiteres","text":"auch Definition von Methoden m\u00f6glich toString() , equals() usw. aus Object k\u00f6nnen \u00fcberschrieben werden Konstanten k\u00f6nnen mit Attributen versehen werden (dann noch privater Konstruktor notwendig) Zugriff auf das Array von Konstanten mithilfe von values() Beispiel f\u00fcr Werte mit Attributen enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } noch ein Beispiel f\u00fcr Werte mit Attributen enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } Ausf\u00fchrliches Beispiel - Skat.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 package vorbereitungen.enums ; import java.util.Arrays ; import java.util.Random ; public class Skat { Karte [] p1 ; Karte [] p2 ; Karte [] p3 ; Karte [] skat ; enum Karten { AS ( 11 ), ZEHN ( 10 ), NEUN ( 0 ), ACHT ( 0 ), SIEBEN ( 0 ), K ( 4 ), D ( 3 ), B ( 2 ); private int kartenwert ; private Karten ( int wert ) { this . kartenwert = wert ; } @Override public String toString () { String s = \"\" ; switch ( this ) { case AS : s = \"A\" ; break ; case ZEHN : s = \"10\" ; break ; case NEUN : s = \"9\" ; break ; case ACHT : s = \"8\" ; break ; case SIEBEN : s = \"7\" ; break ; case K : s = \"K\" ; break ; case D : s = \"D\" ; break ; case B : s = \"B\" ; break ; } return s ; } } enum Farben { KREUZ ( 12 ), PIK ( 11 ), HERZ ( 10 ), KARO ( 9 ); private int farbwert ; private Farben ( int wert ) { this . farbwert = wert ; } @Override public String toString () { char c = ' ' ; switch ( this ) { case KREUZ : c = '\\u2663' ; break ; case PIK : c = '\\u2664' ; break ; case HERZ : c = '\\u2665' ; break ; case KARO : c = '\\u2666' ; break ; } return String . valueOf ( c ); } } class Karte { Karten k ; Farben f ; Karte ( Karten k , Farben f ) { this . k = k ; this . f = f ; } @Override public Karte clone () { return new Karte ( this . k , this . f ); } @Override public String toString () { return f . toString () + k . toString () + \" \" ; } } class Deck { Karte [] deck ; Deck () { deck = new Karte [ 32 ] ; int index = 0 ; for ( Farben f : Farben . values ()) { for ( Karten k : Karten . values ()) { deck [ index ++] = new Karte ( k , f ); } } } @Override public String toString () { String s = \"\" ; for ( int i = 0 ; i < deck . length ; i ++ ) { s += deck [ i ] . f . toString () + deck [ i ] . k . toString () + \" \" ; if ( i == 7 || i == 15 || i == 23 || i == 31 ) s += \"\\n\" ; } return s ; } public void print () { System . out . println ( this . toString ()); } } Skat () { p1 = new Karte [ 8 ] ; p2 = new Karte [ 8 ] ; p3 = new Karte [ 8 ] ; skat = new Karte [ 2 ] ; } boolean existsFalse ( boolean [] b ) { for ( int i = 0 ; i < b . length ; i ++ ) { if ( ! b [ i ] ) return true ; } return false ; } public void geben () { Deck d = new Deck (); Random r = new Random (); boolean [] b = new boolean [ 32 ] ; Arrays . fill ( b , false ); int indexP1 = 0 , indexP2 = 0 , indexP3 = 0 , indexSkat = 0 ; int zz = r . nextInt ( 32 ); while ( existsFalse ( b )) { while ( b [ zz ] ) { zz = r . nextInt ( 32 ); } b [ zz ] = true ; if ( indexP1 < 8 ) { p1 [ indexP1 ++] = d . deck [ zz ] . clone (); } else if ( indexP2 < 8 ) { p2 [ indexP2 ++] = d . deck [ zz ] . clone (); } else if ( indexP3 < 8 ) { p3 [ indexP3 ++] = d . deck [ zz ] . clone (); } else if ( indexSkat < 2 ) { skat [ indexSkat ++] = d . deck [ zz ] . clone (); } } } public void sortieren () { } public void print () { System . out . print ( \"Spieler 1 : \" ); for ( Karte k : p1 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 2 : \" ); for ( Karte k : p2 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Spieler 3 : \" ); for ( Karte k : p3 ) System . out . print ( k . toString () + \" \" ); System . out . println (); System . out . print ( \"Skat : \" ); for ( Karte k : skat ) System . out . print ( k . toString () + \" \" ); System . out . println (); } public static void main ( String [] args ) { Skat s = new Skat (); s . geben (); s . print (); } }","title":"Weiteres:"},{"location":"enum/#nutzliche-links-fur-enums","text":"Oracle Docs W3Schools Java enums - so geht's Enums Java Tutorial - Enums (youtube)","title":"N\u00fctzliche Links f\u00fcr enums"},{"location":"exceptions/","text":"Exceptions \u00b6 Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine ArrayIndexOutOfBounds -Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf null , erhalten wir eine NullPointerException . Wenn bei einer Nutzereingabe eine Zahl erwartet, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls ein Exception geworfen . Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern: syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions ). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte , z.B. fehlerhafte Benutzereingabe Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar gesuchte Datei/Ordner nicht vorhanden usw. Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt . Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt. try-catch \u00b6 Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem index auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher index aus dem Array ist. Allerdings binden wir diesen Versuch in einen try{} -Block ein. Sollte in einem solchen try{} -Block nun eine Exception geworfen werden, dann fangen wir diese in einem catch(){} -Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus: allgemeine Syntax try-catch 1 2 3 4 5 6 7 8 try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile 3 aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem catch -Block, also nach Zeile 8 weiter. Wenn aber die Anweisung(en) in Zeile 3 einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile 5 \"aufgefangen\" und in dem Anweisungsblock in den Zeilen 6-8 behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren. Beispiel ohne try-catch \u00b6 Wir verdeutlichen dieses Prinzip an einem ersten Beispiel: Beispiel zun\u00e4chst ohne Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Ausnahmen { static char charAt ( String s , int index ) { char c = s . charAt ( index ); // kritisch! return c ; } static double divide ( int divident , int divisor ) { double result = divident / divisor ; // kritisch! return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Das Beispiel enth\u00e4lt zwei Methoden charAt() und divide . Der charAt -Methode wird ein String \u00fcbergeben und ein index . Die Methode gibt das Zeichen ( char ) zur\u00fcck, dass im String unter dem index gespeichert ist (z.B. charAt(\"Hallo\", 1) gibt das 'a' zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob index tats\u00e4chlich ein korrekter Index des Strings s ist, d.h. evtl. ist index kleiner als 0 oder gr\u00f6\u00dfer als die L\u00e4nge von s minus 1 . Die Anweisung s.charAt(index); ist somit eine kritische Anweisung , denn sie kann (bei \"falschem\" index ) eine StringIndexOutOfBoundsException werfen. Genau so ist die Anweisung divident/divisor; in der Methode divide eine kritische Anweisung , da es sein kann, dass der divisior gleich 0 ist. Bei der int -Division durch 0 wird eine ArithmeticException geworfen. Wenn die main -Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile 16 ab und Zeile 17 wird gar nicht mehr erreicht: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at packageName.Ausnahmen.divide ( Ausnahmen.java:10 ) at packageName.Ausnahmen.main ( Ausnahmen.java:16 ) Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:10 und um welche Exception es sich handelt, n\u00e4mlich ArithmeticException: / by zero . Wenn wir in der main -Methode Zeile 16 auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile 17 eine Exception wirft, n\u00e4mlich: Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5 at java.base/java.lang.StringLatin1.charAt ( StringLatin1.java:47 ) at java.base/java.lang.String.charAt ( String.java:702 ) at packageName.Ausnahmen.charAt ( Ausnahmen.java:5 ) at packageName.Ausnahmen.main ( Ausnahmen.java:17 ) Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:5 und um welche Exception es sich handelt, n\u00e4mlich StringIndexOutOfBoundsException: String index out of range: 5 . Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile 47 in der Klasse StringLatin1 in der dortigen Methode charAt die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten. Beispiel mit try-catch \u00b6 Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir try-catch -Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen: Beispiel mit Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Die kritischen Anweisungen wurden nun jeweils in einen try -Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t out in den println -Anweisungen verwendet, sondern err - Zeilen 12 und 26 ). Wenn wir das Programm nun ausf\u00fchren (in main muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe: Division durch 0 nicht definiert! 0 .0 Der Index war ausserhalb des Strings Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der divide -Methode wird eine Exception geworfen, dann erfolgt durch Zeile 26 die Fehlerausgabe auf die Konsole. Danach wird in Zeile 28 aber result zur\u00fcckgegeben (hat den Wert 0.0 , den wir bei der Initailisierung in Zeile 19 angegeben haben) und dieser Wert wird durch Zeile 33 auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die charAt -Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile 34 das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an: Ablauf einer Ausnahmesituation \u00b6 Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt: Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp Exception ), wenn eine Exception \"geworfen\" wird Die Abarbeitung des Programmcodes wird sofort unterbrochen. Das Laufzeitsystem sucht nach der n\u00e4chsten catch -Klausel und f\u00fchrt diese aus. Passt die gefundene catch -Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste catch -Klausel gesucht usw. Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen catch -Klausel (Zeile 10 ) ein Objekt vom Typ StringIndexOutOfBoundsException erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von Exception ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von StringIndexOutOfBoundsException allegmein eine Exception erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere catch -Klausel (Zeile 24 ), wo wir eine ArithmeticException erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. generell gilt, dass man mehrere catch -Bl\u00f6cke hintereinander setzen kann und der erste catch -Block, der dem erwartetetn Parametertyp entspricht, wird ausgef\u00fchrt. Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" catch -Klausel gesprungen wird. Ein weiteres Beispiel \u00b6 Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse Ausnahmen um eine weitere Methode inputInt() : eine weitere methode inputInt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, * dann muessen Sie dort noch * module ProjektName * { * requires java.desktop; * } * eintragen, damit Sie das Paket javax.swing importieren koennen. */ import javax.swing.JOptionPane ; public class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); inputOk = true ; try { inputInt = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException } } Schauen wir uns die Implementierung von inputInt() genauer an: in Zeile 50 wird ein kleines Eingabefenster erzeugt ( JOptionPane ist eine Klasse aus dem javax.swing -Paket, welches wiederum im Modul java.desktop verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als String zur\u00fcckgegeben und in der Variablen input gespeichert. in Zeile 53 wird versucht, den Eingabestring input in ein int umzuwandeln. Dazu wird die Methode parseInt() verwendet, die zur Klasse Integer geh\u00f6rt ( Integer ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). wenn input eine Zahl enth\u00e4lt, also z.B. so aussieht: \"1234\" , dann erzeugt parseInt() daraus die int -Zahl 1234 und alles ist ok. Wenn input jedoch keine Zahl enth\u00e4lt, also z.B. \"hallo\" , dann wirft parseInt() eine NumberFormatException , weil die Umwandlung des String s in ein int nicht m\u00f6glich ist. in Zeile 55 wird eine solche NumberFormatException aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter inputOk auf false gesetzt wird. der gesamte Anweisungsblock Fenster->Eingabe->try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von inputOk nicht false ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit parseInt() keine Exception wirft) \u00dcbrigend k\u00f6nnte die Anweisung inputOk = true; auch nach parseInt() in den try -Block geschrieben werden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); try { inputInt = Integer . parseInt ( input ); inputOk = true ; } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } Zeile 12 wird nur genau dann erreicht, wenn parseInt() keine Exception wirft. Dann wird auch der catch -Block nicht betreten und die Schleife wird beendet. Beispiel mit mehreren Exceptions \u00b6 Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende catch -Klausel gesucht wird. Wir erweitern dazu unsere Klasse Ausnahmen um eine weitere Methode mehrereExceptions() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void mehrereExceptions () { String [] basen = { \"2\" , \"8\" , \"10\" , \"Hi\" }; int base = 0 ; double result = 0 ; boolean ok = true ; for ( int index = 0 ; index <= 4 ; index ++ ) { try { base = Integer . parseInt ( basen [ index ] ); ok = true ; } catch ( NumberFormatException nfe ) { System . out . println ( \"Keine Zahl!\" ); ok = false ; } catch ( IndexOutOfBoundsException ioobe ) { System . out . println ( \"Ausserhalb des Arrays\" ); ok = false ; } for ( int exp = 0 ; exp < 6 && ok ; exp ++ ) { result = Math . pow ( base , exp ); System . out . printf ( \"%d ^ %d = %.0f %n\" , base , exp , result ); } } } In Zeile 3 definieren wir uns ein String[] mit 4 Eintr\u00e4gen. Durch dieses String[] laufen wir mit einer for -Schleife (Zeile 8 ) durch. In Zeile 11 wndeln wir jeden Eintrag aus dem String[] in eine int -Zahl um. An zwei Stellen k\u00f6nnen Exceptions geworfen werden: Bei dem Index-basierten Zugriff auf das Array basen[index] in Zeile 11 kann eine ArrayIndexOutOfBounds -Exception geworfen werden, falls index kein korrekter Index des String[] ist (gilt f\u00fcr index==4 ). Bei der Umwandlung von String nach int durch parseInt() in Zeile 11 kann eine NumberFormatException geworfen werden, falls der entsprechende Eintrag im String[] keine Zahl ist (gilt f\u00fcr basen[3]=='Hi' ). Die Methode erzeugt die folgende Ausgabe: 2 ^ 0 = 1 2 ^ 1 = 2 2 ^ 2 = 4 2 ^ 3 = 8 2 ^ 4 = 16 2 ^ 5 = 32 8 ^ 0 = 1 8 ^ 1 = 8 8 ^ 2 = 64 8 ^ 3 = 512 8 ^ 4 = 4096 8 ^ 5 = 32768 10 ^ 0 = 1 10 ^ 1 = 10 10 ^ 2 = 100 10 ^ 3 = 1000 10 ^ 4 = 10000 10 ^ 5 = 100000 Keine Zahl! Ausserhalb des Arrays Das hei\u00dft, dass wenn f\u00fcr parseInt(\"Hi\") eine NumberFormatException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine NumberFormatException erwartet (Zeilen 14-17 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wenn f\u00fcr basen[4] eine ArrayIndexOutOfBoundsException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine IndexOutOfBoundsException erwartet (Zeilen 18-21 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wir sehen, dass es offensichtlich auch eine IndexOutOfBoundsException -Klasse gibt. Das ist eine Elternklasse von ArrayIndexOutOfBoundsException und auch von StringIndexOutOfBoundsException . Wir schauen uns diese Vererbungshierarchie von Exception nun mal an: Die Vererbungshierarchie der Klasse Exception \u00b6 Wenn Sie sich die Klasse Exception in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen: Alle Exception-Klassen erben von der Klasse Exception , die im java.lang -Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden: checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen try-catch -Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem try -Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse RunTimeException ab. Wir werden uns genau mit diesen uncheck Exceptions, also von RunTimeException abgeleiteten Klassen besch\u00e4ftigen. Es gibt von RunTimeException noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die IllegalArgumentException -Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene Exception -Klassen erstellen. try-catch-finally \u00b6 Prinzipiell besteht das Konstrukt try und catch nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem finally -Block. Der finally -Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt: try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } finally { // Aufraeumen, z.B. Schliessen von Dateien, Beenden von // Verbindungen zu Servern, Datenbanken etc. } Typischerweise wird der finally -Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden finally jedoch nicht sehr oft implementieren. throws - eine Exception weiterreichen \u00b6 Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem try-catch -Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort throws verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um throws und danach kommt der entsprechende Typ der Exxception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus: [ modifizierer ] [ rueckgabetyp ] methodenname throws ExceptionType { // Anweisungsblock // wirft (evtl.) Exception } Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse Ausnahmen um die Methode getValueAtIndex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static int getValueAtIndex ( int [] field , int index ) throws ArrayIndexOutOfBoundsException { return field [ index ] ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException mehrereExceptions (); int value = 0 ; boolean ok = true ; int [] field = { 8 , 3 , - 4 , 2 , - 9 }; try { value = getValueAtIndex ( field , - 3 ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Index ausserhalb des Arrays!\" ); ok = false ; } if ( ok ) { System . out . println ( \"value : \" + value ); } } Obwohl die Methode eine kritische Anweisung enth\u00e4lt ( field[index] ), ist diese Anweisung nicht in einen try-catch -Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine ArrayIndexOutOfBoundsException ) geworfen wird. Wir geben das im Methodenkopf mithilfe von throws ArrayIndexOutOfBoundsException bekannt. Die aufrufende Methode ( main ) kann nun selbst den Aufruf der Methode getValueAtIndex() in einen try-catch -Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode getValueAtIndex() zur\u00fcckgegebene Wert ausgegeben. Wenn wir an unsere einleitenden Beispiele denken (Methoden charAt() und divide() ), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von getValueAtIndex() vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei charAt() . Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln. Sch\u00f6ner Code \u00b6 Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP) \u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich) \u2192 lassen Sie Methode, die etwas eledigt, eine Exception werfen und leiten Sie diese weiter ( throws ) \u2192 fangen Sie den Fehler in einer anderen Methode ab ( try ) \u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers ( catch ) in eine dritte Methode auslagern (single responsibility) H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt ( try ) im catch -Block den fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an. throw - eigene Exceptions erzeugen \u00b6 Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich throw . Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort throws sehr \u00e4hnlich. Mit throw erzeugen (werfen) wir eine eigene Exception, mit throws wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe Traingle im ersten Semester bereits \u00fcberlegt, dass ddurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird? Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes throw wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja geworfen. F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten: entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse Exception oder von der Klasse RunTimeException ab ( extends Exception bzw. extends RunTimeException ) oder wir verwenden eine bereits existierende Exception-Klasse (typischerweise IllegalArgumentException ). throw new IllegalArgumentException \u00b6 Wir implementieren unsere Klasse Triangle so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine IllegalArgumentException werfen. Dieser Exception kann ein String als Parameter \u00fcbergeben werden, der im catch -Block mittels getMessage() wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist. Triangle mit eigenen IllegalArgumentExceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"Seiten muessen groesser als 0 sein!\" ); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalArgumentException ( \"Kein Dreieck!\" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } } } Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile 5 - throws IllegalArgumentException ). Im Konstruktor werden die Parameterwerte gepr\u00fcft und entweder eine IllegalArgumentException geworfen, falls eine Seite kleiner gleich 0 ist (Zeile 9 - throw new ) oder eine IllegalArgumentException geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile 13 - throw new ) oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen 17-19 ). Die Erzeugung eines Triangle -Objektes (also der Aufruf des Konstruktors) ist nun in einen try-catch -Block eingebettet (Zeilen 26-32 ). Beachten Sie, dass es sein kann, dass d nach Aufruf des Konstruktors immernoch null ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen. Eigene Exception-Klasse definieren \u00b6 Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von Triangle . Diese eigenen Exception-Klassen erben von der Klasse Exception . Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem try-catch -Block abgefangen und behandelt werden. Eigene Klasse IllegalTriangleException 1 2 3 4 5 6 7 8 9 10 public class IllegalTriangleException extends Exception { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides!\" ); } } Die Klasse IllegalTriangleException verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. Eigene Klasse IllegalSideLengthException 1 2 3 4 5 6 7 8 9 10 11 public class IllegalSideLengthException extends Exception { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Sides must be greater than zero!\" ); } } Die Klasse IllegalSideLengthException verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von Exception erzeugt und dem eine Fehlermeldung als String im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als String \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. Die Anwendung dieser beiden Exception-Klassen in der Klasse Triangle k\u00f6nnte nun so aussehen (wir haben hier auch gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen): Triangle mit den selbst definierten Exception-Klassen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws Exception { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalTriangleException (); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalSideLengthException (); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( Exception e ) { System . out . println ( e . getMessage ()); } } } Beide eigenen Klassen sind ja auch vom Laufzeittyp Exception , da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der catch -Klausel mit Exception (Zeile 30 ) passend. Wenn Sie anstelle der Zeilen 27-33 nur d = new Triangle(3,4,5); schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem try-catch -Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an Surround with try/catch . Das sollten Sie einmal ausprobieren. Wenn Sie anstelle von Exception von der Klasse RunTimeException erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden. Success Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von Exception , insb. von RunTimeException ). Mithilfe von try-catch-[finally] k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von throws zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort throw weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem try-catch -Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...","title":"Exceptions"},{"location":"exceptions/#exceptions","text":"Exceptions kennen wir schon, denn sie passieren uns h\u00e4ufiger. Wenn wir z.B. auf einen Index in einem Array zugreifen, dieser Index aber gar nicht existiert, wird eine ArrayIndexOutOfBounds -Exception geworfen. Wenn wir auf eine Objekteigenschaft zugreifen wollen, z.B. eine Objektmethode, die daf\u00fcr verwendete Referenzvariable aber gar nicht auf ein Objekt zeigt, sondern auf null , erhalten wir eine NullPointerException . Wenn bei einer Nutzereingabe eine Zahl erwartet, um damit weiterrechnen zu k\u00f6nnen, die Nutzerin gibt aber etwas anderes als eine Zahl ein, dann wird ebenfalls ein Exception geworfen . Wir wollen aber gar nicht, dass das Programm in solchen F\u00e4llen abst\u00fcrzt, sondern wir wollen diesen \u201eFehler\u201c erkennen und darauf reagieren. Grunds\u00e4tzlich gibt es also zwei Arten von Fehlern: syntaktische Fehler \u2192 k\u00f6nnen vom Compiler vor der Laufzeit erkannt werden; das programm wird gar nicht erst vollst\u00e4ndig compiliert und nicht ausgef\u00fchrt und logische Fehler \u2192 k\u00f6nnen erst zur Laufzeit erkannt werden. Im Falle der logischen Fehler, die erst zur Laufzeit auftreten, spricht man von Laufzeitfehlern (oder Ausnahmen oder Exceptions ). Die Aufgabe beim Programmieren ist nun, zu identifizieren, an welchen Stellen ein logischer Fehler auftreten k\u00f6nnte , z.B. fehlerhafte Benutzereingabe Datenbank- oder Netzwerkverbindung nicht verf\u00fcgbar gesuchte Datei/Ordner nicht vorhanden usw. Die Stellen, an denen ein solcher logischer Fehler auftreten k\u00f6nnte, nennen wir im Folgenden kritischer Abschnitt . Wir m\u00fcssen solche kritischen Abschnitte in unserem Quellcode identifizieren und haben dann die M\u00f6glichkeit, solche kritischen Abschnitte so zu implementieren, dass die Exception, die eventuell geworfen wird, abgefangen wird und das Programm dadurch nicht abst\u00fcrzt.","title":"Exceptions"},{"location":"exceptions/#try-catch","text":"Die grunds\u00e4tzliche Idee ist die, dass wir zun\u00e4chst versuchen den kritischen Abschnitt einfach auszuf\u00fchren. Wir versuchen z.B. einfach mit einem index auf das Array zuzugreifen, auch wenn wir gar nicht wissen, ob dies ein tats\u00e4chlicher index aus dem Array ist. Allerdings binden wir diesen Versuch in einen try{} -Block ein. Sollte in einem solchen try{} -Block nun eine Exception geworfen werden, dann fangen wir diese in einem catch(){} -Block auf und behandeln sie dort. Die allgemeine Syntax daf\u00fcr sieht so aus: allgemeine Syntax try-catch 1 2 3 4 5 6 7 8 try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } Es passiert Folgendes: wir f\u00fchren die Anweisung(en) in Zeile 3 aus. Wenn diese keine Exception wirft, also alles okay ist, dann machen wir einfach hinter dem catch -Block, also nach Zeile 8 weiter. Wenn aber die Anweisung(en) in Zeile 3 einen Laufzeitfehler verursachen, also eine Exception werfen, dann wird diese in Zeile 5 \"aufgefangen\" und in dem Anweisungsblock in den Zeilen 6-8 behandelt. Das Programm st\u00fcrzt nun nicht mehr ab, sondern wir haben die M\u00f6glichkeit, auf die Exception zu reagieren.","title":"try-catch"},{"location":"exceptions/#beispiel-ohne-try-catch","text":"Wir verdeutlichen dieses Prinzip an einem ersten Beispiel: Beispiel zun\u00e4chst ohne Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Ausnahmen { static char charAt ( String s , int index ) { char c = s . charAt ( index ); // kritisch! return c ; } static double divide ( int divident , int divisor ) { double result = divident / divisor ; // kritisch! return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Das Beispiel enth\u00e4lt zwei Methoden charAt() und divide . Der charAt -Methode wird ein String \u00fcbergeben und ein index . Die Methode gibt das Zeichen ( char ) zur\u00fcck, dass im String unter dem index gespeichert ist (z.B. charAt(\"Hallo\", 1) gibt das 'a' zur\u00fcck). Es wird jedoch gar nicht gepr\u00fcft, ob index tats\u00e4chlich ein korrekter Index des Strings s ist, d.h. evtl. ist index kleiner als 0 oder gr\u00f6\u00dfer als die L\u00e4nge von s minus 1 . Die Anweisung s.charAt(index); ist somit eine kritische Anweisung , denn sie kann (bei \"falschem\" index ) eine StringIndexOutOfBoundsException werfen. Genau so ist die Anweisung divident/divisor; in der Methode divide eine kritische Anweisung , da es sein kann, dass der divisior gleich 0 ist. Bei der int -Division durch 0 wird eine ArithmeticException geworfen. Wenn die main -Methode nun wie angegeben ausgef\u00fchrt wird, dann \"st\u00fcrzt\" das Programm bereits bei Ausf\u00fchrung von Zeile 16 ab und Zeile 17 wird gar nicht mehr erreicht: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at packageName.Ausnahmen.divide ( Ausnahmen.java:10 ) at packageName.Ausnahmen.main ( Ausnahmen.java:16 ) Die Fehlermeldung gibt uns an, welche Zeile die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:10 und um welche Exception es sich handelt, n\u00e4mlich ArithmeticException: / by zero . Wenn wir in der main -Methode Zeile 16 auskommentieren, dann sehen wir, dass auch die Anweisung in Zeile 17 eine Exception wirft, n\u00e4mlich: Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 5 at java.base/java.lang.StringLatin1.charAt ( StringLatin1.java:47 ) at java.base/java.lang.String.charAt ( String.java:702 ) at packageName.Ausnahmen.charAt ( Ausnahmen.java:5 ) at packageName.Ausnahmen.main ( Ausnahmen.java:17 ) Die Fehlermeldung gibt uns an, welche Zeile unseres Programms die Ausnahme geworfen hat, n\u00e4mlich Ausnahmen.java:5 und um welche Exception es sich handelt, n\u00e4mlich StringIndexOutOfBoundsException: String index out of range: 5 . Sie sehen auch, dass eigentlich sogar die Anweisung in Zeile 47 in der Klasse StringLatin1 in der dortigen Methode charAt die Exception geworfen hat. Wir werden dieses \"Weiterreichen\" von Exceptions gleich noch n\u00e4her betrachten.","title":"Beispiel ohne try-catch"},{"location":"exceptions/#beispiel-mit-try-catch","text":"Zun\u00e4chst \"reparieren\" wir unseren Code, indem wir try-catch -Bl\u00f6cke um unsere kritischen Anweisungen hinzuf\u00fcgen: Beispiel mit Behandlung der Exceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException } } Die kritischen Anweisungen wurden nun jeweils in einen try -Block integriert und die Behandlung der eventuell auftretenden Exceptions besteht nur aus einer jeweiligen Fehlerausgabe (ich habe hier daf\u00fcr nicht das Standardausgabeger\u00e4t out in den println -Anweisungen verwendet, sondern err - Zeilen 12 und 26 ). Wenn wir das Programm nun ausf\u00fchren (in main muss auch nichts mehr auskommentiert werden), dann erhalten wir die Ausgabe: Division durch 0 nicht definiert! 0 .0 Der Index war ausserhalb des Strings Das Programm \"st\u00fcrzt\" nun also nicht mehr ab, das ist schonmal ein Erfolg. So ganz optimal ist die L\u00f6sung allerdings noch nicht, da wir nun jeweils einen Nebeneffekt in unsere Methoden eingebaut haben. Angenommen, in der divide -Methode wird eine Exception geworfen, dann erfolgt durch Zeile 26 die Fehlerausgabe auf die Konsole. Danach wird in Zeile 28 aber result zur\u00fcckgegeben (hat den Wert 0.0 , den wir bei der Initailisierung in Zeile 19 angegeben haben) und dieser Wert wird durch Zeile 33 auf die Konsole ausgegeben. Das gleiche gilt f\u00fcr die charAt -Methode. Auch da haben wir einen Nebeneffekt eingebaut und es wird durch Zeile 34 das Leerzeichen auf die Konsole ausgegeben. Nebeneffekte wollen wir aber unbedingt vermeiden und m\u00fcssen unsere Implementierung deshalb noch \u00e4ndern. Zun\u00e4chst schauen wir uns aber den generellen Ablauf einer solchen Ausnahmesituation an:","title":"Beispiel mit try-catch"},{"location":"exceptions/#ablauf-einer-ausnahmesituation","text":"Der generelle Ablauf beim \"Werfen\" eine Exception ist wie folgt: Das Laufzeitsystem (JVM) erzeugt ein Ausnahme-Objekt (Objekt vom Elterntyp Exception ), wenn eine Exception \"geworfen\" wird Die Abarbeitung des Programmcodes wird sofort unterbrochen. Das Laufzeitsystem sucht nach der n\u00e4chsten catch -Klausel und f\u00fchrt diese aus. Passt die gefundene catch -Klausel nicht zur Art der Ausnahme, wird die n\u00e4chste catch -Klausel gesucht usw. Betrachten wir nochmal obigen Code, dann stellen wir fest, dass in der einen catch -Klausel (Zeile 10 ) ein Objekt vom Typ StringIndexOutOfBoundsException erwartet wird. Wir werden gleich sehen, dass dies schon ein sehr spezieller Typ in der Vererbungshierarchie von Exception ist. Das Programm w\u00fcrde auch genau so funktionieren, wenn wir dort anstelle von StringIndexOutOfBoundsException allegmein eine Exception erwarten w\u00fcrden. Das gleiche gilt f\u00fcr die andere catch -Klausel (Zeile 24 ), wo wir eine ArithmeticException erwarten. Wir schauen uns die Vererbungshierarchie der Exceptions gleich an. generell gilt, dass man mehrere catch -Bl\u00f6cke hintereinander setzen kann und der erste catch -Block, der dem erwartetetn Parametertyp entspricht, wird ausgef\u00fchrt. Wichtig ist, dass wir uns merken, dass durch eine Exception der Programmablauf sofort unterbrochen und zur n\u00e4chsten \"passenden\" catch -Klausel gesprungen wird.","title":"Ablauf einer Ausnahmesituation"},{"location":"exceptions/#ein-weiteres-beispiel","text":"Wir schauen uns dazu ein weiteres Beispiel an und erg\u00e4nzen unsere Klasse Ausnahmen um eine weitere Methode inputInt() : eine weitere methode inputInt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * Sollten Sie mit dem Modul-System von Java arbeiten, d.h. sollten * Sie eine Datei module-info.java in Ihrem Projekt-Ordner haben, * dann muessen Sie dort noch * module ProjektName * { * requires java.desktop; * } * eintragen, damit Sie das Paket javax.swing importieren koennen. */ import javax.swing.JOptionPane ; public class Ausnahmen { static char charAt ( String s , int index ) { char c = ' ' ; try { c = s . charAt ( index ); // kritisch! } catch ( StringIndexOutOfBoundsException e ) { System . err . println ( \"Der Index war ausserhalb des Strings\" ); } return c ; } static double divide ( int divident , int divisor ) { double result = 0.0 ; try { result = divident / divisor ; // kritisch! } catch ( ArithmeticException ae ) { System . err . println ( \"Division durch 0 nicht definiert!\" ); } return result ; } static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); inputOk = true ; try { inputInt = Integer . parseInt ( input ); } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException } } Schauen wir uns die Implementierung von inputInt() genauer an: in Zeile 50 wird ein kleines Eingabefenster erzeugt ( JOptionPane ist eine Klasse aus dem javax.swing -Paket, welches wiederum im Modul java.desktop verf\u00fcgbar ist). Die Eingabe in dieses Fenster wird als String zur\u00fcckgegeben und in der Variablen input gespeichert. in Zeile 53 wird versucht, den Eingabestring input in ein int umzuwandeln. Dazu wird die Methode parseInt() verwendet, die zur Klasse Integer geh\u00f6rt ( Integer ist eine sogenannte Wrapper-Klasse - diese schauen wir uns n\u00e4chste Woche an). wenn input eine Zahl enth\u00e4lt, also z.B. so aussieht: \"1234\" , dann erzeugt parseInt() daraus die int -Zahl 1234 und alles ist ok. Wenn input jedoch keine Zahl enth\u00e4lt, also z.B. \"hallo\" , dann wirft parseInt() eine NumberFormatException , weil die Umwandlung des String s in ein int nicht m\u00f6glich ist. in Zeile 55 wird eine solche NumberFormatException aufgefangen. Die \"Behandlung\" dieser Excepion sieht so aus, dass der Schalter inputOk auf false gesetzt wird. der gesamte Anweisungsblock Fenster->Eingabe->try-catch ist in eine Schleife eingebettet. Diese Schleife wird so lange ausgef\u00fchrt, so lange der Wert von inputOk nicht false ist. Das bedeutet, wenn keine Zahl eingegeben wird, dann \u00f6ffnet sich das Fenster erneut und es muss so lange eine Eingabe erfolgen, bis die Eingabe einer Zahl entspricht (und somit parseInt() keine Exception wirft) \u00dcbrigend k\u00f6nnte die Anweisung inputOk = true; auch nach parseInt() in den try -Block geschrieben werden: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int inputInt () { int inputInt = 0 ; boolean inputOk = false ; String input = \"\" ; while ( ! inputOk ) { input = JOptionPane . showInputDialog ( \"Zahl :\" ); try { inputInt = Integer . parseInt ( input ); inputOk = true ; } catch ( NumberFormatException e ) { inputOk = false ; } } return inputInt ; } Zeile 12 wird nur genau dann erreicht, wenn parseInt() keine Exception wirft. Dann wird auch der catch -Block nicht betreten und die Schleife wird beendet.","title":"Ein weiteres Beispiel"},{"location":"exceptions/#beispiel-mit-mehreren-exceptions","text":"Wir betrachten jetzt einmal an einem Besipiel die bei Ablauf einer Ausnahmesituation unter Punkt 4 beschriebene Situation, dass die n\u00e4chstpassende catch -Klausel gesucht wird. Wir erweitern dazu unsere Klasse Ausnahmen um eine weitere Methode mehrereExceptions() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public static void mehrereExceptions () { String [] basen = { \"2\" , \"8\" , \"10\" , \"Hi\" }; int base = 0 ; double result = 0 ; boolean ok = true ; for ( int index = 0 ; index <= 4 ; index ++ ) { try { base = Integer . parseInt ( basen [ index ] ); ok = true ; } catch ( NumberFormatException nfe ) { System . out . println ( \"Keine Zahl!\" ); ok = false ; } catch ( IndexOutOfBoundsException ioobe ) { System . out . println ( \"Ausserhalb des Arrays\" ); ok = false ; } for ( int exp = 0 ; exp < 6 && ok ; exp ++ ) { result = Math . pow ( base , exp ); System . out . printf ( \"%d ^ %d = %.0f %n\" , base , exp , result ); } } } In Zeile 3 definieren wir uns ein String[] mit 4 Eintr\u00e4gen. Durch dieses String[] laufen wir mit einer for -Schleife (Zeile 8 ) durch. In Zeile 11 wndeln wir jeden Eintrag aus dem String[] in eine int -Zahl um. An zwei Stellen k\u00f6nnen Exceptions geworfen werden: Bei dem Index-basierten Zugriff auf das Array basen[index] in Zeile 11 kann eine ArrayIndexOutOfBounds -Exception geworfen werden, falls index kein korrekter Index des String[] ist (gilt f\u00fcr index==4 ). Bei der Umwandlung von String nach int durch parseInt() in Zeile 11 kann eine NumberFormatException geworfen werden, falls der entsprechende Eintrag im String[] keine Zahl ist (gilt f\u00fcr basen[3]=='Hi' ). Die Methode erzeugt die folgende Ausgabe: 2 ^ 0 = 1 2 ^ 1 = 2 2 ^ 2 = 4 2 ^ 3 = 8 2 ^ 4 = 16 2 ^ 5 = 32 8 ^ 0 = 1 8 ^ 1 = 8 8 ^ 2 = 64 8 ^ 3 = 512 8 ^ 4 = 4096 8 ^ 5 = 32768 10 ^ 0 = 1 10 ^ 1 = 10 10 ^ 2 = 100 10 ^ 3 = 1000 10 ^ 4 = 10000 10 ^ 5 = 100000 Keine Zahl! Ausserhalb des Arrays Das hei\u00dft, dass wenn f\u00fcr parseInt(\"Hi\") eine NumberFormatException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine NumberFormatException erwartet (Zeilen 14-17 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wenn f\u00fcr basen[4] eine ArrayIndexOutOfBoundsException geworfen wird, dann wird der catch -Block ausgef\u00fchrt, der eine IndexOutOfBoundsException erwartet (Zeilen 18-21 ). Der andere catch -Block wird nicht ausgef\u00fchrt. Wir sehen, dass es offensichtlich auch eine IndexOutOfBoundsException -Klasse gibt. Das ist eine Elternklasse von ArrayIndexOutOfBoundsException und auch von StringIndexOutOfBoundsException . Wir schauen uns diese Vererbungshierarchie von Exception nun mal an:","title":"Beispiel mit mehreren Exceptions"},{"location":"exceptions/#die-vererbungshierarchie-der-klasse-exception","text":"Wenn Sie sich die Klasse Exception in der Java-Dokumentation einmal anschauen, dann sehen Sie, dass diese Klasse ein Unmenge von Kindklassen hat. Wir betrachten hier einmal die f\u00fcr uns wichtigsten Klassen: Alle Exception-Klassen erben von der Klasse Exception , die im java.lang -Paket definiert ist. Grunds\u00e4tzlich werden zwei Arten von Exceptions unterschieden: checked Exceptions: Checked Exceptions m\u00fcssen gepr\u00fcft werden, d.h. Methoden, die eine checked Exception werfen k\u00f6nnen, m\u00fcssen in einen try-catch -Block integriert werden. Dies wird bereits zur Compilezeit gepr\u00fcft, d.h. das Programm l\u00e4sst sich gar nicht compilieren, wenn eine Methode, die eventuell eine checked Exception wirft, nicht in einem try -Block steht. In der Abbildung stehen checked Exceptions auf der rechten Seite (gr\u00fcn). unchecked Exceptions: Unchecked Exceptions k\u00f6nnen gepr\u00fcft werden, m\u00fcssen aber nicht. Alle unchecked Exceptions leiten sich von der Klasse RunTimeException ab. Wir werden uns genau mit diesen uncheck Exceptions, also von RunTimeException abgeleiteten Klassen besch\u00e4ftigen. Es gibt von RunTimeException noch viele weitere Kindklassen, wie man in der Java-Dokumentation sehen kann, aber die in der Abbildung gezeigten sind die wichtigsten. Eine Kindklasse davon, die IllegalArgumentException -Klasse wird f\u00fcr uns noch eine weitere Rolle spielen, da wir von ihr erben werden, wenn wir uns eigene Exception -Klassen erstellen.","title":"Die Vererbungshierarchie der Klasse Exception"},{"location":"exceptions/#try-catch-finally","text":"Prinzipiell besteht das Konstrukt try und catch nicht nur aus diesen beiden Bl\u00f6cken, sondern auch noch aus dem finally -Block. Der finally -Block wird grunds\u00e4tzlich immer ausgef\u00fchrt, egal, ob eine Exception geworfen wird oder nicht. Die Syntax ist wie folgt: try { // Anweisung(en), die evtl. Fehler verursachen (kritischer Abschnitt) } catch ( Exception e ) { // Behandlung der Exception } finally { // Aufraeumen, z.B. Schliessen von Dateien, Beenden von // Verbindungen zu Servern, Datenbanken etc. } Typischerweise wird der finally -Block dazu verwendet, bestimmte Ressourcen wieder freizugeben, z.B. Dateien zu schlie\u00dfen, Verbindungen zu Servern, Datenbanken usw. zu beenden. Wir werden finally jedoch nicht sehr oft implementieren.","title":"try-catch-finally"},{"location":"exceptions/#throws-eine-exception-weiterreichen","text":"Wir haben bis jetzt immer in den Methoden, in denen die kritische Anweisung ausgef\u00fchrt wurde, diese direkt mit einem try-catch -Block \"ummantelt\". Das muss nicht unbedingt sein. Wir k\u00f6nnen eine in einer Methode geworfene Exception auch an die aufrufende Methode weiterreichen. Dann kann (und sollte) die Exception in der aufrufenden Methode abgefangen und behandelt werden. Um anzugeben, dass eine Methode evtl. eine Exception wirft, wird das Schl\u00fcsselwort throws verwendet. Wir erweiteren also die Deklaration einer Methode (also den Methodenkopf) um throws und danach kommt der entsprechende Typ der Exxception, die in der Methode geworfen werden kann. Die allgemeine Syntax einer Methodendeklaration sieht somit so aus: [ modifizierer ] [ rueckgabetyp ] methodenname throws ExceptionType { // Anweisungsblock // wirft (evtl.) Exception } Wir betrachten auch daf\u00fcr ein Beispiel und erweiteren unsere Klasse Ausnahmen um die Methode getValueAtIndex : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 static int getValueAtIndex ( int [] field , int index ) throws ArrayIndexOutOfBoundsException { return field [ index ] ; } public static void main ( String [] args ) { System . out . println ( divide ( 5 , 0 )); // ArithmeticException System . out . println ( charAt ( \"Hallo\" , 5 )); // StringIndexOutOfBoundsException System . out . println ( \"Zahl: \" + inputInt ()); // NumberFormatException mehrereExceptions (); int value = 0 ; boolean ok = true ; int [] field = { 8 , 3 , - 4 , 2 , - 9 }; try { value = getValueAtIndex ( field , - 3 ); } catch ( ArrayIndexOutOfBoundsException e ) { System . out . println ( \"Index ausserhalb des Arrays!\" ); ok = false ; } if ( ok ) { System . out . println ( \"value : \" + value ); } } Obwohl die Methode eine kritische Anweisung enth\u00e4lt ( field[index] ), ist diese Anweisung nicht in einen try-catch -Block eingebunden. Es kann nun also sein, dass bei Aufruf der Methode eine Exception (eine ArrayIndexOutOfBoundsException ) geworfen wird. Wir geben das im Methodenkopf mithilfe von throws ArrayIndexOutOfBoundsException bekannt. Die aufrufende Methode ( main ) kann nun selbst den Aufruf der Methode getValueAtIndex() in einen try-catch -Block ummanteln und somit die Exception selbst abfangen und behandeln. Nur wenn keine Exception geworfen wird, wird der von der Methode getValueAtIndex() zur\u00fcckgegebene Wert ausgegeben. Wenn wir an unsere einleitenden Beispiele denken (Methoden charAt() und divide() ), dann erinnern wir uns, dass wir dort festegestellt haben, dss die Implementierung so nicht g\u00fcnstig war, da sie Nebeneffekte erzeugt hat, sobald eine Exception geworfen wurde. Diese Nebeneffekte werden bei der Implementierung von getValueAtIndex() vermieden, obwohl die grunds\u00e4tzliche Idee die gleiche ist, wie bei charAt() . Der Nachteil ist, dass man die aufrufende Methode \"zwingt\", die Exception selbst zu behandeln.","title":"throws - eine Exception weiterreichen"},{"location":"exceptions/#schoner-code","text":"Der letzte Satz aus dem vorherigen Abschnitt ist insofern nicht ganz richtig, dass mit unchecked Exceptions ja genau nicht erzwungen wird, eventuelle Exceptions abzufangen. Es gibt gute Gr\u00fcnde daf\u00fcr, alle eigenen Exceptions eher als checked Exceptions zu definieren, als als unchecked Exceptions. Aber zu eigenen Exceptions kommen wir gleich. Trotzdem k\u00f6nnen wir uns schon zum jetzigen Zeitpunkt einige Gedanken, \u00fcber sch\u00f6nen Code in Bezug auf Exceptions machen: eine Methode sollte immer nur eine Sache erledigen (single responsibility principle - SRP) \u2192 die Methode kann nicht auch noch f\u00fcr das Abfangen des Fehlers zust\u00e4ndig sein (try-catch-Bl\u00f6cke sind eh \u201eh\u00e4sslich\u201c und unleserlich) \u2192 lassen Sie Methode, die etwas eledigt, eine Exception werfen und leiten Sie diese weiter ( throws ) \u2192 fangen Sie den Fehler in einer anderen Methode ab ( try ) \u2192 Sie k\u00f6nnen sogar die eigentliche Behandlung des Fehlers ( catch ) in eine dritte Methode auslagern (single responsibility) H\u00e4ufig sieht man, dass die Methode, die den Fehler abf\u00e4ngt ( try ) im catch -Block den fehler protokolliert (in ein ErrorLog-File) und dann eine eigens erzeugte Exception an die Methode weiterleitet, die den Fehler behandelt. Wie man eine Exception erzeugt, schauen wir uns jetzt an.","title":"Sch\u00f6ner Code"},{"location":"exceptions/#throw-eigene-exceptions-erzeugen","text":"Zun\u00e4chst kommt ein neues Schl\u00fcsselwort hinzu, n\u00e4mlich throw . Ungl\u00fccklicherweise ist dies dem Schl\u00fcsselwort throws sehr \u00e4hnlich. Mit throw erzeugen (werfen) wir eine eigene Exception, mit throws wird im Methodenkopf angegeben, dass die Methode (eventuell) eine Exception wirft und diese an die aufrufende Methode weitergibt. Angenommen, f\u00fcr einen Konstruktor der Klasse Dreieck werden Seitenl\u00e4ngen \u00fcbergeben, die entweder kleiner als 0 oder die Summe von 2 Seitenl\u00e4ngen ist kleiner als die dritte Seite ist. Wir hatten uns bei der Bearbeitung der Aufgabe Traingle im ersten Semester bereits \u00fcberlegt, dass ddurch kein \"richtiges\" Dreieck erzeugt wird, aber wir konnten das noch nicht verhindern. das machen wir jetzt. Wie k\u00f6nnen wir also verhindern, dass ein solches Objekt erzeugt wird? Die L\u00f6sung besteht darin, eine eigene Exception zu definieren und diese im Fehlerfall zu werfen. Mithilfe des Schl\u00fcsselwortes throw wird also eine eigene Exception geworfen. Bis jetzt wurden unsere Exceptions ja geworfen. F\u00fcr eine eigene Exception haben wir zwei M\u00f6glichkeiten: entweder erstellen wir uns eine eigene Exception-Klasse und leiten diese von der Klasse Exception oder von der Klasse RunTimeException ab ( extends Exception bzw. extends RunTimeException ) oder wir verwenden eine bereits existierende Exception-Klasse (typischerweise IllegalArgumentException ).","title":"throw - eigene Exceptions erzeugen"},{"location":"exceptions/#throw-new-illegalargumentexception","text":"Wir implementieren unsere Klasse Triangle so, dass wir im Konstruktor f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist, eine IllegalArgumentException werfen. Dieser Exception kann ein String als Parameter \u00fcbergeben werden, der im catch -Block mittels getMessage() wieder ausgelesen werden kann. Das gleiche machen wir f\u00fcr den Fall, dass die Summe von zwei Seiten kleiner der dritten Seite ist. Triangle mit eigenen IllegalArgumentExceptions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws IllegalArgumentException { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalArgumentException ( \"Seiten muessen groesser als 0 sein!\" ); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalArgumentException ( \"Kein Dreieck!\" ); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( IllegalArgumentException e ) { System . out . println ( e . getMessage ()); } } } Der Konstruktor f\u00e4ngt die Exception nicht selbst auf und behandelt sie auch nicht selbst, sondern leitet sie an die aufrufende Methode weiter (Zeile 5 - throws IllegalArgumentException ). Im Konstruktor werden die Parameterwerte gepr\u00fcft und entweder eine IllegalArgumentException geworfen, falls eine Seite kleiner gleich 0 ist (Zeile 9 - throw new ) oder eine IllegalArgumentException geworfen, falls die Summe von zwei Seiten kleiner als die dritte Seite ist (Zeile 13 - throw new ) oder die Objektvariablen die Werte der Parameter bekommen (wenn alles ok ist - Zeilen 17-19 ). Die Erzeugung eines Triangle -Objektes (also der Aufruf des Konstruktors) ist nun in einen try-catch -Block eingebettet (Zeilen 26-32 ). Beachten Sie, dass es sein kann, dass d nach Aufruf des Konstruktors immernoch null ist (n\u00e4mlich dann, wenn eine Exception geworfen wird). Wir haben hier gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen.","title":"throw new IllegalArgumentException"},{"location":"exceptions/#eigene-exception-klasse-definieren","text":"Wir erstellen uns eigene Exception-Klassen f\u00fcr die oben beschriebenen \"Fehler\" im Konstruktor von Triangle . Diese eigenen Exception-Klassen erben von der Klasse Exception . Damit sind die eigenen Exceptions checked Exceptions, d.h. sie m\u00fcssen in einem try-catch -Block abgefangen und behandelt werden. Eigene Klasse IllegalTriangleException 1 2 3 4 5 6 7 8 9 10 public class IllegalTriangleException extends Exception { public IllegalTriangleException ( String s ) { super ( s ); } public IllegalTriangleException () { super ( \"Each side has to be smaller than the sum of the other sides!\" ); } } Die Klasse IllegalTriangleException verwenden wir f\u00fcr den Fall, dass die Summe zweier Seiten kleiner als die dritte Seite ist. Eigene Klasse IllegalSideLengthException 1 2 3 4 5 6 7 8 9 10 11 public class IllegalSideLengthException extends Exception { public IllegalSideLengthException ( String s ) { super ( s ); } public IllegalSideLengthException () { super ( \"Sides must be greater than zero!\" ); } } Die Klasse IllegalSideLengthException verwenden wir f\u00fcr den Fall, dass eine Seite kleiner gleich 0 ist. F\u00fcr beide Klassen haben wir jeweils einen parameterlosen Konstruktor definiert, der ein Objekt von Exception erzeugt und dem eine Fehlermeldung als String im Parameter \u00fcbergeben wird. Au\u00dferdem haben wir in beiden Klassen noch einen parametrisierten Konstruktor, dem eine Fehlermeldung als String \u00fcbergeben werden kann. Wir haben nun die Wahl, ob wir den paarmeterlosen oder den parametrisierten Konstruktor verwenden. Die Anwendung dieser beiden Exception-Klassen in der Klasse Triangle k\u00f6nnte nun so aussehen (wir haben hier auch gleich die main -Methode mit in die Klasse genommen, das sollte man nat\u00fcrlich nicht machen): Triangle mit den selbst definierten Exception-Klassen 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Triangle { private int a , b , c ; public Triangle ( int a , int b , int c ) throws Exception { if ( a <= 0 || b <= 0 || c <= 0 ) { throw new IllegalTriangleException (); } else if ( a >= ( b + c ) || b >= ( a + c ) || c >= ( a + b )) { throw new IllegalSideLengthException (); } else { this . a = a ; this . b = b ; this . c = c ; } } public static void main ( String [] args ) { Triangle d ; try { d = new Triangle ( 3 , 4 , 5 ); //(3,4,0) und (3,4,8) probieren } catch ( Exception e ) { System . out . println ( e . getMessage ()); } } } Beide eigenen Klassen sind ja auch vom Laufzeittyp Exception , da sie von dieser Klasse geerbt haben. Insofern ist der Parametertyp in der catch -Klausel mit Exception (Zeile 30 ) passend. Wenn Sie anstelle der Zeilen 27-33 nur d = new Triangle(3,4,5); schreiben, stellen Sie fest, dass sich das Programm nicht \u00fcbersetzen l\u00e4sst, da es sich um checked Exceptions handelt, die in einem try-catch -Block abgefangen werden m\u00fcssen. Eclipse bietet Ihnen dann aber einen QuickFix an Surround with try/catch . Das sollten Sie einmal ausprobieren. Wenn Sie anstelle von Exception von der Klasse RunTimeException erben, dann handelt es sich bei Ihren Exceptions um unchecked Exceptions. Es ist aber besseres Programmieren, wenn man checked Exceptions erstellt, denn dazu sind die Exceptions ja da, dass sie abgefangen und behandelt werden. Success Wir haben Exceptions kennengelernt. Solche Laufzeitfehler k\u00f6nnen an verschiedenen Stellen passieren und haben unterschiedliche Typen (siehe Kindklassen von Exception , insb. von RunTimeException ). Mithilfe von try-catch-[finally] k\u00f6nnen wir solche Exceptions abfangen und behandeln. Damit st\u00fcrzt unser Programm nicht mehr ab. Mithilfe von throws zeigt eine Methode an, dass sie eine Exception erzeugen kann. Das Schl\u00fcsselwort throw weist die Laufzeitumgebung an, das angegebene Laufzeitobjekt (eine Exception) zu erzeugen und zu werfen. Checked Exceptions m\u00fcssen behandelt werden (Aufruf der Exception-werfenden Methode in einem try-catch -Block). Unchecked Exceptions k\u00f6nnen behandelt werden, m\u00fcssen aber nicht, sollten aber. K\u00f6nnen wir ja jetzt schlie\u00dflich...","title":"Eigene Exception-Klasse definieren"},{"location":"git/","text":"Git \u00b6 Git ist ein Versionierungswerkzeug f\u00fcr die Softwareentwicklung. Mit Git k\u00f6nnen Sie Ihre Software versionieren, d.h. Versionen Ihrer Software erstellen und zwischen diesen Versionen hin- und herwecheseln sowie im Team gemeinsam an einem Softwareprojekt arbeiten und die einzelnen Entwicklungen aller Teammitglieder geeignet zusammenf\u00fchren. Git ist Open Source und frei verf\u00fcgbar . Entstanden ist Git im Rahmen der Entwicklung von Linux , initiiert durch Linus Torvalds , dem Initiator von Linux. Installation von Git \u00b6 Um Git verwenden zu k\u00f6nnen, m\u00fcssen Sie es zun\u00e4chst installieren. Laden Sie sich Git f\u00fcr Ihr Betriebssystem von der Download-Seite herunter bzw. gehen Sie so vor, wie f\u00fcr Ihr Betriebssystenm beschrieben. Installationshilfen erhalten Sie z.B. auch im frei verf\u00fcgbaren Git-Buch unter Git installieren oder auch im Video \u00fcber die ersten Schritte mit Git. Wenn Sie unter Windows arbeiten, dann erhalten Sie mit Git eine GitBash . Wenn wir von nun an vom Terminal (oder Shell oder Bash ) sprechen, dann verwenden Sie bitte immer diese GitBash . Nach erfolgreicher Installation k\u00f6nnen Sie im Terminal den Befehl git --version eingeben und es sollte eine Ausgabe, wie git version 2 .30.1 oder eine aktuellere Versionsnummer erfolgen. Wir k\u00f6nnen Git nun verwenden und betrachten zun\u00e4chst, wie Git als Versionierungswerkzeug verwendet werden kann und schauen uns danach an, wie es als Kollaborationswerkzeug verwendet wird. Git als Versionierungswerkzeug \u00b6 Die grunds\u00e4tzliche Idee von Git ist, \u00c4nderungen an Dateien und Ordnern so zu speichern, dass alle diese \u00c4nderungen nachverfolgbar sind. Git erzeugt sogenannte Snapshots aller Dateien und Ordner und speichert diese Snapshots nacheinander lokal ab. D.h. alles passiert bei Ihnen lokal auf dem Rechner, Sie ben\u00f6tigen keine Verbindung zu einem Server. Wenn Sie sp\u00e4ter im Team zu Mehreren an einem Projekt arbeiten, dann gleichen Sie immer nur die Historien Ihrer Snapshots ab. Git f\u00fcgt immer nur hinzu und das ist auch korrekt so. Selbst, wenn in sp\u00e4teren Versionen Ihres eine Datei nicht mehr existiert, die in fr\u00fcheren Versionen des Projektes noch existierte, soll diese Datei gar nicht gel\u00f6scht werden, denn es k\u00f6nnte ja sein, dass Sie irgendwann nochmal die fr\u00fchere Version anschauen wollen, die die Datei enthielt. Dieses Skript hier z.B. verwalte ich mit Git. Das bedeutet, dass alle Dateien eines Ordners (und Unterordnern) in einem sogenannten Git-Repository (oder nur Repository ) verwaltet werden. F\u00fcr dieses Skript hier k\u00f6nnte das z.B. so aussehen: Das hei\u00dft, ich erstelle zun\u00e4chst 3 Dateien: Einf\u00fchrung , Wiederholung und Git und \"sage\" Git, dass dies Version1 sein soll. Danach f\u00fcge ich 3 weitere Dateien hinzu Aufgaben , \u00dcbungen und Wrapperklassen und zusammen mit den vorherigen 3 Dateien aus Version 1 ergibt das dann Version 2 . Danach \u00e4ndere ich (f\u00fcge hinzu) die Dateien Aufgaben und \u00fcbungen und f\u00fcge au\u00dferdem neue Dateien f\u00fcr Exceptions und JUnit hinzu und \"sage\", dass das insgesamt Version 3 ergibt usw. Git verwaltet nun diese Versionen und der Vorteil ist, dass ich jede dieser Versionen separat zur Verf\u00fcgung stellen k\u00f6nnte und auch auf diesen Versionen weiterarbeiten. Wir werden in Zukunft in Bezug auf Git aber nicht mehr unbedingt von Versionen sprechen, sondern von Snapshots . Wir schauen uns das nun in einem Besipiel an. git init - ein Repository erstellen \u00b6 Angenommen, wir haben in unserem workspace folgende Ordner-Struktur: In dem workspace gibt es ein Projekt Projekt1 und darin einen src -Ordner mit unseren *.java -Dateien und einen bin -Ordner mit unseren *.class -Dateien. Wir lassen f\u00fcr dieses einf\u00fchrende Beispiel einmal Pakete weg. Diese w\u00fcrden ja als Ordner-Struktur sowohl innerhalb von src als auch von bin auftauchen. So sieht also ein typischer workspace aus. Es gibt darin noch weitere Ordner und Dateien, wie z.B. .idea , .metadata , .classpath , .project , .settings , die von unseren Entwicklungsumgebungen (Eclipse, IntelliJ, ...) angelegt wurden. Wir wollen nun unseren workspace von Git verwalten lassen. Dazu wechseln wir im Terminal in den workspace -Ordner und f\u00fchren dort das Kommando git init aus. Dieses Kommando erstellt das Git-Repository . Es muss genau einmal, n\u00e4mlich ganz am Anfang zur Erstellung des Repositorys ausgef\u00fchrt werden. Im Terminal erscheint Hinweis: Als Name f\u00fcr den initialen Branch wurde 'master' benutzt. Dieser Hinweis: Standard-Branchname kann sich \u00e4ndern. Um den Namen des initialen Branches Hinweis: zu konfigurieren, der in allen neuen Repositories verwendet werden soll und Hinweis: um diese Warnung zu unterdr\u00fccken, f\u00fchren Sie aus: Hinweis: Hinweis: git config --global init.defaultBranch <Name> Hinweis: Hinweis: H\u00e4ufig gew\u00e4hlte Namen statt 'master' sind 'main' , 'trunk' und Hinweis: 'development' . Der gerade erstellte Branch kann mit diesem Befehl Hinweis: umbenannt werden: Hinweis: Hinweis: git branch -m <Name> Leeres Git-Repository in /...IhrPfadZumWorkspaceOrdner.../workspace/.git/ initialisiert Somit wurde ein Git-Repository erstellt. Der workspace -Ordner wird nun von Git verwaltet. Dies erkennen Sie daran, dass in dem workspace -Ordner ein .git -Ordner angelegt wurde: Klicken Sie ruhig mal in den Ordner, um zu sehen, was da alles drin ist. .gitignore - Dateien aus der Verwaltung ausschlie\u00dfen \u00b6 Git w\u00fcrde nun den gesamten workspace -Ordner verwalten. Das w\u00e4re zun\u00e4chst auch gar kein Problem. Aber wenn Sie im Team zu mehreren am selben Projekt (workspace) arbeiten, dann wollen Sie bestimmte Dateien gar nicht untereinander austauschen, z.B. alle Dateien, die von Ihrer IDE erstellt wurden (z.B. .idea , .metadata , .classpath , .project , .settings ). Auch alle Dateien im bin -Ordner m\u00fcssen nicht von Git verwaltet werden, weil Sie ja stets neu durch das Compilieren erzeugt werden. Noch bevor wir nun also unsere erste Version erzeugen wollen, schlie\u00dfen wir zun\u00e4chst einige Ordner und Dateien aus der Verwaltung von Git aus. Dazu wird im workspace -Ordner eine Datei .gitignore erstellt, in die wir alle Dateien und Ordner eintragen, die wir aus der Git-Verwaltung ausschlie\u00dfen wollen. Bevor wir das machen, geben wir im Terminal in unserem workspace -Ordner einmal den Befehl git status ein. Dies wird der am meisten verwendete Befehl f\u00fcr uns sein, der mit dem Befehl bekommen wir Auskunft \u00fcber den aktuellen Status des Repositorys. Die Ausgabe derzeit ist Auf Branch master Noch keine Commits Unversionierte Dateien: ( benutzen Sie \"git add <Datei>...\" , um die \u00c4nderungen zum Commit vorzumerken ) .DS_Store .idea/ .metadata/ Projekt1/ nichts zum Commit vorgemerkt, aber es gibt unversionierte Dateien ( benutzen Sie \"git add\" zum Versionieren ) Das m\u00fcssen wir zum jetzigen Zeitpunkt noch nicht alles verstehen, aber wir sehen, dass Git derzeit die Datei .DS_Store und die Ordner .idea/ , .metadata/ und Projekt1/ verwaltet und wir ja eigentlich nur die Verwaltung von Projekt1/ w\u00fcnschen (und darin auch nicht alles). Wir erstellen uns also im workspace -Ordner eine .gitignore -Datei und geben darin ein: .DS_Store .idea .metadata Projekt1/bin Projekt1/.classpath Projekt1/.project Projekt1/.settings Damit geben wir an, dass die Datei .DS_Store ignoriert werden soll (gibt es nur unter Mac - legt der Finder automatisch zur schnelleren Suche an) sowie die Ordner .idea und .metadata . H\u00e4tten wir .idea/ und .metadata/ geschrieben, w\u00fcrde der Ordner jeweils selbst mit in der Git-Verwaltung sein, jedoch der Kontent nicht. Ansonsten soll auch noch der Ordner Projekt1/bin aus der Git-Verwaltung entfernt werden und alle Dateien und Ordner, die mit einem Punkt beginnen und im Ordner Projekt1 liegen. Wenn man alle Dateien ignorieren m\u00f6chte, die mit einem Punkt beginnen, egal in welchem ordner, dann k\u00f6nnte man auch .* in die .gitignore schreiben. Dann w\u00fcrde allerdings auch die .gitignore selbst dazugeh\u00f6ren. Diese kann und sollte man aber ruhig mit in die Git-Verwaltung aufnehmen. Eine \u00dcbersicht \u00fcber m\u00f6gliche Eintr\u00e4ge in die .gitignore findet man z.B. hier oder hier . Wenn wir jetzt erneut git status eingeben, dann ist die Ausgabe: Auf Branch master Noch keine Commits Unversionierte Dateien: ( benutzen Sie \"git add <Datei>...\" , um die \u00c4nderungen zum Commit vorzumerken ) .gitignore Projekt1/ nichts zum Commit vorgemerkt, aber es gibt unversionierte Dateien ( benutzen Sie \"git add\" zum Versionieren ) D.h. wir sehen, dass die Dateien und Ordner .DS_Store , .idea/ und .metadata/ nun nicht mehr mit verwaltet werden, daf\u00fcr aber die .gitignore . Wir haben jetzt ein Git-Repoitory , aber es ist noch leer. Wir f\u00fcgen nun Dateien diesem Repository hinzu. git add - dem Repository Dateien hinzuf\u00fcgen \u00b6 Wir haben noch keine Ordner und Dateien in unser Repository aufgenommen, d.h. es werden noch keine \u00c4nderungen an diesen Dateien durch Git verwaltet. Um Dateien dem Repository hinzuzuf\u00fcgen, verwenden wir das Kommando git add . Wir wollen den Ordner Projekt1 und die Datei .gitignore dem Repository hinzuf\u00fcgen, um sie von nun an von Git verwalten zu lassen (d.h. ihre \u00c4nderungen zu \"protokollieren\"). Wir geben im Terminal im workspace -Ordner ein: git add .gitignore git add Projekt1 und f\u00fcgen somit den gesamten Ordner Projekt1 (aber nicht die in der .gitignore definierten Dateien und Ordner aus dem Ordner Projekt1 ) und die .gitignore -Datei dem Repository hinzu. git status ergibt nun: Auf Branch master Noch keine Commits Zum Commit vorgemerkte \u00c4nderungen: ( benutzen Sie \"git rm --cached <Datei>...\" zum Entfernen aus der Staging-Area ) neue Datei: .gitignore neue Datei: Projekt1/src/A.java neue Datei: Projekt1/src/B.java D.h. von nun an werden von Git die Dateien .gitignore , Projekt1/src/A.java und Projekt1/src/B.java verwaltet. Die Dateien A.java und B.java sind jetzt noch leer. Wann immer wir eine neue Datei in unserem workspace erstellen und wir wollen, dass sie von Git verwaltet wird, f\u00fcgen wir diese Datei mit git add <datei> dem repository hinzu! Wann immer wir eine neue Datei in unserem workspace erstellen und wir nicht wollen, dass sie von Git verwaltet wird, f\u00fcgen wir diese Datei der .gitignore -Datei hinzu! Mit dem Befehl git add . werden einfach immer alle neuen Dateien hinzugef\u00fcgt. Wir werden diesen Befehl h\u00e4ufig nutzen, um nicht alle neuen Dateien einzeln aufzulisten. Es gibt f\u00fcr add auch die Option --all ( -A ), mit der alle Dateien aus einem Ordner hinzugef\u00fcgt werden. git commit - einen Snapshot erstellen \u00b6 Mit git commit \"speichern\" wir das gesamte Repository. Git merkt sich den Stand aller Dateien und Ordner und den Zeitpunkt des Commits. Zus\u00e4tzlich geben wir zum git commit noch eine Commit-Nachricht an, um den Stand der Arbeit zu beschreiben. In einem Snapshot werden alle \u00c4nderungen im Vergleich zum vorherigen Snapshot gespeichert. Man kann sich also die Versionierung mit Git wie eine Reihe von Commits (Snapshots) vorstellen: Ganz am Anfang ein initiales Commit ( C0 ), dann wurde weiter gearbeitet und ein weiteres Commit ( C1 ) gesetzt und so weiter ( C2 ). Es ist ohne Probleme m\u00f6glich, wieder zum Stand von C1 oder sogar C0 \"zur\u00fcckzuspringen\" (zeigen wir sp\u00e4ter, wie). Zun\u00e4chst erstellen wir unser initiales Commit. Dazu geben wir im Terminal im workspace -Ordner ein: git commit -m \"Initiales Commit. A.java und B.java jeweils leer.\" es erscheint die Ausgabe: [ master ( Root-Commit ) 8236e8a ] Initiales Commit. A.java und B.java jeweils leer. 3 files changed, 8 insertions ( + ) create mode 100644 .gitignore create mode 100644 Projekt1/src/A.java create mode 100644 Projekt1/src/B.java Unser erstes Commit (das sogenannte Root-Commit ) wurde erstellt. Wir haben jetzt einen \"gespeicherten\" Ausgangszustand, zu dem wir immer wieder zur\u00fccksetzen k\u00f6nnten. Unser \"Entwicklungsstrang\" nennt sich Branch . Der Hauptstrang , an dem wir versuchen, alle Entwicklungen immer ordentlich zusammenzuf\u00fchren, nennt sich master -Branch. Das letzte Commit ist stets der HEAD . Derzeit ist unser HEAD also dieses initiale Commit. Die Begriffe sind in der folgenden Abbildung dargestellt: Wir \u00e4ndern nun mal die Datei Projekt1/src/A.java und f\u00fcgen dort einfach ein Zeilenkommentar // Zeile 1 hinzugefuegt // hinzu. Wenn wir nun git status aufrufen, erscheint Auf Branch master \u00c4nderungen, die nicht zum Commit vorgemerkt sind: ( benutzen Sie \"git add <Datei>...\" , um die \u00c4nderungen zum Commit vorzumerken ) ( benutzen Sie \"git restore <Datei>...\" , um die \u00c4nderungen im Arbeitsverzeichnis zu verwerfen ) ge\u00e4ndert: Projekt1/src/A.java keine \u00c4nderungen zum Commit vorgemerkt ( benutzen Sie \"git add\" und/oder \"git commit -a\" ) Wir k\u00f6nnen diese \u00c4nderung nun committen, indem wir die Option -a verwenden (oder zuvor git add Projekt1/src/A.java ): git commit -am \"in A.java Zeile 1 hinzugefuegt\" Wir erhalten die Ausgabe: [ master 44ed3a8 ] in A.java Zeile 1 hinzugefuegt 1 file changed, 2 insertions ( + ) Wir haben jetzt einen neuen HEAD , nicht mehr das Root-Commit mit der \"Nummer\" 8236e8a , sondern nun dieses zweite Commit mit der \"Nummer\" 44ed3a8 . Diese Nummern sind Hash-Werte. Tats\u00e4chlich sind diese Hash-Werte sogar l\u00e4nger. Wir k\u00f6nnen Sie uns mit git log anzeigen lassen. git log und git show \u00b6 Mit git log k\u00f6nnen Sie sich alle Ihre Commits auflisten lassen. In unserem jetzigen Zustand erzeugt git log folgende Ausgabe: commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd ( HEAD -> master ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 18 :13:48 2021 +0200 in A.java Zeile 1 hinzugefuegt commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Wenn Ihnen diese Ansicht zu un\u00fcbersichtlich ist, k\u00f6nnen Sie die Option --oneline verwenden: git log --oneline erzeugt: 44ed3a8 ( HEAD -> master ) in A.java Zeile 1 hinzugefuegt 8236e8a Initiales Commit. A.java und B.java jeweils leer. git branch und git ckeckout - Branches in Git \u00b6 Unser Repository sieht derzeit so aus: Angenommen, wir wollen etwas ausprobieren und unabh\u00e4ngig von dem Hauptentwicklungsstrang (dem master -Branch) z.B. an Projekt1/src/B.java arbeiten, ohne aber den bisherigen Stand zu \"gef\u00e4rden\". Dazu gibt es die M\u00f6glichkeit, neue, eigene Branches zu erstellen. Diese gehen von einem Commit des master -Branches aus und k\u00f6nnen sp\u00e4ter auch wieder auf den master -Branch f\u00fchren (oder, falls unser Ausprobieren doch nicht erfolgreich war, auch nicht). Einen neuen Branch erstellen wir mit git branch <nameDesNeuenBranches> . Wir erstellen uns einen Branch tryB : git branch tryB Dabei passiert erstmal noch gar nichts. Es wird nur ein Link auf das letzte Commit (den HEAD ) erzeugt und dieser Link hei\u00dft tryB . Wenn wir jetzt einfach erstmal an Projekt1/src/A.java weiterarbeiten w\u00fcrden und die \u00c4nderungen committen, stellen wir fest, dass wir tats\u00e4chlich am master -Branch weiterarbeiten. Um das zu zeigen, \u00e4ndern wir die Datei Projekt1/src/A.java und f\u00fcgen einen weiteren Zeilenkommentar hinzu. // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // Wir wissen bereits, wie wir diese \u00c4nderung committen: git commit -am \"in A.java Zeile 2 hinzugefuegt\" git log ergibt: commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde ( HEAD -> master ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sat Apr 3 09 :09:54 2021 +0200 in A.java Zeile 2 hinzugefuegt commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd ( tryB ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 18 :13:48 2021 +0200 in A.java Zeile 1 hinzugefuegt commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Das zeigt uns, dass wir am master -Branch weitergearbeitet haben und dass HEAD auf den master -Branch zeigt. Wir sehen aber auch, dass wir auf dem zweiten Commit einen Link tryB haben. Wir wollen jetzt aber auf diesem tryB -Branch arbeiten und nutzen dazu den Befehl git checkout <branch> : git checkout tryB Damit haben wir 2 Sachen getan: arbeiten wir jetzt auf einem anderen Branch, als dem master -Branch, n\u00e4mlich dem tryB -Branch und setzen wir auf den Zustand auf, den wir mit dem Commit gespeichert hatten ( 44ed3a8 ), auf den tryB zeigt. Den 2. Punkt k\u00f6nnen wir \u00fcberpr\u00fcfen, indem wir uns die Datei Projekt1/src/A.java anschauen. Die sieht n\u00e4mlich jetzt (wieder) so aus: // Zeile 1 hinzugefuegt // Wir f\u00fcgen nun das Gleiche in die Projekt1/src/B.java ein: // Zeile 1 hinzugefuegt // und committen diese \u00c4nderung: git commit -am \"in B.java Zeile 1 hinzugefuegt\" Die Commits lassen wir uns zun\u00e4chst mit git log anzeigen: commit e754d18f0d8cb1e8593edca740fa75b84d5de30f ( HEAD -> tryB ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sat Apr 3 09 :56:28 2021 +0200 in B.java Zeile 1 hinzugefuegt commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 18 :13:48 2021 +0200 in A.java Zeile 1 hinzugefuegt commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Wir sehen, dass alle Commits aufgelistet werden, die bis zum aktuellen HEAD f\u00fchren. Es fehlt aber beispielsweise das Commit, das bereits f\u00fcr den master -Branch ausgef\u00fchrt wurde und in dem in Projekt1/src/A.java bereits Zeile 2 hinzugefuegt wurde. Um sich alle Commits auszugeben und sogar eine Graph-\u00e4hnliche Darstellung zu erhalten, verwenden wir git log --all --graph Wir erhalten folgende Ausgabe: * commit e754d18f0d8cb1e8593edca740fa75b84d5de30f ( HEAD -> tryB ) | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :56:28 2021 +0200 | | in B.java Zeile 1 hinzugefuegt | | * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde ( master ) | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :09:54 2021 +0200 | | in A.java Zeile 2 hinzugefuegt | * commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Fri Apr 2 18 :13:48 2021 +0200 | | in A.java Zeile 1 hinzugefuegt | * commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. und daraus erkennt man, dass unser Repository (die Commit-Hostorie) derzeit so aussieht: git merge - Branches zusammenf\u00fchren \u00b6 Wir haben folgende Situation: ausgehend von Commit 44ed3a8 ( in A.java Zeile 1 hinzugefuegt ) haben wir auf dem master -Branch weitergearbeitet und dort ein Commit 9c869b6 ( in A.java Zeile 2 hinzugefuegt ) erstellt und parallel dazu auf dem tryB -Branch gearbeitet und dort ein Commit e754d18 ( in B.java Zeile 1 hinzugefuegt ) erstellt. Nun wollen wir beide Branches wieder zusammenf\u00fchren, um mit beiden \u00c4nderungen weiterzuarbeiten. Das Zusammenf\u00fchren von Branches erfolgt mithilfe von git merge <branchToMerge> . Wir wollen gerne den tryB -Branch in den master -Branch mergen , um dann mit dem master -Branch weiterzuarbeiten. Dazu wechseln wir zun\u00e4chst in den master -Branch. das erreichen wir, indem wir checkout verwenden: git checkout master Die Ausgabe ist Zu Branch 'master' gewechselt Nun mergen wir diesen mit dem tryB -Branch, indem wir git merge tryB eingeben. Wichtig ist, dass es sich hierbei auch um ein erzwungenes Commit (sogenanntes Merge-Commit ) handelt, da beide Branches eigene Commits enthielten. Es wird uns eine Commit-nachricht angeboten. Mit ZZ verlassen wir den vi . Wenn wir uns nun die Commit-Logs ausgeben lassen ( git log --all --graph ), dann erhalten wir folgende Ausgabe * commit 7ffabf8646580d6bb2ba289de93e6fe20b894084 ( HEAD -> master, tryB ) | \\ Merge: e754d18 9c869b6 | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 16 :21:12 2021 +0200 | | | | Merge branch 'master' into tryB | | | * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 09 :09:54 2021 +0200 | | | | in A.java Zeile 2 hinzugefuegt | | * | commit e754d18f0d8cb1e8593edca740fa75b84d5de30f | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :56:28 2021 +0200 | | in B.java Zeile 1 hinzugefuegt | * commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Fri Apr 2 18 :13:48 2021 +0200 | | in A.java Zeile 1 hinzugefuegt | * commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. und erkennen, dass die beiden Branches nun wieder \"vereint\" sind: Wenn wir uns A.java anschauen, dann sehen wir, dass diese Datei 2 Zeilen enth\u00e4lt und die Datei B.java eine. Beide sind also auf dem aktuellsten Stand. Wir \u00fcben Mergen an dieser Stelle nochmal und bilden 2 Branches, in dem einen erstellen wir uns eine \"Klasse\" C.java und in dem anderen eine D.java : git branch classC git branch classD git checkout classC touch Projekt1/src/C.java echo \"// Zeile 1 hinzugefuegt\" >> Projekt1/src/C.java git add Projekt1/src/C.java git commit -m \"in C.java Zeile 1 hinzugefuegt\" git checkout classD touch Projekt1/src/C.java echo \"// Zeile 1 hinzugefuegt\" >> Projekt1/src/D.java git add Projekt1/src/D.java git commit -m \"in D.java Zeile 1 hinzugefuegt\" git checkout master git merge classC Hierbei handelt es sich um ein sogenanntes Fast-Forward-Commit , da der master -Branch keine eigenen \u00c4nderungen enthielt, sondern nur die \u00c4nderungen des classC -Branches in den master -Branch eingef\u00fcgt werden m\u00fcssen. Es gibt hier keine potenziellen Konflikte. Wenn wir nun aber auch den classD -Branch in den master -Branch mergen wollen, enth\u00e4lt sowohl der master -Branch \u00c4nderungen ( C.java ) als auch der classD -Branch ( D.java ). Hierbei handelt es sich also um ein Merge-Commit : git merge classD vi \u00f6ffnet und wir k\u00f6nnen die Commit-Message \u00e4ndern oder sie so lassen. Wir beenden den vi wieder mit ZZ . git log --all --graph zeigt: * commit 15d5e0b00f2a4af5eaa4d84ba55e340f912ccb42 ( HEAD -> master ) | \\ Merge: 0d86294 01f8dfd | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 17 :12:18 2021 +0200 | | | | Merge branch 'classD' | | | * commit 01f8dfd9c68148c984db99dec980d227f1fe4044 ( classD ) | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 17 :05:46 2021 +0200 | | | | in D.java Zeile 1 hinzugefuegt | | * | commit 0d8629458ca0a5e244c121be525f8e647b5c6bd9 ( classC ) | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 16 :51:14 2021 +0200 | | in C.java Zeile 1 hinzugefuegt | * commit 7ffabf8646580d6bb2ba289de93e6fe20b894084 ( tryB ) | \\ Merge: e754d18 9c869b6 | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 16 :21:12 2021 +0200 | | | | Merge branch 'master' into tryB | | | * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 09 :09:54 2021 +0200 | | | | in A.java Zeile 2 hinzugefuegt | | * | commit e754d18f0d8cb1e8593edca740fa75b84d5de30f | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :56:28 2021 +0200 | | in B.java Zeile 1 hinzugefuegt | * commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Fri Apr 2 18 :13:48 2021 +0200 | | in A.java Zeile 1 hinzugefuegt | * commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Die Commit-Historie unseres Repositories sieht so aus: Eine umfangreiche Beschreibung aller \u00c4nderungen in den jeweiligen Commits erhalten Sie auch durch den Befehl git show --pretty=fuller --abbrev-commit . Konflikte aufl\u00f6sen \u00b6 Gerade bei der Arbeit im Team kann es passieren, dass in verschiedenen Branches an der gleichen Datei \u00c4nderungen durchgef\u00fchrt werden. Wenn diese Branches dann \"gemerged\" werden sollen, kann Git diesen Konflikt nicht alleine aufl\u00f6sen (soll \u00c4nderung A gelten oder \u00c4nderung B oder beide?). Die Aufl\u00f6sung eines solchen Konfliktes muss durch die Entwicklerinnen geschehen. Zur Demonstration erzeugen wir uns erneut zwei Branches, changeA1 und changeA2 und f\u00fchren in beiden Branches eine \u00c4nderung an Projekt1/src/A.java durch: git branch changeA1 git branch changeA2 git checkout changeA1 echo \"// eine \u00c4nderung durch Entwicklerin A\" >> Projekt1/src/A.java git commit -am \"in A eine \u00c4nderung durch Entwicklerin A\" git checkout changeA2 echo \"// eine \u00c4nderung durch Entwicklerin B\" >> Projekt1/src/A.java git commit -am \"in A eine \u00c4nderung durch Entwicklerin B\" Wenn wir jetzt versuchen, die beiden Branches mit git merge changeA1 zu mergen, dann erhalten wir folgende Ausgabe: automatischer Merge von Projekt1/src/A.java KONFLIKT ( Inhalt ) : Merge-Konflikt in Projekt1/src/A.java Automatischer Merge fehlgeschlagen ; beheben Sie die Konflikte und committen Sie dann das Ergebnis. Git kann diesen Konflikt nicht automatisch aufl\u00f6sen. Die Ausgabe von git status hilft dabei nicht wirklich weiter: Auf Branch changeA2 Sie haben nicht zusammengef\u00fchrte Pfade. ( beheben Sie die Konflikte und f\u00fchren Sie \"git commit\" aus ) ( benutzen Sie \"git merge --abort\" , um den Merge abzubrechen ) Nicht zusammengef\u00fchrte Pfade: ( benutzen Sie \"git add/rm <Datei>...\" , um die Aufl\u00f6sung zu markieren ) von beiden ge\u00e4ndert: Projekt1/src/A.java keine \u00c4nderungen zum Commit vorgemerkt ( benutzen Sie \"git add\" und/oder \"git commit -a\" ) Mit git log --merge k\u00f6nnen wir uns die Commits anschauen, die die \u00c4nderungen enthalten, welche f\u00fcr den Konflikt sorgen: commit da1f715199e68f17ea276b07a9c3a6e88b319e8a ( HEAD -> changeA2 ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sun Apr 4 08 :08:13 2021 +0200 in A eine \u00c4nderung durch Entwicklerin B commit 63a9a40ab267bc53f2a688a45e6813d7c15170c6 ( changeA1 ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sun Apr 4 08 :07:25 2021 +0200 in A eine \u00c4nderung durch Entwicklerin A Der Befehl git diff zeigt uns den Konflikt ganz konkret an: diff --cc Projekt1/src/A.java index a5c84c3,a920d29..0000000 --- a/Projekt1/src/A.java +++ b/Projekt1/src/A.java @@@ -1,4 -1,4 +1,8 @@@ // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // ++ <<<<<< < HEAD +// eine \u00c4nderung durch Entwicklerin B ++ ======= + // eine \u00c4nderung durch Entwicklerin A ++>>>>>>> changeA1 Diese Darstellung in der Datei finden wir auch wieder, wenn wir uns die Datei Projekt1/src/A.java anschauen: // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // <<<<<< < HEAD // eine \u00c4nderung durch Entwicklerin B ======= // eine \u00c4nderung durch Entwicklerin A >>>>>>> changeA1 In unserer Konflikt-Datei gibt es folgende drei Eintr\u00e4ge: <<<<<<< HEAD ======= >>>>>>> changeA1 Aller Inhalt zwischen den ersten beiden Zeilen enth\u00e4lt die \u00c4nderungen des aktuellen Branches und alle \u00c4nderungen zwischen den letzten beiden Zeilen enth\u00e4lt alle \u00c4nderungen des Branches, in den gemerged werden soll ( changeA1 ). Entwicklungsumgebungen (IntelliJ, Eclipse, Atom, Visual Studio Code usw.) unterst\u00fctzen bei der Aufl\u00f6sung solcher Konflikte. Wir \u00fcbernehmen einfach beide \u00c4nderungen h\u00e4ndisch und committen diese \u00c4nderung. Projekt1/src/A.java sieht also jetzt so aus: // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // // eine \u00c4nderung durch Entwicklerin B // eine \u00c4nderung durch Entwicklerin A und der Commit: git commit -am \"Merge-Konflikt in A.java geloest. Aenderungen A UND B eingefuegt\" . Merge abbrechen \u00b6 Sollten Sie aufgrund der Konfliktmeldung den Merge-Vorgang doch nicht durchf\u00fchren wollen, k\u00f6nnen Sie mit git merge --abort den Merge abbrechen und mit git reset die in Konflikt stehenden Dateien auf einen als funktionierend bekannten Zustand zur\u00fcckzusetzen. git stash - Arbeit unterbrechen \u00b6 Angenommen, Sie haben bereits \u00c4nderungen durchgef\u00fchrt, diese sind aber noch nicht \"fertig\" und Sie wollen Sie deshalb noch nicht committen. Stattdessen m\u00fcssen Sie aber an anderer Stelle zun\u00e4chst noch einen BugFix erledigen. Dann k\u00f6nnen Sie Ihre gegenw\u00e4rtigen \u00c4nderungen \"stashen\" - in einen Stash-Modus setzen, also erstmal verstauen , um daran sp\u00e4ter weiterzuarbeiten: git stash Jetzt k\u00f6nnen Sie erstmal andere \u00c4nderungen durchf\u00fchren und committen und um dann wieder zu Ihren urspr\u00fcnglichen \u00c4nderungen zur\u00fcckzukehren, holen Sie diese wieder aus dem Stash-Modus: git stash pop Einige weitere n\u00fctzliche Befehle \u00b6 Angenommen, Sie haben committed, aber einige \u00c4nderungen vergessen (entweder vorher nicht geadded oder noch gar nicht ge\u00e4ndert), dann k\u00f6nnen Sie den vorherigen Commit \"\u00fcberschreiben\". git commit -m \"zu frueh committed\" // jetzt noch die Aenderungen hinzufuegen git commit --amend Angenommen, Sie haben seit dem letzten Commit \u00c4nderungen an Dateien vorgenommen, die Sie aber gerne verwerfen m\u00f6chten. Sie werden in der Literatur daf\u00fcr Befehle finden, wie z.B. git checkout HEAD oder git reset --hard . Sie sollten damit \u00e4u\u00dferst vorsichtig sein! Bei git checkout HEAD (aslo dem \"Zur\u00fccksetzen\" auf das letzte Commit) bleiben die ge\u00e4nderten Dateien \"modifiziert\". Das hilft also gar nicht wirklich. git reset --hard kann Sie unter Umst\u00e4nden auf ein Commit zur\u00fccksetzen, das noch weiter zur\u00fcck in der Historie liegt, als Sie planen. Verwenden Sie zum Zur\u00fccksetzen Ihrer \u00c4nderungen (Undo) besser git restore <dateiUndo> Geben Sie also die Datei an, die Sie ge\u00e4ndert haben und die wieder auf den Zustand des letzten Commits zur\u00fcckgesetzt werden soll. L\u00f6schen Sie niemals einfach Dateien oder Ordner in dem durch Git verwalteten Ordner (Ihrem Repository) \u00fcber den Finder oder den Dateiexplorer! Die Idee von Git ist die, dass immer nur etwas hinzukommt. Selbst, wenn Sie eine bestimmte Datei nicht mehr ben\u00f6tigen, so kann es ja doch sein, dass diese in fr\u00fcheren Versionen vorkommt. Lassen Sie sie einfach im Verzeichnis! Aliases \u00b6 Es ist ganz hilfreich, sich f\u00fcr einige Optionen Aliase zu definieren, da diese oft verwendet werden. Dazu nutzen Sie git config . Hier einige Beispiele von n\u00fctzlichen Aliases (aus dem Git-Buch ): git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status Git als Kollaborationswerkzeug \u00b6 Im vorherigen Abschnitt haben wir diskutiert, wie wir Git zur Versionsverwaltung verwenden k\u00f6nnen. Dazu haben wir ein lokales Git-Repository angelegt. Nun wollen wir betrachten, wie Git als Kollaborationswerkzeug eingesetzt werden kann, d.h. wie mehere Entwicklerinnen zusammen an einem (globalen) Git-Repository arbeiten k\u00f6nnen. Dazu ben\u00f6tigen wir einen Host (Bereitsteller netzbasierter Dienste), der ein zentrales Git-Repository zur Verf\u00fcgung stellen kann. Es gibt mehrere solcher Git-Hosts. Die bekanntesten sind: GitHub GitLab Bibucket Wir zeigen das Verwenden eines zentralen Repositories exemplarisch f\u00fcr GitHub . Sie m\u00fcssen sich in GitHub registrieren . Die Verwendung von GitHub ist kostenlos . Die Idee eines zentralen Repositorys ist die, dass daran mehrere lokale Repositories angebunden sein k\u00f6nnen: \u00dcber das zentrale Repository werden alle lokalen Repositories synchronisiert, so dass alle Repositories \u00fcber den gleichen Stand, d.h. alle Dateien und Ordner sowie die gleiche Commit-Historie verf\u00fcgen. Wichtig ist jedoch, dass man zum Entwickeln nicht permanent online sein muss. Vielmehr kann man beliebig lange offline auf dem eigenen lokalen Repository arbeiten, bis man irgendwann seine \u00c4nderungen in das zentrale Repository schreiben ( push ) bzw. dort abgelegte \u00c4nderungen aus anderen lokalen Repositories lesen ( pull ) m\u00f6chte. Ein zentrales Repository anlegen \u00b6 Sie loggen sich in GitHub (oder dem von Ihnen gew\u00e4hlten Diensteanbieter) ein und klicken auf \"New\": Dann geben Sie einen sprechenden Namen f\u00fcr das Repository ein. Sie k\u00f6nnen w\u00e4hlen, ob das Repository Public (f\u00fcr alle lesbar) oder Private (nur f\u00fcr Eingeladene lesbar) sein soll. Die darunter stehenden Checkboxen sollten Sie nicht anklicken, da Sie ein bereits existierendes lokales Repository mit diesem zentralen Repository verbinden wollen. In Ihrem lokalen Repository haben Sie ja wahrscheinlich bereits eine .gitignore -Datei. W\u00fcrden Sie diese Checkboxen markieren, m\u00fcssten Sie bereits ganz am Anfang mergen . Klicken Sie auf den Button Create repository . Das zentrale Repository ist nun erstellt. Nun m\u00fcssen wir nur noch vorgehen, wie auf der Seite angegeben: Im Terminal f\u00fchren wir im workspace -Ordner (in unserem lokalen Repository - der Ordner, der den .git -Ordner enth\u00e4lt) den Befehl git remote add origin https://github.com/jfreiheit/einfuehrung-git.git aus. https://github.com/jfreiheit/einfuehrung-git.git entspricht dabei der sogenannten Remote-URL und lautet bei Ihnen nat\u00fcrlich anders. Es ist der Pfad (die URL) zu Ihrem zentralen Git-Repository. Mit diesem Befehl verbinden wir unser lokales Git-Repository mit dem zentralen Git-Repository. Wir geben dem zentralen Git-Repository dabei den Namen origin . Den n\u00e4chsten von GitHub vorgeschlagenen Befehl git branch -M main k\u00f6nnen wir ebenfalls ausf\u00fchren. Wir wissen bereits, dass wir damit einen neuen Branch erstellen, n\u00e4mlich main . Wir verlassen also den master -Branch und wechseln zu einem neuen main -Branch. Das kann man machen, muss man aber nicht. Die Option -M steht f\u00fcr --move --force . Damit bestimmen wir, dass wir einen main -Branch erstellen, selbst wenn dieser bereits existierte. Siehe auch die Dokumentation f\u00fcr git branch . Der dritte von GitHub vorgeschlagene Befehl git push -u origin main bewirkt, dass unser komplettes lokales Git-Repository auf das zentrale Git-Repository gespielt wird. Das hei\u00dft, der aktuelle Branch main wird auf das zentrale Git-Repository origin gepushed . Nach Ausf\u00fchrung dieses Befehls ist das zentrale Repository auf dem selben Stand wie das lokale Repository. Alltag mit Git \u00b6 Ihr lokales Repository ist nun mit dem zentralen Repository verkn\u00fcpft. Wenn Sie jetzt \u00c4nderungen an Ihrem Code (Ihrem lokalen Repository) durchf\u00fchren und diese \u00c4nderungen auf dem zentralen Repository speichern wollen, sieht Ihr \"Alltag\" wie folgt aus. git add - eine neue Datei hinzuf\u00fcgen \u00b6 Angenommen, Sie erstellen eine neue Klasse (Datei), z.B. Projekt1/src/E.java , dann f\u00fcgen Sie diese neue Datei mit git add <neueDatei> Ihrem lokalen Repository hinzu: git add Projekt1/src/E.java Wenn Sie sich dann mit git status den Status des Repositorys anschauen, erhalten Sie Auf Branch main Ihr Branch ist auf demselben Stand wie 'origin/main' . Zum Commit vorgemerkte \u00c4nderungen: ( benutzen Sie \"git restore --staged <Datei>...\" zum Entfernen aus der Staging-Area ) neue Datei: Projekt1/src/E.java Neue Dateien f\u00fcgen Sie mittels git add <neueDatei> dem Repository hinzu. git commit - \u00c4nderungen \"speichern\" \u00b6 Angenommen, Sie haben \u00c4nderungen an Dateien hinzugef\u00fcgt, diese Dateien sind aber bereits Teil des Repositorys (wurden also bereits bei Erstellung mit git add hinzugef\u00fcgt). Dann speichern Sie diese \u00c4nderungen mit git commit -am \"Commit-Message\" . Angenommen, wir haben in Projekt1/src/E.java 2 Zeilen hinzugef\u00fcgt, dann committen wir diese \u00c4nderungen z.B. mit git commit -am \"in E.java 2 Zeilen hinzugefuegt\" Die Option -m steht daf\u00fcr, dass wir gleich die Commit-Message mit angeben. Fehlt diese Option, \u00f6ffnet sich ein vi und wir f\u00fcgen die Commit-Message nachtr\u00e4glich hinzu. Den vi verlassen wir mit ZZ . Die Option -a steht f\u00fcr add . Jede \u00c4nderung muss zun\u00e4chst hinzugef\u00fcgt werden. H\u00e4ufig sieht man daf\u00fcr die Verwendung des Befehls git add . . Das l\u00e4sst sich aber mit der Option -a auch beim Commit selbst erledigen. Wenn Sie sich dann mit git status den Status des Repositorys anschauen, erhalten Sie Auf Branch main Ihr Branch ist 1 Commit vor 'origin/main' . ( benutzen Sie \"git push\" , um lokale Commits zu publizieren ) nichts zu committen, Arbeitsverzeichnis unver\u00e4ndert \u00c4nderungen am Code (Repository) \"committen\" (speichern) Sie mittels git commit -am \"Commit-Message\" . git push - \u00c4nderungen auf das zentrale Repository spielen \u00b6 Sie k\u00f6nnen beliebig lange und oft Ihr lokales Repository \u00e4ndern, wie im Abschnitt Git als Versionierungswerkzeug beschrieben. Wenn Sie Ihr lokales Repository auf Ihr zentrales Repository spielen m\u00f6chten, verwenden Sie den Befehl git push . Damit stellen Sie das zentrale Repository auf den Stand Ihres lokalen Repositorys. git push ergibt folgende Ausgabe: Objekte aufz\u00e4hlen: 8 , fertig. Z\u00e4hle Objekte: 100 % ( 8 /8 ) , fertig. Delta-Kompression verwendet bis zu 8 Threads. Komprimiere Objekte: 100 % ( 3 /3 ) , fertig. Schreibe Objekte: 100 % ( 5 /5 ) , 439 Bytes | 439 .00 KiB/s, fertig. Gesamt 5 ( Delta 1 ) , Wiederverwendet 0 ( Delta 0 ) , Pack wiederverwendet 0 remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To https://github.com/jfreiheit/einfuehrung-git.git 15d5e0b..6ddd0dc main -> main Damit \u00fcbernimmt das zentrale Repository den Stand des lokalen Repositorys. Um das zentrale Repository auf den Stand Ihres lokalen Repositorys zu bringen, verwenden Sie git push . Das hei\u00dft, wenn Sie alleine an Ihrem zenztralen Repository arbeiten, m\u00fcssen sie sich nur folgende Befehle merken: git add <datei> // falls die Datei neu erstellt wurde und Ihrem Repository bekannt gemacht (hinzugef\u00fcgt) werden soll git commit -am \"Commit-Message\" // um die \u00c4nderungen ins lokale Repository zu \"speichern\" git push // um das zentrale Repository auf den Stand des lokalen Repositorys zu bringen So sieht einfach sieht der Alltag aus, wenn Sie alleine am (zentralen) Repository arbeiten. Ein existierendes zentrales Repository verwenden \u00b6 Angenommen, jemand anderer besitzt ein zentrales Repository und m\u00f6chte den Code mit Ihnen teilen - angenommen, ich m\u00f6chte mit Ihnen den Code aus meinem Repository https://github.com/jfreiheit/einfuehrung-git.git teilen. Sie k\u00f6nnen dieses Repository klonen (kopieren), indem sie einmalig git clone https://github.com/jfreiheit/einfuehrung-git.git eingeben. Dadurch erstellen Sie sich ein lokales Repository, das einer identischen Kopie (einem Clone) des zentralen Repositorys https://github.com/jfreiheit/einfuehrung-git.git entspricht. Dieses lokale Repository ist dann bereits auch mit dem zentralen Repository verbunden. Angenommen, ich f\u00fchre nun \u00c4nderungen an diesem zentralen Repository durch und somit einige Commits. Damit diese \u00c4nderungen auch Ihrem lokalen Repository bekannt werden, f\u00fchren Sie git pull aus. Damit \"holen\" Sie sich den aktuellen Stand des zentralen Repositories. git config \u00b6 Sollten Sie aufgefordert werden, einige Accountdetails in Ihrer Git-Konfiguration zu speichern, dann machen Sie das. Sie k\u00f6nnen diese Schritte selbst dann vornehmen, wenn Sie nicht dazu aufgefordert werden: git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" In den Strings geben Sie nat\u00fcrlich Ihre Daten an. Weitere Informationen zur Konfiguration von Git finden Sie auch hier . N\u00fctzliche Links zu Git \u00b6 Git Dokumentation Git Buch Lerne Git mit Bitbucket Cloud Git-Tutorial: Git und die wichtigsten Befehle kennenlernen Learn Git Branching Git - Der einfache Einstieg Git in Bildern Visualizing Git Concepts Git Kata noch mehr Git Katas EGit - Git mit Eclipse \u00b6 Mit EGit integrieren Sie Git in Eclipse. Sie k\u00f6nnen pr\u00fcfen, ob Sie EGit bereits in Eclipse installiert haben, indem Sie in Eclipse unter Help \u2192 Eclipse Marketplace den Reiter Installed anklicken und schauen, ob EGit in dieser Liste auftaucht. Wenn nicht, w\u00e4hlen Sie den Reiter Search und geben in die Suchleiste EGit ein und installieren das PlugIn. Sie k\u00f6nnen auch unter Help \u2192 Install new Software... diese URL eintragen, um EGit zu installieren: http://download.eclipse.org/egit/updates . Sie finden die Installationsanleitung auch unter https://www.eclipse.org/egit/ oder z.B. auch hier und hier . Beim Verbinden Ihres lokalen Repositories mit Eclipse k\u00f6nnen Sie z.B. vorgehen wie hier beschrieben oder hier .","title":"Git"},{"location":"git/#git","text":"Git ist ein Versionierungswerkzeug f\u00fcr die Softwareentwicklung. Mit Git k\u00f6nnen Sie Ihre Software versionieren, d.h. Versionen Ihrer Software erstellen und zwischen diesen Versionen hin- und herwecheseln sowie im Team gemeinsam an einem Softwareprojekt arbeiten und die einzelnen Entwicklungen aller Teammitglieder geeignet zusammenf\u00fchren. Git ist Open Source und frei verf\u00fcgbar . Entstanden ist Git im Rahmen der Entwicklung von Linux , initiiert durch Linus Torvalds , dem Initiator von Linux.","title":"Git"},{"location":"git/#installation-von-git","text":"Um Git verwenden zu k\u00f6nnen, m\u00fcssen Sie es zun\u00e4chst installieren. Laden Sie sich Git f\u00fcr Ihr Betriebssystem von der Download-Seite herunter bzw. gehen Sie so vor, wie f\u00fcr Ihr Betriebssystenm beschrieben. Installationshilfen erhalten Sie z.B. auch im frei verf\u00fcgbaren Git-Buch unter Git installieren oder auch im Video \u00fcber die ersten Schritte mit Git. Wenn Sie unter Windows arbeiten, dann erhalten Sie mit Git eine GitBash . Wenn wir von nun an vom Terminal (oder Shell oder Bash ) sprechen, dann verwenden Sie bitte immer diese GitBash . Nach erfolgreicher Installation k\u00f6nnen Sie im Terminal den Befehl git --version eingeben und es sollte eine Ausgabe, wie git version 2 .30.1 oder eine aktuellere Versionsnummer erfolgen. Wir k\u00f6nnen Git nun verwenden und betrachten zun\u00e4chst, wie Git als Versionierungswerkzeug verwendet werden kann und schauen uns danach an, wie es als Kollaborationswerkzeug verwendet wird.","title":"Installation von Git"},{"location":"git/#git-als-versionierungswerkzeug","text":"Die grunds\u00e4tzliche Idee von Git ist, \u00c4nderungen an Dateien und Ordnern so zu speichern, dass alle diese \u00c4nderungen nachverfolgbar sind. Git erzeugt sogenannte Snapshots aller Dateien und Ordner und speichert diese Snapshots nacheinander lokal ab. D.h. alles passiert bei Ihnen lokal auf dem Rechner, Sie ben\u00f6tigen keine Verbindung zu einem Server. Wenn Sie sp\u00e4ter im Team zu Mehreren an einem Projekt arbeiten, dann gleichen Sie immer nur die Historien Ihrer Snapshots ab. Git f\u00fcgt immer nur hinzu und das ist auch korrekt so. Selbst, wenn in sp\u00e4teren Versionen Ihres eine Datei nicht mehr existiert, die in fr\u00fcheren Versionen des Projektes noch existierte, soll diese Datei gar nicht gel\u00f6scht werden, denn es k\u00f6nnte ja sein, dass Sie irgendwann nochmal die fr\u00fchere Version anschauen wollen, die die Datei enthielt. Dieses Skript hier z.B. verwalte ich mit Git. Das bedeutet, dass alle Dateien eines Ordners (und Unterordnern) in einem sogenannten Git-Repository (oder nur Repository ) verwaltet werden. F\u00fcr dieses Skript hier k\u00f6nnte das z.B. so aussehen: Das hei\u00dft, ich erstelle zun\u00e4chst 3 Dateien: Einf\u00fchrung , Wiederholung und Git und \"sage\" Git, dass dies Version1 sein soll. Danach f\u00fcge ich 3 weitere Dateien hinzu Aufgaben , \u00dcbungen und Wrapperklassen und zusammen mit den vorherigen 3 Dateien aus Version 1 ergibt das dann Version 2 . Danach \u00e4ndere ich (f\u00fcge hinzu) die Dateien Aufgaben und \u00fcbungen und f\u00fcge au\u00dferdem neue Dateien f\u00fcr Exceptions und JUnit hinzu und \"sage\", dass das insgesamt Version 3 ergibt usw. Git verwaltet nun diese Versionen und der Vorteil ist, dass ich jede dieser Versionen separat zur Verf\u00fcgung stellen k\u00f6nnte und auch auf diesen Versionen weiterarbeiten. Wir werden in Zukunft in Bezug auf Git aber nicht mehr unbedingt von Versionen sprechen, sondern von Snapshots . Wir schauen uns das nun in einem Besipiel an.","title":"Git als Versionierungswerkzeug"},{"location":"git/#git-init-ein-repository-erstellen","text":"Angenommen, wir haben in unserem workspace folgende Ordner-Struktur: In dem workspace gibt es ein Projekt Projekt1 und darin einen src -Ordner mit unseren *.java -Dateien und einen bin -Ordner mit unseren *.class -Dateien. Wir lassen f\u00fcr dieses einf\u00fchrende Beispiel einmal Pakete weg. Diese w\u00fcrden ja als Ordner-Struktur sowohl innerhalb von src als auch von bin auftauchen. So sieht also ein typischer workspace aus. Es gibt darin noch weitere Ordner und Dateien, wie z.B. .idea , .metadata , .classpath , .project , .settings , die von unseren Entwicklungsumgebungen (Eclipse, IntelliJ, ...) angelegt wurden. Wir wollen nun unseren workspace von Git verwalten lassen. Dazu wechseln wir im Terminal in den workspace -Ordner und f\u00fchren dort das Kommando git init aus. Dieses Kommando erstellt das Git-Repository . Es muss genau einmal, n\u00e4mlich ganz am Anfang zur Erstellung des Repositorys ausgef\u00fchrt werden. Im Terminal erscheint Hinweis: Als Name f\u00fcr den initialen Branch wurde 'master' benutzt. Dieser Hinweis: Standard-Branchname kann sich \u00e4ndern. Um den Namen des initialen Branches Hinweis: zu konfigurieren, der in allen neuen Repositories verwendet werden soll und Hinweis: um diese Warnung zu unterdr\u00fccken, f\u00fchren Sie aus: Hinweis: Hinweis: git config --global init.defaultBranch <Name> Hinweis: Hinweis: H\u00e4ufig gew\u00e4hlte Namen statt 'master' sind 'main' , 'trunk' und Hinweis: 'development' . Der gerade erstellte Branch kann mit diesem Befehl Hinweis: umbenannt werden: Hinweis: Hinweis: git branch -m <Name> Leeres Git-Repository in /...IhrPfadZumWorkspaceOrdner.../workspace/.git/ initialisiert Somit wurde ein Git-Repository erstellt. Der workspace -Ordner wird nun von Git verwaltet. Dies erkennen Sie daran, dass in dem workspace -Ordner ein .git -Ordner angelegt wurde: Klicken Sie ruhig mal in den Ordner, um zu sehen, was da alles drin ist.","title":"git init - ein Repository erstellen"},{"location":"git/#gitignore-dateien-aus-der-verwaltung-ausschlieen","text":"Git w\u00fcrde nun den gesamten workspace -Ordner verwalten. Das w\u00e4re zun\u00e4chst auch gar kein Problem. Aber wenn Sie im Team zu mehreren am selben Projekt (workspace) arbeiten, dann wollen Sie bestimmte Dateien gar nicht untereinander austauschen, z.B. alle Dateien, die von Ihrer IDE erstellt wurden (z.B. .idea , .metadata , .classpath , .project , .settings ). Auch alle Dateien im bin -Ordner m\u00fcssen nicht von Git verwaltet werden, weil Sie ja stets neu durch das Compilieren erzeugt werden. Noch bevor wir nun also unsere erste Version erzeugen wollen, schlie\u00dfen wir zun\u00e4chst einige Ordner und Dateien aus der Verwaltung von Git aus. Dazu wird im workspace -Ordner eine Datei .gitignore erstellt, in die wir alle Dateien und Ordner eintragen, die wir aus der Git-Verwaltung ausschlie\u00dfen wollen. Bevor wir das machen, geben wir im Terminal in unserem workspace -Ordner einmal den Befehl git status ein. Dies wird der am meisten verwendete Befehl f\u00fcr uns sein, der mit dem Befehl bekommen wir Auskunft \u00fcber den aktuellen Status des Repositorys. Die Ausgabe derzeit ist Auf Branch master Noch keine Commits Unversionierte Dateien: ( benutzen Sie \"git add <Datei>...\" , um die \u00c4nderungen zum Commit vorzumerken ) .DS_Store .idea/ .metadata/ Projekt1/ nichts zum Commit vorgemerkt, aber es gibt unversionierte Dateien ( benutzen Sie \"git add\" zum Versionieren ) Das m\u00fcssen wir zum jetzigen Zeitpunkt noch nicht alles verstehen, aber wir sehen, dass Git derzeit die Datei .DS_Store und die Ordner .idea/ , .metadata/ und Projekt1/ verwaltet und wir ja eigentlich nur die Verwaltung von Projekt1/ w\u00fcnschen (und darin auch nicht alles). Wir erstellen uns also im workspace -Ordner eine .gitignore -Datei und geben darin ein: .DS_Store .idea .metadata Projekt1/bin Projekt1/.classpath Projekt1/.project Projekt1/.settings Damit geben wir an, dass die Datei .DS_Store ignoriert werden soll (gibt es nur unter Mac - legt der Finder automatisch zur schnelleren Suche an) sowie die Ordner .idea und .metadata . H\u00e4tten wir .idea/ und .metadata/ geschrieben, w\u00fcrde der Ordner jeweils selbst mit in der Git-Verwaltung sein, jedoch der Kontent nicht. Ansonsten soll auch noch der Ordner Projekt1/bin aus der Git-Verwaltung entfernt werden und alle Dateien und Ordner, die mit einem Punkt beginnen und im Ordner Projekt1 liegen. Wenn man alle Dateien ignorieren m\u00f6chte, die mit einem Punkt beginnen, egal in welchem ordner, dann k\u00f6nnte man auch .* in die .gitignore schreiben. Dann w\u00fcrde allerdings auch die .gitignore selbst dazugeh\u00f6ren. Diese kann und sollte man aber ruhig mit in die Git-Verwaltung aufnehmen. Eine \u00dcbersicht \u00fcber m\u00f6gliche Eintr\u00e4ge in die .gitignore findet man z.B. hier oder hier . Wenn wir jetzt erneut git status eingeben, dann ist die Ausgabe: Auf Branch master Noch keine Commits Unversionierte Dateien: ( benutzen Sie \"git add <Datei>...\" , um die \u00c4nderungen zum Commit vorzumerken ) .gitignore Projekt1/ nichts zum Commit vorgemerkt, aber es gibt unversionierte Dateien ( benutzen Sie \"git add\" zum Versionieren ) D.h. wir sehen, dass die Dateien und Ordner .DS_Store , .idea/ und .metadata/ nun nicht mehr mit verwaltet werden, daf\u00fcr aber die .gitignore . Wir haben jetzt ein Git-Repoitory , aber es ist noch leer. Wir f\u00fcgen nun Dateien diesem Repository hinzu.","title":".gitignore - Dateien aus der Verwaltung ausschlie\u00dfen"},{"location":"git/#git-add-dem-repository-dateien-hinzufugen","text":"Wir haben noch keine Ordner und Dateien in unser Repository aufgenommen, d.h. es werden noch keine \u00c4nderungen an diesen Dateien durch Git verwaltet. Um Dateien dem Repository hinzuzuf\u00fcgen, verwenden wir das Kommando git add . Wir wollen den Ordner Projekt1 und die Datei .gitignore dem Repository hinzuf\u00fcgen, um sie von nun an von Git verwalten zu lassen (d.h. ihre \u00c4nderungen zu \"protokollieren\"). Wir geben im Terminal im workspace -Ordner ein: git add .gitignore git add Projekt1 und f\u00fcgen somit den gesamten Ordner Projekt1 (aber nicht die in der .gitignore definierten Dateien und Ordner aus dem Ordner Projekt1 ) und die .gitignore -Datei dem Repository hinzu. git status ergibt nun: Auf Branch master Noch keine Commits Zum Commit vorgemerkte \u00c4nderungen: ( benutzen Sie \"git rm --cached <Datei>...\" zum Entfernen aus der Staging-Area ) neue Datei: .gitignore neue Datei: Projekt1/src/A.java neue Datei: Projekt1/src/B.java D.h. von nun an werden von Git die Dateien .gitignore , Projekt1/src/A.java und Projekt1/src/B.java verwaltet. Die Dateien A.java und B.java sind jetzt noch leer. Wann immer wir eine neue Datei in unserem workspace erstellen und wir wollen, dass sie von Git verwaltet wird, f\u00fcgen wir diese Datei mit git add <datei> dem repository hinzu! Wann immer wir eine neue Datei in unserem workspace erstellen und wir nicht wollen, dass sie von Git verwaltet wird, f\u00fcgen wir diese Datei der .gitignore -Datei hinzu! Mit dem Befehl git add . werden einfach immer alle neuen Dateien hinzugef\u00fcgt. Wir werden diesen Befehl h\u00e4ufig nutzen, um nicht alle neuen Dateien einzeln aufzulisten. Es gibt f\u00fcr add auch die Option --all ( -A ), mit der alle Dateien aus einem Ordner hinzugef\u00fcgt werden.","title":"git add - dem Repository Dateien hinzuf\u00fcgen"},{"location":"git/#git-commit-einen-snapshot-erstellen","text":"Mit git commit \"speichern\" wir das gesamte Repository. Git merkt sich den Stand aller Dateien und Ordner und den Zeitpunkt des Commits. Zus\u00e4tzlich geben wir zum git commit noch eine Commit-Nachricht an, um den Stand der Arbeit zu beschreiben. In einem Snapshot werden alle \u00c4nderungen im Vergleich zum vorherigen Snapshot gespeichert. Man kann sich also die Versionierung mit Git wie eine Reihe von Commits (Snapshots) vorstellen: Ganz am Anfang ein initiales Commit ( C0 ), dann wurde weiter gearbeitet und ein weiteres Commit ( C1 ) gesetzt und so weiter ( C2 ). Es ist ohne Probleme m\u00f6glich, wieder zum Stand von C1 oder sogar C0 \"zur\u00fcckzuspringen\" (zeigen wir sp\u00e4ter, wie). Zun\u00e4chst erstellen wir unser initiales Commit. Dazu geben wir im Terminal im workspace -Ordner ein: git commit -m \"Initiales Commit. A.java und B.java jeweils leer.\" es erscheint die Ausgabe: [ master ( Root-Commit ) 8236e8a ] Initiales Commit. A.java und B.java jeweils leer. 3 files changed, 8 insertions ( + ) create mode 100644 .gitignore create mode 100644 Projekt1/src/A.java create mode 100644 Projekt1/src/B.java Unser erstes Commit (das sogenannte Root-Commit ) wurde erstellt. Wir haben jetzt einen \"gespeicherten\" Ausgangszustand, zu dem wir immer wieder zur\u00fccksetzen k\u00f6nnten. Unser \"Entwicklungsstrang\" nennt sich Branch . Der Hauptstrang , an dem wir versuchen, alle Entwicklungen immer ordentlich zusammenzuf\u00fchren, nennt sich master -Branch. Das letzte Commit ist stets der HEAD . Derzeit ist unser HEAD also dieses initiale Commit. Die Begriffe sind in der folgenden Abbildung dargestellt: Wir \u00e4ndern nun mal die Datei Projekt1/src/A.java und f\u00fcgen dort einfach ein Zeilenkommentar // Zeile 1 hinzugefuegt // hinzu. Wenn wir nun git status aufrufen, erscheint Auf Branch master \u00c4nderungen, die nicht zum Commit vorgemerkt sind: ( benutzen Sie \"git add <Datei>...\" , um die \u00c4nderungen zum Commit vorzumerken ) ( benutzen Sie \"git restore <Datei>...\" , um die \u00c4nderungen im Arbeitsverzeichnis zu verwerfen ) ge\u00e4ndert: Projekt1/src/A.java keine \u00c4nderungen zum Commit vorgemerkt ( benutzen Sie \"git add\" und/oder \"git commit -a\" ) Wir k\u00f6nnen diese \u00c4nderung nun committen, indem wir die Option -a verwenden (oder zuvor git add Projekt1/src/A.java ): git commit -am \"in A.java Zeile 1 hinzugefuegt\" Wir erhalten die Ausgabe: [ master 44ed3a8 ] in A.java Zeile 1 hinzugefuegt 1 file changed, 2 insertions ( + ) Wir haben jetzt einen neuen HEAD , nicht mehr das Root-Commit mit der \"Nummer\" 8236e8a , sondern nun dieses zweite Commit mit der \"Nummer\" 44ed3a8 . Diese Nummern sind Hash-Werte. Tats\u00e4chlich sind diese Hash-Werte sogar l\u00e4nger. Wir k\u00f6nnen Sie uns mit git log anzeigen lassen.","title":"git commit - einen Snapshot erstellen"},{"location":"git/#git-log-und-git-show","text":"Mit git log k\u00f6nnen Sie sich alle Ihre Commits auflisten lassen. In unserem jetzigen Zustand erzeugt git log folgende Ausgabe: commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd ( HEAD -> master ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 18 :13:48 2021 +0200 in A.java Zeile 1 hinzugefuegt commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Wenn Ihnen diese Ansicht zu un\u00fcbersichtlich ist, k\u00f6nnen Sie die Option --oneline verwenden: git log --oneline erzeugt: 44ed3a8 ( HEAD -> master ) in A.java Zeile 1 hinzugefuegt 8236e8a Initiales Commit. A.java und B.java jeweils leer.","title":"git log und git show"},{"location":"git/#git-branch-und-git-ckeckout-branches-in-git","text":"Unser Repository sieht derzeit so aus: Angenommen, wir wollen etwas ausprobieren und unabh\u00e4ngig von dem Hauptentwicklungsstrang (dem master -Branch) z.B. an Projekt1/src/B.java arbeiten, ohne aber den bisherigen Stand zu \"gef\u00e4rden\". Dazu gibt es die M\u00f6glichkeit, neue, eigene Branches zu erstellen. Diese gehen von einem Commit des master -Branches aus und k\u00f6nnen sp\u00e4ter auch wieder auf den master -Branch f\u00fchren (oder, falls unser Ausprobieren doch nicht erfolgreich war, auch nicht). Einen neuen Branch erstellen wir mit git branch <nameDesNeuenBranches> . Wir erstellen uns einen Branch tryB : git branch tryB Dabei passiert erstmal noch gar nichts. Es wird nur ein Link auf das letzte Commit (den HEAD ) erzeugt und dieser Link hei\u00dft tryB . Wenn wir jetzt einfach erstmal an Projekt1/src/A.java weiterarbeiten w\u00fcrden und die \u00c4nderungen committen, stellen wir fest, dass wir tats\u00e4chlich am master -Branch weiterarbeiten. Um das zu zeigen, \u00e4ndern wir die Datei Projekt1/src/A.java und f\u00fcgen einen weiteren Zeilenkommentar hinzu. // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // Wir wissen bereits, wie wir diese \u00c4nderung committen: git commit -am \"in A.java Zeile 2 hinzugefuegt\" git log ergibt: commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde ( HEAD -> master ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sat Apr 3 09 :09:54 2021 +0200 in A.java Zeile 2 hinzugefuegt commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd ( tryB ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 18 :13:48 2021 +0200 in A.java Zeile 1 hinzugefuegt commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Das zeigt uns, dass wir am master -Branch weitergearbeitet haben und dass HEAD auf den master -Branch zeigt. Wir sehen aber auch, dass wir auf dem zweiten Commit einen Link tryB haben. Wir wollen jetzt aber auf diesem tryB -Branch arbeiten und nutzen dazu den Befehl git checkout <branch> : git checkout tryB Damit haben wir 2 Sachen getan: arbeiten wir jetzt auf einem anderen Branch, als dem master -Branch, n\u00e4mlich dem tryB -Branch und setzen wir auf den Zustand auf, den wir mit dem Commit gespeichert hatten ( 44ed3a8 ), auf den tryB zeigt. Den 2. Punkt k\u00f6nnen wir \u00fcberpr\u00fcfen, indem wir uns die Datei Projekt1/src/A.java anschauen. Die sieht n\u00e4mlich jetzt (wieder) so aus: // Zeile 1 hinzugefuegt // Wir f\u00fcgen nun das Gleiche in die Projekt1/src/B.java ein: // Zeile 1 hinzugefuegt // und committen diese \u00c4nderung: git commit -am \"in B.java Zeile 1 hinzugefuegt\" Die Commits lassen wir uns zun\u00e4chst mit git log anzeigen: commit e754d18f0d8cb1e8593edca740fa75b84d5de30f ( HEAD -> tryB ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sat Apr 3 09 :56:28 2021 +0200 in B.java Zeile 1 hinzugefuegt commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 18 :13:48 2021 +0200 in A.java Zeile 1 hinzugefuegt commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Wir sehen, dass alle Commits aufgelistet werden, die bis zum aktuellen HEAD f\u00fchren. Es fehlt aber beispielsweise das Commit, das bereits f\u00fcr den master -Branch ausgef\u00fchrt wurde und in dem in Projekt1/src/A.java bereits Zeile 2 hinzugefuegt wurde. Um sich alle Commits auszugeben und sogar eine Graph-\u00e4hnliche Darstellung zu erhalten, verwenden wir git log --all --graph Wir erhalten folgende Ausgabe: * commit e754d18f0d8cb1e8593edca740fa75b84d5de30f ( HEAD -> tryB ) | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :56:28 2021 +0200 | | in B.java Zeile 1 hinzugefuegt | | * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde ( master ) | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :09:54 2021 +0200 | | in A.java Zeile 2 hinzugefuegt | * commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Fri Apr 2 18 :13:48 2021 +0200 | | in A.java Zeile 1 hinzugefuegt | * commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. und daraus erkennt man, dass unser Repository (die Commit-Hostorie) derzeit so aussieht:","title":"git branch und git ckeckout - Branches in Git"},{"location":"git/#git-merge-branches-zusammenfuhren","text":"Wir haben folgende Situation: ausgehend von Commit 44ed3a8 ( in A.java Zeile 1 hinzugefuegt ) haben wir auf dem master -Branch weitergearbeitet und dort ein Commit 9c869b6 ( in A.java Zeile 2 hinzugefuegt ) erstellt und parallel dazu auf dem tryB -Branch gearbeitet und dort ein Commit e754d18 ( in B.java Zeile 1 hinzugefuegt ) erstellt. Nun wollen wir beide Branches wieder zusammenf\u00fchren, um mit beiden \u00c4nderungen weiterzuarbeiten. Das Zusammenf\u00fchren von Branches erfolgt mithilfe von git merge <branchToMerge> . Wir wollen gerne den tryB -Branch in den master -Branch mergen , um dann mit dem master -Branch weiterzuarbeiten. Dazu wechseln wir zun\u00e4chst in den master -Branch. das erreichen wir, indem wir checkout verwenden: git checkout master Die Ausgabe ist Zu Branch 'master' gewechselt Nun mergen wir diesen mit dem tryB -Branch, indem wir git merge tryB eingeben. Wichtig ist, dass es sich hierbei auch um ein erzwungenes Commit (sogenanntes Merge-Commit ) handelt, da beide Branches eigene Commits enthielten. Es wird uns eine Commit-nachricht angeboten. Mit ZZ verlassen wir den vi . Wenn wir uns nun die Commit-Logs ausgeben lassen ( git log --all --graph ), dann erhalten wir folgende Ausgabe * commit 7ffabf8646580d6bb2ba289de93e6fe20b894084 ( HEAD -> master, tryB ) | \\ Merge: e754d18 9c869b6 | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 16 :21:12 2021 +0200 | | | | Merge branch 'master' into tryB | | | * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 09 :09:54 2021 +0200 | | | | in A.java Zeile 2 hinzugefuegt | | * | commit e754d18f0d8cb1e8593edca740fa75b84d5de30f | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :56:28 2021 +0200 | | in B.java Zeile 1 hinzugefuegt | * commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Fri Apr 2 18 :13:48 2021 +0200 | | in A.java Zeile 1 hinzugefuegt | * commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. und erkennen, dass die beiden Branches nun wieder \"vereint\" sind: Wenn wir uns A.java anschauen, dann sehen wir, dass diese Datei 2 Zeilen enth\u00e4lt und die Datei B.java eine. Beide sind also auf dem aktuellsten Stand. Wir \u00fcben Mergen an dieser Stelle nochmal und bilden 2 Branches, in dem einen erstellen wir uns eine \"Klasse\" C.java und in dem anderen eine D.java : git branch classC git branch classD git checkout classC touch Projekt1/src/C.java echo \"// Zeile 1 hinzugefuegt\" >> Projekt1/src/C.java git add Projekt1/src/C.java git commit -m \"in C.java Zeile 1 hinzugefuegt\" git checkout classD touch Projekt1/src/C.java echo \"// Zeile 1 hinzugefuegt\" >> Projekt1/src/D.java git add Projekt1/src/D.java git commit -m \"in D.java Zeile 1 hinzugefuegt\" git checkout master git merge classC Hierbei handelt es sich um ein sogenanntes Fast-Forward-Commit , da der master -Branch keine eigenen \u00c4nderungen enthielt, sondern nur die \u00c4nderungen des classC -Branches in den master -Branch eingef\u00fcgt werden m\u00fcssen. Es gibt hier keine potenziellen Konflikte. Wenn wir nun aber auch den classD -Branch in den master -Branch mergen wollen, enth\u00e4lt sowohl der master -Branch \u00c4nderungen ( C.java ) als auch der classD -Branch ( D.java ). Hierbei handelt es sich also um ein Merge-Commit : git merge classD vi \u00f6ffnet und wir k\u00f6nnen die Commit-Message \u00e4ndern oder sie so lassen. Wir beenden den vi wieder mit ZZ . git log --all --graph zeigt: * commit 15d5e0b00f2a4af5eaa4d84ba55e340f912ccb42 ( HEAD -> master ) | \\ Merge: 0d86294 01f8dfd | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 17 :12:18 2021 +0200 | | | | Merge branch 'classD' | | | * commit 01f8dfd9c68148c984db99dec980d227f1fe4044 ( classD ) | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 17 :05:46 2021 +0200 | | | | in D.java Zeile 1 hinzugefuegt | | * | commit 0d8629458ca0a5e244c121be525f8e647b5c6bd9 ( classC ) | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 16 :51:14 2021 +0200 | | in C.java Zeile 1 hinzugefuegt | * commit 7ffabf8646580d6bb2ba289de93e6fe20b894084 ( tryB ) | \\ Merge: e754d18 9c869b6 | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 16 :21:12 2021 +0200 | | | | Merge branch 'master' into tryB | | | * commit 9c869b672ed42c5af22cbb5c9fdc3419ff863bde | | Author: J. Freiheit <freiheit@htw-berlin.de> | | Date: Sat Apr 3 09 :09:54 2021 +0200 | | | | in A.java Zeile 2 hinzugefuegt | | * | commit e754d18f0d8cb1e8593edca740fa75b84d5de30f | / Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Sat Apr 3 09 :56:28 2021 +0200 | | in B.java Zeile 1 hinzugefuegt | * commit 44ed3a807200ef537f5da0817e0ff3ac0b958ffd | Author: J. Freiheit <freiheit@htw-berlin.de> | Date: Fri Apr 2 18 :13:48 2021 +0200 | | in A.java Zeile 1 hinzugefuegt | * commit 8236e8ac0b2e2c7d5a83df3f2f71bf73297188a6 Author: J. Freiheit <freiheit@htw-berlin.de> Date: Fri Apr 2 08 :42:37 2021 +0200 Initiales Commit. A.java und B.java jeweils leer. Die Commit-Historie unseres Repositories sieht so aus: Eine umfangreiche Beschreibung aller \u00c4nderungen in den jeweiligen Commits erhalten Sie auch durch den Befehl git show --pretty=fuller --abbrev-commit .","title":"git merge - Branches zusammenf\u00fchren"},{"location":"git/#konflikte-auflosen","text":"Gerade bei der Arbeit im Team kann es passieren, dass in verschiedenen Branches an der gleichen Datei \u00c4nderungen durchgef\u00fchrt werden. Wenn diese Branches dann \"gemerged\" werden sollen, kann Git diesen Konflikt nicht alleine aufl\u00f6sen (soll \u00c4nderung A gelten oder \u00c4nderung B oder beide?). Die Aufl\u00f6sung eines solchen Konfliktes muss durch die Entwicklerinnen geschehen. Zur Demonstration erzeugen wir uns erneut zwei Branches, changeA1 und changeA2 und f\u00fchren in beiden Branches eine \u00c4nderung an Projekt1/src/A.java durch: git branch changeA1 git branch changeA2 git checkout changeA1 echo \"// eine \u00c4nderung durch Entwicklerin A\" >> Projekt1/src/A.java git commit -am \"in A eine \u00c4nderung durch Entwicklerin A\" git checkout changeA2 echo \"// eine \u00c4nderung durch Entwicklerin B\" >> Projekt1/src/A.java git commit -am \"in A eine \u00c4nderung durch Entwicklerin B\" Wenn wir jetzt versuchen, die beiden Branches mit git merge changeA1 zu mergen, dann erhalten wir folgende Ausgabe: automatischer Merge von Projekt1/src/A.java KONFLIKT ( Inhalt ) : Merge-Konflikt in Projekt1/src/A.java Automatischer Merge fehlgeschlagen ; beheben Sie die Konflikte und committen Sie dann das Ergebnis. Git kann diesen Konflikt nicht automatisch aufl\u00f6sen. Die Ausgabe von git status hilft dabei nicht wirklich weiter: Auf Branch changeA2 Sie haben nicht zusammengef\u00fchrte Pfade. ( beheben Sie die Konflikte und f\u00fchren Sie \"git commit\" aus ) ( benutzen Sie \"git merge --abort\" , um den Merge abzubrechen ) Nicht zusammengef\u00fchrte Pfade: ( benutzen Sie \"git add/rm <Datei>...\" , um die Aufl\u00f6sung zu markieren ) von beiden ge\u00e4ndert: Projekt1/src/A.java keine \u00c4nderungen zum Commit vorgemerkt ( benutzen Sie \"git add\" und/oder \"git commit -a\" ) Mit git log --merge k\u00f6nnen wir uns die Commits anschauen, die die \u00c4nderungen enthalten, welche f\u00fcr den Konflikt sorgen: commit da1f715199e68f17ea276b07a9c3a6e88b319e8a ( HEAD -> changeA2 ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sun Apr 4 08 :08:13 2021 +0200 in A eine \u00c4nderung durch Entwicklerin B commit 63a9a40ab267bc53f2a688a45e6813d7c15170c6 ( changeA1 ) Author: J. Freiheit <freiheit@htw-berlin.de> Date: Sun Apr 4 08 :07:25 2021 +0200 in A eine \u00c4nderung durch Entwicklerin A Der Befehl git diff zeigt uns den Konflikt ganz konkret an: diff --cc Projekt1/src/A.java index a5c84c3,a920d29..0000000 --- a/Projekt1/src/A.java +++ b/Projekt1/src/A.java @@@ -1,4 -1,4 +1,8 @@@ // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // ++ <<<<<< < HEAD +// eine \u00c4nderung durch Entwicklerin B ++ ======= + // eine \u00c4nderung durch Entwicklerin A ++>>>>>>> changeA1 Diese Darstellung in der Datei finden wir auch wieder, wenn wir uns die Datei Projekt1/src/A.java anschauen: // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // <<<<<< < HEAD // eine \u00c4nderung durch Entwicklerin B ======= // eine \u00c4nderung durch Entwicklerin A >>>>>>> changeA1 In unserer Konflikt-Datei gibt es folgende drei Eintr\u00e4ge: <<<<<<< HEAD ======= >>>>>>> changeA1 Aller Inhalt zwischen den ersten beiden Zeilen enth\u00e4lt die \u00c4nderungen des aktuellen Branches und alle \u00c4nderungen zwischen den letzten beiden Zeilen enth\u00e4lt alle \u00c4nderungen des Branches, in den gemerged werden soll ( changeA1 ). Entwicklungsumgebungen (IntelliJ, Eclipse, Atom, Visual Studio Code usw.) unterst\u00fctzen bei der Aufl\u00f6sung solcher Konflikte. Wir \u00fcbernehmen einfach beide \u00c4nderungen h\u00e4ndisch und committen diese \u00c4nderung. Projekt1/src/A.java sieht also jetzt so aus: // Zeile 1 hinzugefuegt // Zeile 2 hinzugefuegt // // eine \u00c4nderung durch Entwicklerin B // eine \u00c4nderung durch Entwicklerin A und der Commit: git commit -am \"Merge-Konflikt in A.java geloest. Aenderungen A UND B eingefuegt\" .","title":"Konflikte aufl\u00f6sen"},{"location":"git/#merge-abbrechen","text":"Sollten Sie aufgrund der Konfliktmeldung den Merge-Vorgang doch nicht durchf\u00fchren wollen, k\u00f6nnen Sie mit git merge --abort den Merge abbrechen und mit git reset die in Konflikt stehenden Dateien auf einen als funktionierend bekannten Zustand zur\u00fcckzusetzen.","title":"Merge abbrechen"},{"location":"git/#git-stash-arbeit-unterbrechen","text":"Angenommen, Sie haben bereits \u00c4nderungen durchgef\u00fchrt, diese sind aber noch nicht \"fertig\" und Sie wollen Sie deshalb noch nicht committen. Stattdessen m\u00fcssen Sie aber an anderer Stelle zun\u00e4chst noch einen BugFix erledigen. Dann k\u00f6nnen Sie Ihre gegenw\u00e4rtigen \u00c4nderungen \"stashen\" - in einen Stash-Modus setzen, also erstmal verstauen , um daran sp\u00e4ter weiterzuarbeiten: git stash Jetzt k\u00f6nnen Sie erstmal andere \u00c4nderungen durchf\u00fchren und committen und um dann wieder zu Ihren urspr\u00fcnglichen \u00c4nderungen zur\u00fcckzukehren, holen Sie diese wieder aus dem Stash-Modus: git stash pop","title":"git stash - Arbeit unterbrechen"},{"location":"git/#einige-weitere-nutzliche-befehle","text":"Angenommen, Sie haben committed, aber einige \u00c4nderungen vergessen (entweder vorher nicht geadded oder noch gar nicht ge\u00e4ndert), dann k\u00f6nnen Sie den vorherigen Commit \"\u00fcberschreiben\". git commit -m \"zu frueh committed\" // jetzt noch die Aenderungen hinzufuegen git commit --amend Angenommen, Sie haben seit dem letzten Commit \u00c4nderungen an Dateien vorgenommen, die Sie aber gerne verwerfen m\u00f6chten. Sie werden in der Literatur daf\u00fcr Befehle finden, wie z.B. git checkout HEAD oder git reset --hard . Sie sollten damit \u00e4u\u00dferst vorsichtig sein! Bei git checkout HEAD (aslo dem \"Zur\u00fccksetzen\" auf das letzte Commit) bleiben die ge\u00e4nderten Dateien \"modifiziert\". Das hilft also gar nicht wirklich. git reset --hard kann Sie unter Umst\u00e4nden auf ein Commit zur\u00fccksetzen, das noch weiter zur\u00fcck in der Historie liegt, als Sie planen. Verwenden Sie zum Zur\u00fccksetzen Ihrer \u00c4nderungen (Undo) besser git restore <dateiUndo> Geben Sie also die Datei an, die Sie ge\u00e4ndert haben und die wieder auf den Zustand des letzten Commits zur\u00fcckgesetzt werden soll. L\u00f6schen Sie niemals einfach Dateien oder Ordner in dem durch Git verwalteten Ordner (Ihrem Repository) \u00fcber den Finder oder den Dateiexplorer! Die Idee von Git ist die, dass immer nur etwas hinzukommt. Selbst, wenn Sie eine bestimmte Datei nicht mehr ben\u00f6tigen, so kann es ja doch sein, dass diese in fr\u00fcheren Versionen vorkommt. Lassen Sie sie einfach im Verzeichnis!","title":"Einige weitere n\u00fctzliche Befehle"},{"location":"git/#aliases","text":"Es ist ganz hilfreich, sich f\u00fcr einige Optionen Aliase zu definieren, da diese oft verwendet werden. Dazu nutzen Sie git config . Hier einige Beispiele von n\u00fctzlichen Aliases (aus dem Git-Buch ): git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status","title":"Aliases"},{"location":"git/#git-als-kollaborationswerkzeug","text":"Im vorherigen Abschnitt haben wir diskutiert, wie wir Git zur Versionsverwaltung verwenden k\u00f6nnen. Dazu haben wir ein lokales Git-Repository angelegt. Nun wollen wir betrachten, wie Git als Kollaborationswerkzeug eingesetzt werden kann, d.h. wie mehere Entwicklerinnen zusammen an einem (globalen) Git-Repository arbeiten k\u00f6nnen. Dazu ben\u00f6tigen wir einen Host (Bereitsteller netzbasierter Dienste), der ein zentrales Git-Repository zur Verf\u00fcgung stellen kann. Es gibt mehrere solcher Git-Hosts. Die bekanntesten sind: GitHub GitLab Bibucket Wir zeigen das Verwenden eines zentralen Repositories exemplarisch f\u00fcr GitHub . Sie m\u00fcssen sich in GitHub registrieren . Die Verwendung von GitHub ist kostenlos . Die Idee eines zentralen Repositorys ist die, dass daran mehrere lokale Repositories angebunden sein k\u00f6nnen: \u00dcber das zentrale Repository werden alle lokalen Repositories synchronisiert, so dass alle Repositories \u00fcber den gleichen Stand, d.h. alle Dateien und Ordner sowie die gleiche Commit-Historie verf\u00fcgen. Wichtig ist jedoch, dass man zum Entwickeln nicht permanent online sein muss. Vielmehr kann man beliebig lange offline auf dem eigenen lokalen Repository arbeiten, bis man irgendwann seine \u00c4nderungen in das zentrale Repository schreiben ( push ) bzw. dort abgelegte \u00c4nderungen aus anderen lokalen Repositories lesen ( pull ) m\u00f6chte.","title":"Git als Kollaborationswerkzeug"},{"location":"git/#ein-zentrales-repository-anlegen","text":"Sie loggen sich in GitHub (oder dem von Ihnen gew\u00e4hlten Diensteanbieter) ein und klicken auf \"New\": Dann geben Sie einen sprechenden Namen f\u00fcr das Repository ein. Sie k\u00f6nnen w\u00e4hlen, ob das Repository Public (f\u00fcr alle lesbar) oder Private (nur f\u00fcr Eingeladene lesbar) sein soll. Die darunter stehenden Checkboxen sollten Sie nicht anklicken, da Sie ein bereits existierendes lokales Repository mit diesem zentralen Repository verbinden wollen. In Ihrem lokalen Repository haben Sie ja wahrscheinlich bereits eine .gitignore -Datei. W\u00fcrden Sie diese Checkboxen markieren, m\u00fcssten Sie bereits ganz am Anfang mergen . Klicken Sie auf den Button Create repository . Das zentrale Repository ist nun erstellt. Nun m\u00fcssen wir nur noch vorgehen, wie auf der Seite angegeben: Im Terminal f\u00fchren wir im workspace -Ordner (in unserem lokalen Repository - der Ordner, der den .git -Ordner enth\u00e4lt) den Befehl git remote add origin https://github.com/jfreiheit/einfuehrung-git.git aus. https://github.com/jfreiheit/einfuehrung-git.git entspricht dabei der sogenannten Remote-URL und lautet bei Ihnen nat\u00fcrlich anders. Es ist der Pfad (die URL) zu Ihrem zentralen Git-Repository. Mit diesem Befehl verbinden wir unser lokales Git-Repository mit dem zentralen Git-Repository. Wir geben dem zentralen Git-Repository dabei den Namen origin . Den n\u00e4chsten von GitHub vorgeschlagenen Befehl git branch -M main k\u00f6nnen wir ebenfalls ausf\u00fchren. Wir wissen bereits, dass wir damit einen neuen Branch erstellen, n\u00e4mlich main . Wir verlassen also den master -Branch und wechseln zu einem neuen main -Branch. Das kann man machen, muss man aber nicht. Die Option -M steht f\u00fcr --move --force . Damit bestimmen wir, dass wir einen main -Branch erstellen, selbst wenn dieser bereits existierte. Siehe auch die Dokumentation f\u00fcr git branch . Der dritte von GitHub vorgeschlagene Befehl git push -u origin main bewirkt, dass unser komplettes lokales Git-Repository auf das zentrale Git-Repository gespielt wird. Das hei\u00dft, der aktuelle Branch main wird auf das zentrale Git-Repository origin gepushed . Nach Ausf\u00fchrung dieses Befehls ist das zentrale Repository auf dem selben Stand wie das lokale Repository.","title":"Ein zentrales Repository anlegen"},{"location":"git/#alltag-mit-git","text":"Ihr lokales Repository ist nun mit dem zentralen Repository verkn\u00fcpft. Wenn Sie jetzt \u00c4nderungen an Ihrem Code (Ihrem lokalen Repository) durchf\u00fchren und diese \u00c4nderungen auf dem zentralen Repository speichern wollen, sieht Ihr \"Alltag\" wie folgt aus.","title":"Alltag mit Git"},{"location":"git/#git-add-eine-neue-datei-hinzufugen","text":"Angenommen, Sie erstellen eine neue Klasse (Datei), z.B. Projekt1/src/E.java , dann f\u00fcgen Sie diese neue Datei mit git add <neueDatei> Ihrem lokalen Repository hinzu: git add Projekt1/src/E.java Wenn Sie sich dann mit git status den Status des Repositorys anschauen, erhalten Sie Auf Branch main Ihr Branch ist auf demselben Stand wie 'origin/main' . Zum Commit vorgemerkte \u00c4nderungen: ( benutzen Sie \"git restore --staged <Datei>...\" zum Entfernen aus der Staging-Area ) neue Datei: Projekt1/src/E.java Neue Dateien f\u00fcgen Sie mittels git add <neueDatei> dem Repository hinzu.","title":"git add - eine neue Datei hinzuf\u00fcgen"},{"location":"git/#git-commit-anderungen-speichern","text":"Angenommen, Sie haben \u00c4nderungen an Dateien hinzugef\u00fcgt, diese Dateien sind aber bereits Teil des Repositorys (wurden also bereits bei Erstellung mit git add hinzugef\u00fcgt). Dann speichern Sie diese \u00c4nderungen mit git commit -am \"Commit-Message\" . Angenommen, wir haben in Projekt1/src/E.java 2 Zeilen hinzugef\u00fcgt, dann committen wir diese \u00c4nderungen z.B. mit git commit -am \"in E.java 2 Zeilen hinzugefuegt\" Die Option -m steht daf\u00fcr, dass wir gleich die Commit-Message mit angeben. Fehlt diese Option, \u00f6ffnet sich ein vi und wir f\u00fcgen die Commit-Message nachtr\u00e4glich hinzu. Den vi verlassen wir mit ZZ . Die Option -a steht f\u00fcr add . Jede \u00c4nderung muss zun\u00e4chst hinzugef\u00fcgt werden. H\u00e4ufig sieht man daf\u00fcr die Verwendung des Befehls git add . . Das l\u00e4sst sich aber mit der Option -a auch beim Commit selbst erledigen. Wenn Sie sich dann mit git status den Status des Repositorys anschauen, erhalten Sie Auf Branch main Ihr Branch ist 1 Commit vor 'origin/main' . ( benutzen Sie \"git push\" , um lokale Commits zu publizieren ) nichts zu committen, Arbeitsverzeichnis unver\u00e4ndert \u00c4nderungen am Code (Repository) \"committen\" (speichern) Sie mittels git commit -am \"Commit-Message\" .","title":"git commit - \u00c4nderungen \"speichern\""},{"location":"git/#git-push-anderungen-auf-das-zentrale-repository-spielen","text":"Sie k\u00f6nnen beliebig lange und oft Ihr lokales Repository \u00e4ndern, wie im Abschnitt Git als Versionierungswerkzeug beschrieben. Wenn Sie Ihr lokales Repository auf Ihr zentrales Repository spielen m\u00f6chten, verwenden Sie den Befehl git push . Damit stellen Sie das zentrale Repository auf den Stand Ihres lokalen Repositorys. git push ergibt folgende Ausgabe: Objekte aufz\u00e4hlen: 8 , fertig. Z\u00e4hle Objekte: 100 % ( 8 /8 ) , fertig. Delta-Kompression verwendet bis zu 8 Threads. Komprimiere Objekte: 100 % ( 3 /3 ) , fertig. Schreibe Objekte: 100 % ( 5 /5 ) , 439 Bytes | 439 .00 KiB/s, fertig. Gesamt 5 ( Delta 1 ) , Wiederverwendet 0 ( Delta 0 ) , Pack wiederverwendet 0 remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To https://github.com/jfreiheit/einfuehrung-git.git 15d5e0b..6ddd0dc main -> main Damit \u00fcbernimmt das zentrale Repository den Stand des lokalen Repositorys. Um das zentrale Repository auf den Stand Ihres lokalen Repositorys zu bringen, verwenden Sie git push . Das hei\u00dft, wenn Sie alleine an Ihrem zenztralen Repository arbeiten, m\u00fcssen sie sich nur folgende Befehle merken: git add <datei> // falls die Datei neu erstellt wurde und Ihrem Repository bekannt gemacht (hinzugef\u00fcgt) werden soll git commit -am \"Commit-Message\" // um die \u00c4nderungen ins lokale Repository zu \"speichern\" git push // um das zentrale Repository auf den Stand des lokalen Repositorys zu bringen So sieht einfach sieht der Alltag aus, wenn Sie alleine am (zentralen) Repository arbeiten.","title":"git push - \u00c4nderungen auf das zentrale Repository spielen"},{"location":"git/#ein-existierendes-zentrales-repository-verwenden","text":"Angenommen, jemand anderer besitzt ein zentrales Repository und m\u00f6chte den Code mit Ihnen teilen - angenommen, ich m\u00f6chte mit Ihnen den Code aus meinem Repository https://github.com/jfreiheit/einfuehrung-git.git teilen. Sie k\u00f6nnen dieses Repository klonen (kopieren), indem sie einmalig git clone https://github.com/jfreiheit/einfuehrung-git.git eingeben. Dadurch erstellen Sie sich ein lokales Repository, das einer identischen Kopie (einem Clone) des zentralen Repositorys https://github.com/jfreiheit/einfuehrung-git.git entspricht. Dieses lokale Repository ist dann bereits auch mit dem zentralen Repository verbunden. Angenommen, ich f\u00fchre nun \u00c4nderungen an diesem zentralen Repository durch und somit einige Commits. Damit diese \u00c4nderungen auch Ihrem lokalen Repository bekannt werden, f\u00fchren Sie git pull aus. Damit \"holen\" Sie sich den aktuellen Stand des zentralen Repositories.","title":"Ein existierendes zentrales Repository verwenden"},{"location":"git/#git-config","text":"Sollten Sie aufgefordert werden, einige Accountdetails in Ihrer Git-Konfiguration zu speichern, dann machen Sie das. Sie k\u00f6nnen diese Schritte selbst dann vornehmen, wenn Sie nicht dazu aufgefordert werden: git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" In den Strings geben Sie nat\u00fcrlich Ihre Daten an. Weitere Informationen zur Konfiguration von Git finden Sie auch hier .","title":"git config"},{"location":"git/#nutzliche-links-zu-git","text":"Git Dokumentation Git Buch Lerne Git mit Bitbucket Cloud Git-Tutorial: Git und die wichtigsten Befehle kennenlernen Learn Git Branching Git - Der einfache Einstieg Git in Bildern Visualizing Git Concepts Git Kata noch mehr Git Katas","title":"N\u00fctzliche Links zu Git"},{"location":"git/#egit-git-mit-eclipse","text":"Mit EGit integrieren Sie Git in Eclipse. Sie k\u00f6nnen pr\u00fcfen, ob Sie EGit bereits in Eclipse installiert haben, indem Sie in Eclipse unter Help \u2192 Eclipse Marketplace den Reiter Installed anklicken und schauen, ob EGit in dieser Liste auftaucht. Wenn nicht, w\u00e4hlen Sie den Reiter Search und geben in die Suchleiste EGit ein und installieren das PlugIn. Sie k\u00f6nnen auch unter Help \u2192 Install new Software... diese URL eintragen, um EGit zu installieren: http://download.eclipse.org/egit/updates . Sie finden die Installationsanleitung auch unter https://www.eclipse.org/egit/ oder z.B. auch hier und hier . Beim Verbinden Ihres lokalen Repositories mit Eclipse k\u00f6nnen Sie z.B. vorgehen wie hier beschrieben oder hier .","title":"EGit - Git mit Eclipse"},{"location":"hilfen/","text":"Hilfen \u00b6 Hier erl\u00e4utern wir in losem Zusammenhang einzelne Aspekte.","title":"Hilfen"},{"location":"hilfen/#hilfen","text":"Hier erl\u00e4utern wir in losem Zusammenhang einzelne Aspekte.","title":"Hilfen"},{"location":"interfaces/","text":"Interfaces \u00b6 Interfaces sind auch abstrakte Klassen. Interfaces enthalten ausschlie\u00dflich abstrakte Methoden (keine Methode darf implementiert sein). Interfaces beschreiben Schnittstellen . F\u00fcr Interfaces wird nicht das Schl\u00fcsselwort class , sondern interface verwendet. Klassen erben nicht von Interfaces, sondern implementieren sie. Deshalb wird auch nicht das Schl\u00fcsselwort extends , sondern das Schl\u00fcsselwort implements verwendet. W\u00e4hrend in Java nur von genau einer Klasse geerbt werden kann (also auch nur von genau einer abstrakten Klasse), kann eine Klasse kann beliebig viele Interfaces implementieren. Interfaces sind automatisch abstract , d.h. das Schl\u00fcsselwort abstract muss nicht angegeben werden. Auch die Methoden in Interfaces m\u00fcssen nicht als abstrakt gekennzeichnet werden. Interfaces k\u00f6nnen, wie abstrakte Klassen auch, als Typen verwendet werden. Abtrakte Klasse Interface k\u00f6nnen abstrakte und nicht-abstrakte (also implementierte) Methoden haben k\u00f6nnen nur abstrakte Methoden beinhalten es kann nur von einer (abstrakten) Klasse geerbt werden (Schl\u00fcsselwort extends ) es k\u00f6nnen beliebig viele Interfaces implementiert werden (Schl\u00fcsselwort implemenets ), mehrere Interfaces durch Komma getrennt abstrakte Klassen k\u00f6nnen selbst Interfaces implementieren Interfaces k\u00f6nnen keine abstrakten Klassen implementieren (alle Methoden m\u00fcssen ja abstrakt sein) das Schl\u00fcsselwort abstract deklariert eine abstrakte Klasse (und eine abstrakte Methode) das Schl\u00fcsselwort interface deklariert ein Interface eine abstrakte Klasse kann von einer anderen abstrakten Klasse erben und mehrere Interfaces implementieren ein Interface kann nur von einem anderen Interface erben abtrakte Klassen k\u00f6nnen final Variablen (Konstanten), nicht-finale Variablen, statische und nicht-statische Variablen als Eigenschaften beinhalten Interfaces k\u00f6nnen nur statische Konstanten ( static final ) als Eigenschaften beinhalten die Eigenschaften einer abstrakten Klasse k\u00f6nnen private , protected , default und public sein in Interfaces sind alle Eigenschaften public Bsp.: public abstract class Shape{ public abstract void draw(); } Bsp.: public interface Drawable{ void draw(); } Das Interface Comparable \u00b6 Ehe wir uns ein eigenes Interface schreiben, schauen wir uns zun\u00e4chst die Verwendung eines bereits existierenden Interfaces an. Es handelt sich um das Interface Comparable aus dem java.lang -Paket. Wenn Sie sich die Java-Dokumentation dieses Interfaces einmal anschauen, dann sehen Sie, dass es von sehr vielen Klassen implementiert wird. Dieses Interface enth\u00e4lt genau eine (nat\u00fcrlich abstrakte) Methode compareTo() . Diese Methode kennen wir auch schon, denn wir haben sie betrachtet, als wir in Prog1 Strings kennengelernt haben. Die Methode this.compareTo(Object obj) wird verwendet, um zu vergleichen, ob this gr\u00f6\u00dfer, kleiner oder gleich obj ist. Das bedeutet, dass wir compareTo() in unserer Klasse implementieren sollten, wenn wir die Objekte unserer Klasse der Gr\u00f6\u00dfe nach ordnen wollen, wenn wir also erm\u00f6glichen wollen, dass die Objekte der Klasse sortiert werden k\u00f6nnen. Die Methode this.compareTo(Object obj) gibt ein int zur\u00fcck, f\u00fcr dessen Wert Folgendes gelten soll: ist der zur\u00fcckgegebene int -Wert positiv ( > 0 ), dann ist this gr\u00f6\u00dfer als obj , ist der zur\u00fcckgegebene int -Wert negativ ( < 0 ), dann ist this kleiner als obj , ist der zur\u00fcckgegebene int -Wert 0 , dann ist this gleich obj . Angenommen, wir wollen f\u00fcr die folgende Klasse Rectangle (aus dem Abschnitt Abstrakte Klassen ) festlegen, dass die Rechtecke der Gr\u00f6\u00dfe nach geordnet werden k\u00f6nnen. Gegeben ist also zun\u00e4chst folgende Klasse (wir verwenden hier auch Shape aus Abstrakte Klassen ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Die Klasse Rectangle erbt also von der abstrakten Klasse Shape und Rectangle muss deshalb die Methoden perimeter() und area() implementieren. Nun geben wir an, dass Rectangle auch das Interface Comparable implementieren soll. Dazu erg\u00e4nzen wir die erste Zeile um implements Comparable , d.h. die Klassendeklaration sieht jetzt so aus: 1 2 public class Rectangle extends Shape implements Comparable { Wenn Sie das hinzuf\u00fcgen, stellen wir fest, dass ein Fehler erzeugt wird (die Klasse l\u00e4sst sich nicht compilieren). Die Fehlerausgabe besagt: The type Rectangle must implement the inherited abstract method Comparable.compareTo(Object) . Es werden zwei QuickFixes angeboten, entweder Add unimplemented methods oder Make type Rectangle abstract . Letzteres wollen wir aber nicht ( Rectangle soll nicht zu einer abstrakten Klasse gemacht werden). Also w\u00e4hlen wir Add unimplemented methods . Eclipse f\u00fcgt uns die compareTo() -Methode in den Code ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Jetzt l\u00e4sst sich der Code bereits compilieren, wir erhalten aber noch eine Warnung: Comparable is a raw type. References to generic type Comparable<T> should be parameterized Diese Warnung besagt, dass wir, wie wir das von Collections bereits kennen, auch das Interface Comparable typisieren sollen. Das wollen wir auch tun, denn wir implementieren dieses Interface hier f\u00fcr unsere Klasse Rectangle . Wir typisieren deshalb Comparable mit Rectangle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Interssanterweise ist nun zwar unsere Warnung weg, aber daf\u00fcr erhalten wir erneut einen Fehler: The type Rectangle must implement the inherited abstract method Comparable<Rectangle>.compareTo ( Rectangle ) Dadurch, dass wir Comparable mit Rectangle typisieren (was korrekt ist), wird nun verlangt, dass wir nicht mehr die Methode @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } implementieren, sondern die Methode @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } Der Typ des Parameters hat sich durch unsere Typisierung also ge\u00e4ndert. Das ist gut, denn dann m\u00fcssen wir nicht mehr, wie z.B. bei equals(Object o) , pr\u00fcfen, ob es sich bei dem \u00fcbergebenen Objekt tats\u00e4chlich um ein Rectangle handelt. Wir \u00e4ndern also den Parametertyp in compareTo() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } } In Zukunft typisieren wir das Comparable -Interface noch bevor wir Add unimplemented methods w\u00e4hlen. Wir typisieren es stets mit der Klasse, in der wir das Interface implementieren. F\u00fcr die Implementierung m\u00fcssen wir uns nun \u00fcberlegen, wann ein Rectangle -Objekt gr\u00f6\u00dfer (kleiner/gleich) sein soll, als ein anderes. Da compareTo() ein int zur\u00fcckgibt, k\u00f6nnten wir z.B. die Summen von height und width verwenden: 23 24 25 26 27 @Override public int compareTo ( Rectangle o ) { int diff = ( this . height + this . width ) - ( o . height + o . width ); return diff ; } Wenn die Summe von height und width von this gr\u00f6\u00dfer ist, als von o , dann geben wir eine positive int -Zahl zur\u00fcck, wenn sie kleiner ist, dann eine negative int -Zahl und wenn sie gleich sind, dann 0 . Damit entsprechen wir den Vorgaben von compareTo() .","title":"Interfaces"},{"location":"interfaces/#interfaces","text":"Interfaces sind auch abstrakte Klassen. Interfaces enthalten ausschlie\u00dflich abstrakte Methoden (keine Methode darf implementiert sein). Interfaces beschreiben Schnittstellen . F\u00fcr Interfaces wird nicht das Schl\u00fcsselwort class , sondern interface verwendet. Klassen erben nicht von Interfaces, sondern implementieren sie. Deshalb wird auch nicht das Schl\u00fcsselwort extends , sondern das Schl\u00fcsselwort implements verwendet. W\u00e4hrend in Java nur von genau einer Klasse geerbt werden kann (also auch nur von genau einer abstrakten Klasse), kann eine Klasse kann beliebig viele Interfaces implementieren. Interfaces sind automatisch abstract , d.h. das Schl\u00fcsselwort abstract muss nicht angegeben werden. Auch die Methoden in Interfaces m\u00fcssen nicht als abstrakt gekennzeichnet werden. Interfaces k\u00f6nnen, wie abstrakte Klassen auch, als Typen verwendet werden. Abtrakte Klasse Interface k\u00f6nnen abstrakte und nicht-abstrakte (also implementierte) Methoden haben k\u00f6nnen nur abstrakte Methoden beinhalten es kann nur von einer (abstrakten) Klasse geerbt werden (Schl\u00fcsselwort extends ) es k\u00f6nnen beliebig viele Interfaces implementiert werden (Schl\u00fcsselwort implemenets ), mehrere Interfaces durch Komma getrennt abstrakte Klassen k\u00f6nnen selbst Interfaces implementieren Interfaces k\u00f6nnen keine abstrakten Klassen implementieren (alle Methoden m\u00fcssen ja abstrakt sein) das Schl\u00fcsselwort abstract deklariert eine abstrakte Klasse (und eine abstrakte Methode) das Schl\u00fcsselwort interface deklariert ein Interface eine abstrakte Klasse kann von einer anderen abstrakten Klasse erben und mehrere Interfaces implementieren ein Interface kann nur von einem anderen Interface erben abtrakte Klassen k\u00f6nnen final Variablen (Konstanten), nicht-finale Variablen, statische und nicht-statische Variablen als Eigenschaften beinhalten Interfaces k\u00f6nnen nur statische Konstanten ( static final ) als Eigenschaften beinhalten die Eigenschaften einer abstrakten Klasse k\u00f6nnen private , protected , default und public sein in Interfaces sind alle Eigenschaften public Bsp.: public abstract class Shape{ public abstract void draw(); } Bsp.: public interface Drawable{ void draw(); }","title":"Interfaces"},{"location":"interfaces/#das-interface-comparable","text":"Ehe wir uns ein eigenes Interface schreiben, schauen wir uns zun\u00e4chst die Verwendung eines bereits existierenden Interfaces an. Es handelt sich um das Interface Comparable aus dem java.lang -Paket. Wenn Sie sich die Java-Dokumentation dieses Interfaces einmal anschauen, dann sehen Sie, dass es von sehr vielen Klassen implementiert wird. Dieses Interface enth\u00e4lt genau eine (nat\u00fcrlich abstrakte) Methode compareTo() . Diese Methode kennen wir auch schon, denn wir haben sie betrachtet, als wir in Prog1 Strings kennengelernt haben. Die Methode this.compareTo(Object obj) wird verwendet, um zu vergleichen, ob this gr\u00f6\u00dfer, kleiner oder gleich obj ist. Das bedeutet, dass wir compareTo() in unserer Klasse implementieren sollten, wenn wir die Objekte unserer Klasse der Gr\u00f6\u00dfe nach ordnen wollen, wenn wir also erm\u00f6glichen wollen, dass die Objekte der Klasse sortiert werden k\u00f6nnen. Die Methode this.compareTo(Object obj) gibt ein int zur\u00fcck, f\u00fcr dessen Wert Folgendes gelten soll: ist der zur\u00fcckgegebene int -Wert positiv ( > 0 ), dann ist this gr\u00f6\u00dfer als obj , ist der zur\u00fcckgegebene int -Wert negativ ( < 0 ), dann ist this kleiner als obj , ist der zur\u00fcckgegebene int -Wert 0 , dann ist this gleich obj . Angenommen, wir wollen f\u00fcr die folgende Klasse Rectangle (aus dem Abschnitt Abstrakte Klassen ) festlegen, dass die Rechtecke der Gr\u00f6\u00dfe nach geordnet werden k\u00f6nnen. Gegeben ist also zun\u00e4chst folgende Klasse (wir verwenden hier auch Shape aus Abstrakte Klassen ): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Rectangle extends Shape { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } } Die Klasse Rectangle erbt also von der abstrakten Klasse Shape und Rectangle muss deshalb die Methoden perimeter() und area() implementieren. Nun geben wir an, dass Rectangle auch das Interface Comparable implementieren soll. Dazu erg\u00e4nzen wir die erste Zeile um implements Comparable , d.h. die Klassendeklaration sieht jetzt so aus: 1 2 public class Rectangle extends Shape implements Comparable { Wenn Sie das hinzuf\u00fcgen, stellen wir fest, dass ein Fehler erzeugt wird (die Klasse l\u00e4sst sich nicht compilieren). Die Fehlerausgabe besagt: The type Rectangle must implement the inherited abstract method Comparable.compareTo(Object) . Es werden zwei QuickFixes angeboten, entweder Add unimplemented methods oder Make type Rectangle abstract . Letzteres wollen wir aber nicht ( Rectangle soll nicht zu einer abstrakten Klasse gemacht werden). Also w\u00e4hlen wir Add unimplemented methods . Eclipse f\u00fcgt uns die compareTo() -Methode in den Code ein: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Jetzt l\u00e4sst sich der Code bereits compilieren, wir erhalten aber noch eine Warnung: Comparable is a raw type. References to generic type Comparable<T> should be parameterized Diese Warnung besagt, dass wir, wie wir das von Collections bereits kennen, auch das Interface Comparable typisieren sollen. Das wollen wir auch tun, denn wir implementieren dieses Interface hier f\u00fcr unsere Klasse Rectangle . Wir typisieren deshalb Comparable mit Rectangle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } } Interssanterweise ist nun zwar unsere Warnung weg, aber daf\u00fcr erhalten wir erneut einen Fehler: The type Rectangle must implement the inherited abstract method Comparable<Rectangle>.compareTo ( Rectangle ) Dadurch, dass wir Comparable mit Rectangle typisieren (was korrekt ist), wird nun verlangt, dass wir nicht mehr die Methode @Override public int compareTo ( Object o ) { // TODO Auto-generated method stub return 0 ; } implementieren, sondern die Methode @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } Der Typ des Parameters hat sich durch unsere Typisierung also ge\u00e4ndert. Das ist gut, denn dann m\u00fcssen wir nicht mehr, wie z.B. bei equals(Object o) , pr\u00fcfen, ob es sich bei dem \u00fcbergebenen Objekt tats\u00e4chlich um ein Rectangle handelt. Wir \u00e4ndern also den Parametertyp in compareTo() : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Rectangle extends Shape implements Comparable < Rectangle > { private int width , height ; public Rectangle ( int width , int height ) { this . width = width ; this . height = height ; } @Override public double perimeter () { return ( 2.0 * ( this . width + this . height )); } @Override public double area () { return ( this . width * this . height ); } @Override public int compareTo ( Rectangle o ) { // TODO Auto-generated method stub return 0 ; } } In Zukunft typisieren wir das Comparable -Interface noch bevor wir Add unimplemented methods w\u00e4hlen. Wir typisieren es stets mit der Klasse, in der wir das Interface implementieren. F\u00fcr die Implementierung m\u00fcssen wir uns nun \u00fcberlegen, wann ein Rectangle -Objekt gr\u00f6\u00dfer (kleiner/gleich) sein soll, als ein anderes. Da compareTo() ein int zur\u00fcckgibt, k\u00f6nnten wir z.B. die Summen von height und width verwenden: 23 24 25 26 27 @Override public int compareTo ( Rectangle o ) { int diff = ( this . height + this . width ) - ( o . height + o . width ); return diff ; } Wenn die Summe von height und width von this gr\u00f6\u00dfer ist, als von o , dann geben wir eine positive int -Zahl zur\u00fcck, wenn sie kleiner ist, dann eine negative int -Zahl und wenn sie gleich sind, dann 0 . Damit entsprechen wir den Vorgaben von compareTo() .","title":"Das Interface Comparable"},{"location":"junit/","text":"JUnit-Tests \u00b6 Testen von Programmen ist wichtig. Ohne Testen ist es kaum m\u00f6glich, Fehler in Programmen zu entdecken. Bis jetzt haben wir unsere Programme immer durch reines Anwenden getestet, d.h. wir haben die implementierten Methoden aufgerufen und ihnen unterschiedliche Parameterwerte \u00fcbergeben. Wir werden das jetzt \u00e4ndern und nutzen daf\u00fcr JUnit . Allgemeines zum (Unit-)Testen \u00b6 Der ber\u00fchmte Informatiker Edsger W. Dijkstra hat \u00fcber das Testen gesagt: Durch Testen kann man stets nur die Anwesenheit, nie aber die Abwesenheit von Fehlern beweisen Das bedeutet, wir k\u00f6nnen durch das Testen Fehler finden. Wenn wir aber keine finden, dann wissen wir nicht, ob das Programm dann auch keine Fehler mehr enth\u00e4lt. Es ist leider nicht m\u00f6glich, grunds\u00e4tzlich die Fehlerfreiheit von Programmen zu pr\u00fcfen. Aber das Testen stellt ein wichtiges Werkzeug dar, um Fehler zu entdecken. Es gibt verschiedene Arten von Tests: In der Abbildung erkennen wir, dass die Unit-tests, die wir hier kennenlernen wollen, am besten automatisierbar, am h\u00e4ufigsten und am einfachsten sind. Mit Unit-Tests k\u00f6nnen wir Methoden und Klassen testen, wobei wir die Tests implementieren. Die Idee ist, dass wir funktionale Einzelteile eines Programms separat und isoliert vom Rest auf ihre Korrektheit hin \u00fcberpr\u00fcfen. Wir versuchen extra, so wenig wie m\u00f6glich die Effekte anderer Funktionalit\u00e4ten bzw. Komponenten in die Tests einflie\u00dfen zu lassen. Das erfolgt dann in den Komponenten- bzw. Integrationstests. Das hat zwei Vorteile: einerseits ist der zu pr\u00fcfende Funktionsumfang \u00fcberschaubar und andererseits k\u00f6nnen diese Unit-Tests leicht automatisiert ausgef\u00fchrt werden. Es gibt, wie bereits eingangs erw\u00e4hnt, keine Garantie von Fehlerfreiheit. Ein Nachteil der Unit-Tests besteht darin, dass sie schwierig f\u00fcr Methoden zu gestalten sind, in denen es Abh\u00e4ngigkeiten von der Laufzeitumgebung oder anderen Komponenten gibt. Test-Driven Development \u00b6 Unit Tests k\u00f6nnen entweder nach Erstellung des Programmcodes geschrieben werden, um diesen nachtr\u00e4glich zu testen oder vor Erstellung des Programmcodes. Wenn wir die Tests vor der Erstellung des Programmcodes erstellen, dann beschreiben wir mit den Tests die Anforderungen an den zu erstellenden Code. Wir werden hier lernen, wie die Erstellung der Tests und des Programmcodes Hand-in_Hand erfolgen k\u00f6nnen. Diese Vorgehensweise nennt sich Test-driven developement (TDD) . Wir werden, wie \u00fcblich, TDD anhand eines Beispiels einf\u00fchren. Unser Vorgehen l\u00e4sst sich wie folgt beschreiben: Wir schreiben einen Test, der die Anforderung f\u00fcr einen m\u00f6glichst kleinen iterativen Schritt bei der Erstellung des Programmcodes beschreibt. Wir schreiben m\u00f6glichst wenig Programmcode, so dass der Test genau erf\u00fcllt wird. Wir gehen wieder zu 1. und beschreiben den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test. Wir wiederholen 2. f\u00fcr den neuen Test usw. Die folgende Abbildung visualisiert das Vorgehen. Ausgangspunkt ist immer ein Test. Wir implementieren solange, bis dieser und alle vorher implementierten Tests erfolgreich durchlaufen werden. Dann schreiben wir einen weiteren Test und implementieren wieder so lange, bis dieser und alle vorher geschreibenen Tests erfolgreich durchlaufen werden. Dieses Vorgehen wird so lange wiederholt, so lange wir weitere Testf\u00e4lle hinzuf\u00fcgen k\u00f6nnen, die jeweils neue Anforderungen beschreiben. Zur Implementierung des Codes geh\u00f6rt auch das Refactoring, d.h. wir verbessern bisher geschriebenen Code durch neue Tests. TDD f\u00fcr einen Time-Zeit-Umrechner \u00b6 Angenommen, wir wollen einen einfachen Konverter erstellen, der eine Uhrzeit im 12-Stunden-Zeitsystem (mit am und pm ) in eine 24-Stundendarstellung umwandelt (von String nach String ). Im Web findet man einige Beispiel, z.B. hier . Dazu erstellen wir uns zun\u00e4chst eine Klasse UmrechnungTimeZeit.java , die die Methode convert() enth\u00e4lt. Diese Methode erwartet einen String mit einer 12-Stunden-Zeit time und gibt einen String zur\u00fcck, der die time im 24-Stundenformat darstellt. UmrechnungTimeZeit.java public class UmrechnungTimeZeit { public String convert ( String time ) { return \"\" ; } } Das ist unsere Klasse in der Augangssituation. Bevor wir anfangen, zu implemntieren, wollen wir uns zun\u00e4chst einen ersten einfachen Test schreiben, der uns eine erste Anforderung (einen ersten Testfall) beschreibt. Dazu w\u00e4hlen wir in Eclipse File --> New --> JUnit Test Case . Es erscheint folgendes Fenster: Wir w\u00e4hlen New JUnit Jupiter test aus und benennen unsere Testklasse TestUmrechnungTimeZeit und geben an, dass die Class under test die Klasse UmrechnungTimeZeit ist (Auswahl durch Browse... ). Wenn wir dann auf Finish klicken, erscheint: Das best\u00e4tigen wir mit OK . Es wird die TestUmrechnungTimeZeit.java erstellt, die so aussieht: TestUmrechnungTimeZeit.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void test () { fail ( \"Not yet implemented\" ); } } Sollten Fehler beim Import der junit.jupiter -Pakete angezeigt werden, dann m\u00fcssen Sie in Ihre module-info.java noch folgende Anweisung einf\u00fcgen: Einf\u00fcgen in die module-info.java requires org . junit . jupiter . api ; Eine JUnit-Testklasse \u00b6 Die Klasse TestUmrechnungTimeZeit.java ist eine JUnit-Testklasse. Eine JUnit-Testklasse enth\u00e4lt keine main() -Methode, ist aber ausf\u00fchrbar. Sie enth\u00e4lt stattdessen Methoden, die mit @Test annotiert sind. Diese @Test -Methoden enthalten Zusicherungen (sogenannte Assertions ). Mit diesen Assertions geben Sie das erwartete Ergebnis des Testfalls an. Assertions \u00b6 Es gibt unterschiedliche M\u00f6glichkeiten, das tats\u00e4chliche Ergebnis der Ausf\u00fchrung mit dem erwarteten Ergebnis zu vergleichen: Gleichheit, Ungleichheit, kleiner, gr\u00f6\u00dfer null , nicht null gleiche Objekte ( equals() ) Diese Vergleiche werden mittels Assertions durchgef\u00fchrt. Folgende Tabelle gibt einen \u00dcberblick \u00fcber einige der am meisten verwendeten Assertions an. Alle Assertions, die es gibt, finden Sie hier . Assertion Beschreibung fail(message) L\u00e4sst den Test scheitern (fail) mit Nachricht message . Wird genutzt, um zu \u00fcberpr\u00fcfen, ob Code unerreichbar ist oder bevor der Test implementiert ist. assertTrue(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond wahr ist oder scheitert mit Nachricht m assertFalse(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond false ist oder scheitert mit Nachricht m assertEquals(a,b,m) \u00dcberpr\u00fcft, ob Parameter a und b gleich sind oder scheitert mit Nachricht m assertArrayEquals(a,b,m) \u00dcberpr\u00fcft, ob Inhalte der Arrays a und b gleich sind oder scheitert mit Nachricht m assertNull(o,m) \u00dcberpr\u00fcft, ob Object o==null ist oder scheitert mit Nachricht m assertNotNull(o,m) \u00dcberpr\u00fcft, ob Object o!=null ist oder scheitert mit Nachricht m assertSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1==o2 ist oder scheitert mit Nachricht m assertNotSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1!=o2 ist oder scheitert mit Nachricht m Derzeit verwenden wir in unserer Testklasse nur die Assertion fail() . Diese steht aber nur daf\u00fcr, dass wir diesen Test noch implementieren m\u00fcssen. Das machen wir jetzt. Eine erste Testmethode f\u00fcr unser Beispiel \u00b6 Zun\u00e4chst einmal schauen wir uns an, wie wir unsere Testklasse ausf\u00fchren. Dazu w\u00e4hlen wir in Eclipse unter Run --> Run As ... --> JUnit Test . Oder Sie w\u00e4hlen gleich den mittleren der gezeigten drei Buttons . Dann erhalten Sie folgendes Bild: Auf der linken Seite sehen Sie im JUnit -Reiter einen roten Querbalken. Dieser zeigt an, dass ein Test fehlgeschlagen ist. Im Editor-Fenster wird der fehlgeschlagene Test rot markiert. Es ist klar, dass der Test fehlschl\u00e4gt, denn das bezweckt ja die Assertion fail() . Links unten sieht man den Failure trace . Dort ist in der ertsen Zeile die Fehlermeldung Not yet implemented zu sehen - das ist die Nachricht, die der fail() -Assertion \u00fcbergeben wurde. Wir implementieren nun die erste Testmethode. Dazu benennen wir die Methode test() um in testConvert1amTo1() . In unserem ersten Test wollen wir \u00fcberpr\u00fcfen, ob unsere Methode convert(String time) korrekt arbeitet, wenn ihr der String 1:00 am \u00fcbergeben wird. Die Idee ist nun die folgende: wir definieren unsere Testmethode so, dass wir angeben, welches Ergebnis wir erwarten, wenn der String 1:00 am \u00fcbergeben wird. Wir erwarten das Ergebnis 1:00 . Generell sollte eine Testmethode in der folgenden Form aufgebaut sein: given (preperation) : gibt die Voraussetzungen des Tests an, z.B. die Erzeugung eines Objektes; bei uns: die Erzeugung eines UmrechnungTimeZeit -Objektes, when (execution) : beschreibt, was und wie ausgef\u00fchrt werden soll; bei uns: die Ausf\u00fchrung der Methode convert() mit dem Parameterwert \"1:00 am\" , then (verification) : beschreibt, wie sich das Ergebnis der Ausf\u00fchrung in Bezug auf das erwartete Ergebnis verhalten soll; bei uns: assertEquals(tatsaechlichesErgebnis, \"1:00\") . Nach Umbenennung der Methode test() in TestUmrechnungTimeZeit.java in testConvert1amTo1(String time) und Implementierung dieser Methode sieht die Klasse TestUmrechnungTimeZeit.java nun so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } } In der Testmethode erzeugen wir uns also zun\u00e4chst ein Objekt von UmrechnungTimeZeit , damit wir die Objektmethode convert() \u00fcberhaupt aufrufen k\u00f6nnen (Zeile 9 ). Dann rufen wir die convert() -Methode auf und \u00fcbergeben ihr den String \"1:00 am\" . Das Ergebnis der Methode wird in der Variablen zeit gespeichert (Zeile 12 ). Dann vergleichen wir das tats\u00e4chliche Ergebnis ( zeit ) mit dem erwarteten Ergebnis ( \"1:00\" ) und wollen, dass beide gleich sind ( assertEquals() ). Somit haben wir einen m\u00f6glichst kleinen iterativen Schritt hin zur fertigen Implementierung als Test beschrieben. Unsere n\u00e4chste Aufgabe ist nun, m\u00f6glichst wenig Programmcode zu schreiben, so dass der Test genau erf\u00fcllt wird. Diese Aufgabe erledigen wir auf ganz simple Weise, indem unsere convert() -Methode einfach den String \"1:00\" zur\u00fcckgibt. UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return \"1:00\" ; } } Das erscheint uns auf den ersten Blick v\u00f6llig sinnlos - und das ist es nat\u00fcrlich irgendwie auch. Aber wir erinnern uns: wir wollen m\u00f6glichst wenig Programmcode schreiben, so dass der Test genau erf\u00fcllt wird. Und das machen wir hier. Wenn wir nun unsere Testklasse ausf\u00fchren, dann sehen wir: Auf der linken Seite ist nun ein gr\u00fcner Balken zu sehen, d.h. alle unsere Tests (bis jetzt haben wir nur einen) sind korrekt. Unsere Methode convert() arbeitet in Bezug auf unsere Tests korrekt. Nun f\u00fcgen wir einen zweiten Test hinzu. Dazu k\u00f6nnen wir die Methode testConvert1amTo1() einfach kopieren. Die neue Methode nennen wir testConvert1amTo1() , da wir nun testen wollen, ob unsere Methode auch den String \"2:00 am\" korrekt nach \"2:00\" umwandelt. Mit diesem Test beherzigen wir das Prinzip, den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test zu beschreiben. Dieser m\u00f6glichst kleine Schritt ist f\u00fcr uns der Schritt von \"1:00 am\" nach \"2:00 am\" . Die neue Testmethode sieht so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } @Test void testConvert2amTo2 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"2:00 am\" ); // verification --> then assertEquals ( zeit , \"2:00\" ); } } Wenn wir die Testklasse nun ausf\u00fchren, ohne die convert() -Methode zu \u00e4ndern, erhalten wir folgendes Bild: Der Balken im JUnit -Fenster ist rot. Darunter wird uns angegeben, dass der Testfall testConvert1amTo1() immer noch korrekt ist (gr\u00fcner Haken), aber der Testfall testConvert2amTo2() ist gescheitert (blaues Kreuz). Im Editorfenster ist rot unterlegt, welche Assertion gescheitert ist ( assertEquals(zeit, \"2:00\"); ). Wir brauchen nun also eine Idee, wie wir die convert() -Methode anpassen k\u00f6nnen, so dass beide Testf\u00e4lle korrekt ausgef\u00fchrt werden. Wir versuchen es mit der Idee, einfach die ersten vier Zeichen des \u00fcbergebenen Strings time zur\u00fcckzugeben: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return time . substring ( 0 , 4 ); } } Wenn wir nun unsere Testklasse ausf\u00fchren, dann sind beide Testf\u00e4lle korrekt. Auf diese Art und Weise entwickeln wir nach und nach eine Implementierung der convert() -Methode. Dazu f\u00fcgen wir nach und nach immer weitere Testf\u00e4lle unserer Testklasse hinzu. Mindestens noch f\u00fcr folgende F\u00e4lle: time erwartetes Ergebnis \"1:15 am\" \"1:15\" \"11:00 am\" \"11:00\" \"11:15 am\" \"11:15\" \"1:00 pm\" \"13:00\" \"2:00 pm\" \"14:00\" \"1:15 pm\" \"13:15\" \"11:00 pm\" \"23:00\" \"11:15 pm\" \"23:15\" \"12:00 am\" \"0:00\" \"12:01 am\" \"0:01\" \"12:00 pm\" \"12:00\" \"12:01 pm\" \"12:01\" \"12:00 noon\" \"12:00\" \"12:00 midnight\" \"0:00\" Das Auswahl der Testwerte ist ganz offensichtlich ein wichtiges Thema und bestimmt die Korrektheit der sp\u00e4teren Implementierung mit. Es ist wichtig, keinen Testfall zu vergessen. Leider gibt es daf\u00fcr keine formalen Regeln, sondern nur intuitive Vorgaben. Es wird immer versucht, \"Grenzwerte\" zu ermitteln, um wirklich alle Testf\u00e4lle abzudecken. Quellcode aus dem Video \u00b6 Im Video \u00fcber JUnit wurde folgender Quellcode erzeugt: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package videos.video4 ; import static org.junit.jupiter.api.Assertions.assertEquals ; import org.junit.jupiter.api.Test ; public class UmrechnungTimeZeit { public String convert ( String time ) { final int LAST_THREE_CHARS = 3 ; // \" pm\" or \" am\" if ( time . endsWith ( \"am\" )) { return time . substring ( 0 ,( time . length () - LAST_THREE_CHARS )); } else // ends with pm { final int DIFFERENCE_BETWEEN_H_TO_HH = 12 ; int hourInt = this . getHoursInt ( time ); hourInt += DIFFERENCE_BETWEEN_H_TO_HH ; String minutes = this . getMinutesStr ( time ); String zeit = hourInt + \":\" + minutes ; return zeit ; } } String getHoursStr ( String time ) { String [] allStr = time . split ( \":\" ); return allStr [ 0 ] ; } String getMinutesStr ( String time ) { final int FIRST_TWO_CHARS = 2 ; String [] allStr = time . split ( \":\" ); String afterDouble = allStr [ 1 ] ; String minutesStr = afterDouble . substring ( 0 , FIRST_TWO_CHARS ); return minutesStr ; } int getHoursInt ( String time ) { String hoursStr = this . getHoursStr ( time ); int hoursInt = Integer . valueOf ( hoursStr ); return hoursInt ; } } UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 package videos.video4 ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class UmrechnungTimeZeitTest { @Test void testConvert1amTo1 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 am\" ); // than (verification) assertEquals ( zeit , \"1:00\" , \"1:00 am to 1:00 not working\" ); } @Test void testConvert2amTo2 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"2:00 am\" ); // than (verification) assertEquals ( zeit , \"2:00\" , \"2:00 am to 2:00 not working\" ); } @Test void testConvert9amTo9 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"9:00 am\" ); // than (verification) assertEquals ( \"9:00\" , zeit ); } @Test void testConvert10amTo10 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"10:00 am\" ); // than (verification) assertEquals ( \"10:00\" , zeit ); } @Test void testConvert1115amTo1115 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:15 am\" ); // than (verification) assertEquals ( \"11:15\" , zeit ); } @Test void testConvert1pmTo13 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 pm\" ); // than (verification) assertEquals ( \"13:00\" , zeit ); } @Test void testConvert3pmTo15 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"3:00 pm\" ); // than (verification) assertEquals ( \"15:00\" , zeit ); } @Test void testConvert545pmTo1745 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"5:45 pm\" ); // than (verification) assertEquals ( \"17:45\" , zeit ); } @Test void testConvert11pmTo23 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:00 pm\" ); // than (verification) assertEquals ( \"23:00\" , zeit ); } @Test void testGetHoursStr11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"11\" , hour ); } @Test void testGetHoursStr1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"1\" , hour ); } @Test void testGetHoursInt1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"1:00 pm\" ); // than (verification) assertEquals ( 1 , hours ); } @Test void testGetHoursInt11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"11:00 pm\" ); // than (verification) assertEquals ( 11 , hours ); } @Test void testGetMinutes1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } @Test void testGetMinutes11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } } module-info.java module SoSe2021 { requires java . desktop ; requires org . junit . jupiter . api ; } Annotationen \u00b6 Neben den Assertions gibt es auch noch Annotationen , die beim Testen eine Rolle spielen. Eine Annotation haben wir bereits verwendet: @Test . Hier einen \u00dcberblick \u00fcber die h\u00e4ufigsten Annotationen: Annotation Beschreibung @Test public void method() Die Methode ist eine Testmethode @BeforeEach public void method() Die Methode wird vor jedem Test ausgef\u00fchrt @AfterEach public void method() Die Methode wird nach jedem Test ausgef\u00fchrt @BeforeAll public static void method() Die Methode wird einmalig ausgef\u00fchrt bevor die Tests starten (static!) @AfterAll public static void method() Die Methode wird einmalig ausgef\u00fchrt nachdem die Tests gelaufen sind Ein Beispiel \u00b6 Wir betrachten die Klasse Power mit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class Power { private int base ; private int exp ; public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public double value () { double value = 1.0 ; if ( exp > 0 ) { for ( int i = 0 ; i < exp ; i ++ ) { value *= base ; } } else { for ( int i = 0 ; i <- exp ; i ++ ) { value *= base ; } value = 1.0 / value ; } return value ; } @Override public String toString () { return \"(\" + this . base + \"^\" + this . exp + \")\" ; } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Power p = ( Power ) o ; return ( this . base == p . base && this . exp == p . exp ); } @Override public int hashCode () { return 7 * this . base + 11 * this . exp ; } } F\u00fcr diese Klasse erstellen wir eine Testklasse, die neben der Annotation @Test auch die Annotationen @BeforeAll und @BeforeEach exemplarisch verwendet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; class PowerTest { static Power p1 , p2 , p3 , p4 ; static int testnr = 1 ; @BeforeAll public static void setup () { p1 = new Power ( 2 , 3 ); p2 = new Power ( 2 , 3 ); p3 = new Power ( - 2 , 3 ); p4 = new Power ( 2 , - 3 ); } @BeforeEach public void printBeforeTests () { System . out . printf ( \"%n %n --------------- Test %d ------------ %n\" , testnr ); p1 . print (); p2 . print (); testnr ++ ; } @Test void testToString () { String s = p1 . toString (); assertEquals ( \"(2^3)\" , s , \"Strings are not equal!\" ); } @Test void testPower () { assertNotNull ( p1 , \"no Power object\" ); } @Test void testValue () { double value = p1 . value (); assertEquals ( value , 8.0 , \"2^3 should be 8.0\" ); } @Test public void testEqualsObject () { assertTrue ( p1 . equals ( p2 ), \" 2^3 should be equal to 2^3!\" ); } } Diese Testklasse deckt nat\u00fcrlich viel zu wenige Testf\u00e4lle ab, aber es geht hier nur ums Prinzip. F\u00fchren Sie die Testklasse aus und beobachten Sie dabei auch die Konsole. Vor jeden Test ( @BeforeEach ) gibt es eine Ausgabe auf die Konsole. Bevor irgendein Test ( @Test ) ausgef\u00fchrt wird ( @BeforeAll ) werden verschiedene Objekte der Klasse Power erzeugt. In den Testf\u00e4llen werden aber nur p1 und p2 verwendet. Das m\u00fcsste nat\u00fcrlich noch deutlich erweitert werden. Success Wir haben JUnit-Testing kennengelernt. Unit-Tests sind eine gute M\u00f6glichkeit, einzelne Methoden automatisiert zu testen. Mithilfe von Unit-Tests k\u00f6nnen wir Code so entwicklen, dass alle formulierten Tests erfolgreich bestehen. Werden erst die Tests geschrieben und gegen die Tests implementiert, wird dieses Programmierverfahren Test-driven development genannt. Unit-Tests k\u00f6nnen aber auch verwendet werden, um existierenden Code zu testen. JUnit ist das Framework f\u00fcr Java-Unit-Tests. Ausf\u00fchrliche Informationen zu JUnit sind hier zu finden.","title":"JUnit-Tests"},{"location":"junit/#junit-tests","text":"Testen von Programmen ist wichtig. Ohne Testen ist es kaum m\u00f6glich, Fehler in Programmen zu entdecken. Bis jetzt haben wir unsere Programme immer durch reines Anwenden getestet, d.h. wir haben die implementierten Methoden aufgerufen und ihnen unterschiedliche Parameterwerte \u00fcbergeben. Wir werden das jetzt \u00e4ndern und nutzen daf\u00fcr JUnit .","title":"JUnit-Tests"},{"location":"junit/#allgemeines-zum-unit-testen","text":"Der ber\u00fchmte Informatiker Edsger W. Dijkstra hat \u00fcber das Testen gesagt: Durch Testen kann man stets nur die Anwesenheit, nie aber die Abwesenheit von Fehlern beweisen Das bedeutet, wir k\u00f6nnen durch das Testen Fehler finden. Wenn wir aber keine finden, dann wissen wir nicht, ob das Programm dann auch keine Fehler mehr enth\u00e4lt. Es ist leider nicht m\u00f6glich, grunds\u00e4tzlich die Fehlerfreiheit von Programmen zu pr\u00fcfen. Aber das Testen stellt ein wichtiges Werkzeug dar, um Fehler zu entdecken. Es gibt verschiedene Arten von Tests: In der Abbildung erkennen wir, dass die Unit-tests, die wir hier kennenlernen wollen, am besten automatisierbar, am h\u00e4ufigsten und am einfachsten sind. Mit Unit-Tests k\u00f6nnen wir Methoden und Klassen testen, wobei wir die Tests implementieren. Die Idee ist, dass wir funktionale Einzelteile eines Programms separat und isoliert vom Rest auf ihre Korrektheit hin \u00fcberpr\u00fcfen. Wir versuchen extra, so wenig wie m\u00f6glich die Effekte anderer Funktionalit\u00e4ten bzw. Komponenten in die Tests einflie\u00dfen zu lassen. Das erfolgt dann in den Komponenten- bzw. Integrationstests. Das hat zwei Vorteile: einerseits ist der zu pr\u00fcfende Funktionsumfang \u00fcberschaubar und andererseits k\u00f6nnen diese Unit-Tests leicht automatisiert ausgef\u00fchrt werden. Es gibt, wie bereits eingangs erw\u00e4hnt, keine Garantie von Fehlerfreiheit. Ein Nachteil der Unit-Tests besteht darin, dass sie schwierig f\u00fcr Methoden zu gestalten sind, in denen es Abh\u00e4ngigkeiten von der Laufzeitumgebung oder anderen Komponenten gibt.","title":"Allgemeines zum (Unit-)Testen"},{"location":"junit/#test-driven-development","text":"Unit Tests k\u00f6nnen entweder nach Erstellung des Programmcodes geschrieben werden, um diesen nachtr\u00e4glich zu testen oder vor Erstellung des Programmcodes. Wenn wir die Tests vor der Erstellung des Programmcodes erstellen, dann beschreiben wir mit den Tests die Anforderungen an den zu erstellenden Code. Wir werden hier lernen, wie die Erstellung der Tests und des Programmcodes Hand-in_Hand erfolgen k\u00f6nnen. Diese Vorgehensweise nennt sich Test-driven developement (TDD) . Wir werden, wie \u00fcblich, TDD anhand eines Beispiels einf\u00fchren. Unser Vorgehen l\u00e4sst sich wie folgt beschreiben: Wir schreiben einen Test, der die Anforderung f\u00fcr einen m\u00f6glichst kleinen iterativen Schritt bei der Erstellung des Programmcodes beschreibt. Wir schreiben m\u00f6glichst wenig Programmcode, so dass der Test genau erf\u00fcllt wird. Wir gehen wieder zu 1. und beschreiben den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test. Wir wiederholen 2. f\u00fcr den neuen Test usw. Die folgende Abbildung visualisiert das Vorgehen. Ausgangspunkt ist immer ein Test. Wir implementieren solange, bis dieser und alle vorher implementierten Tests erfolgreich durchlaufen werden. Dann schreiben wir einen weiteren Test und implementieren wieder so lange, bis dieser und alle vorher geschreibenen Tests erfolgreich durchlaufen werden. Dieses Vorgehen wird so lange wiederholt, so lange wir weitere Testf\u00e4lle hinzuf\u00fcgen k\u00f6nnen, die jeweils neue Anforderungen beschreiben. Zur Implementierung des Codes geh\u00f6rt auch das Refactoring, d.h. wir verbessern bisher geschriebenen Code durch neue Tests.","title":"Test-Driven Development"},{"location":"junit/#tdd-fur-einen-time-zeit-umrechner","text":"Angenommen, wir wollen einen einfachen Konverter erstellen, der eine Uhrzeit im 12-Stunden-Zeitsystem (mit am und pm ) in eine 24-Stundendarstellung umwandelt (von String nach String ). Im Web findet man einige Beispiel, z.B. hier . Dazu erstellen wir uns zun\u00e4chst eine Klasse UmrechnungTimeZeit.java , die die Methode convert() enth\u00e4lt. Diese Methode erwartet einen String mit einer 12-Stunden-Zeit time und gibt einen String zur\u00fcck, der die time im 24-Stundenformat darstellt. UmrechnungTimeZeit.java public class UmrechnungTimeZeit { public String convert ( String time ) { return \"\" ; } } Das ist unsere Klasse in der Augangssituation. Bevor wir anfangen, zu implemntieren, wollen wir uns zun\u00e4chst einen ersten einfachen Test schreiben, der uns eine erste Anforderung (einen ersten Testfall) beschreibt. Dazu w\u00e4hlen wir in Eclipse File --> New --> JUnit Test Case . Es erscheint folgendes Fenster: Wir w\u00e4hlen New JUnit Jupiter test aus und benennen unsere Testklasse TestUmrechnungTimeZeit und geben an, dass die Class under test die Klasse UmrechnungTimeZeit ist (Auswahl durch Browse... ). Wenn wir dann auf Finish klicken, erscheint: Das best\u00e4tigen wir mit OK . Es wird die TestUmrechnungTimeZeit.java erstellt, die so aussieht: TestUmrechnungTimeZeit.java import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void test () { fail ( \"Not yet implemented\" ); } } Sollten Fehler beim Import der junit.jupiter -Pakete angezeigt werden, dann m\u00fcssen Sie in Ihre module-info.java noch folgende Anweisung einf\u00fcgen: Einf\u00fcgen in die module-info.java requires org . junit . jupiter . api ;","title":"TDD f\u00fcr einen Time-Zeit-Umrechner"},{"location":"junit/#eine-junit-testklasse","text":"Die Klasse TestUmrechnungTimeZeit.java ist eine JUnit-Testklasse. Eine JUnit-Testklasse enth\u00e4lt keine main() -Methode, ist aber ausf\u00fchrbar. Sie enth\u00e4lt stattdessen Methoden, die mit @Test annotiert sind. Diese @Test -Methoden enthalten Zusicherungen (sogenannte Assertions ). Mit diesen Assertions geben Sie das erwartete Ergebnis des Testfalls an.","title":"Eine JUnit-Testklasse"},{"location":"junit/#assertions","text":"Es gibt unterschiedliche M\u00f6glichkeiten, das tats\u00e4chliche Ergebnis der Ausf\u00fchrung mit dem erwarteten Ergebnis zu vergleichen: Gleichheit, Ungleichheit, kleiner, gr\u00f6\u00dfer null , nicht null gleiche Objekte ( equals() ) Diese Vergleiche werden mittels Assertions durchgef\u00fchrt. Folgende Tabelle gibt einen \u00dcberblick \u00fcber einige der am meisten verwendeten Assertions an. Alle Assertions, die es gibt, finden Sie hier . Assertion Beschreibung fail(message) L\u00e4sst den Test scheitern (fail) mit Nachricht message . Wird genutzt, um zu \u00fcberpr\u00fcfen, ob Code unerreichbar ist oder bevor der Test implementiert ist. assertTrue(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond wahr ist oder scheitert mit Nachricht m assertFalse(cond,m) \u00dcberpr\u00fcft, ob Bedingung cond false ist oder scheitert mit Nachricht m assertEquals(a,b,m) \u00dcberpr\u00fcft, ob Parameter a und b gleich sind oder scheitert mit Nachricht m assertArrayEquals(a,b,m) \u00dcberpr\u00fcft, ob Inhalte der Arrays a und b gleich sind oder scheitert mit Nachricht m assertNull(o,m) \u00dcberpr\u00fcft, ob Object o==null ist oder scheitert mit Nachricht m assertNotNull(o,m) \u00dcberpr\u00fcft, ob Object o!=null ist oder scheitert mit Nachricht m assertSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1==o2 ist oder scheitert mit Nachricht m assertNotSame(o1,o2,m) \u00dcberpr\u00fcft, ob Objektreferenz o1!=o2 ist oder scheitert mit Nachricht m Derzeit verwenden wir in unserer Testklasse nur die Assertion fail() . Diese steht aber nur daf\u00fcr, dass wir diesen Test noch implementieren m\u00fcssen. Das machen wir jetzt.","title":"Assertions"},{"location":"junit/#eine-erste-testmethode-fur-unser-beispiel","text":"Zun\u00e4chst einmal schauen wir uns an, wie wir unsere Testklasse ausf\u00fchren. Dazu w\u00e4hlen wir in Eclipse unter Run --> Run As ... --> JUnit Test . Oder Sie w\u00e4hlen gleich den mittleren der gezeigten drei Buttons . Dann erhalten Sie folgendes Bild: Auf der linken Seite sehen Sie im JUnit -Reiter einen roten Querbalken. Dieser zeigt an, dass ein Test fehlgeschlagen ist. Im Editor-Fenster wird der fehlgeschlagene Test rot markiert. Es ist klar, dass der Test fehlschl\u00e4gt, denn das bezweckt ja die Assertion fail() . Links unten sieht man den Failure trace . Dort ist in der ertsen Zeile die Fehlermeldung Not yet implemented zu sehen - das ist die Nachricht, die der fail() -Assertion \u00fcbergeben wurde. Wir implementieren nun die erste Testmethode. Dazu benennen wir die Methode test() um in testConvert1amTo1() . In unserem ersten Test wollen wir \u00fcberpr\u00fcfen, ob unsere Methode convert(String time) korrekt arbeitet, wenn ihr der String 1:00 am \u00fcbergeben wird. Die Idee ist nun die folgende: wir definieren unsere Testmethode so, dass wir angeben, welches Ergebnis wir erwarten, wenn der String 1:00 am \u00fcbergeben wird. Wir erwarten das Ergebnis 1:00 . Generell sollte eine Testmethode in der folgenden Form aufgebaut sein: given (preperation) : gibt die Voraussetzungen des Tests an, z.B. die Erzeugung eines Objektes; bei uns: die Erzeugung eines UmrechnungTimeZeit -Objektes, when (execution) : beschreibt, was und wie ausgef\u00fchrt werden soll; bei uns: die Ausf\u00fchrung der Methode convert() mit dem Parameterwert \"1:00 am\" , then (verification) : beschreibt, wie sich das Ergebnis der Ausf\u00fchrung in Bezug auf das erwartete Ergebnis verhalten soll; bei uns: assertEquals(tatsaechlichesErgebnis, \"1:00\") . Nach Umbenennung der Methode test() in TestUmrechnungTimeZeit.java in testConvert1amTo1(String time) und Implementierung dieser Methode sieht die Klasse TestUmrechnungTimeZeit.java nun so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } } In der Testmethode erzeugen wir uns also zun\u00e4chst ein Objekt von UmrechnungTimeZeit , damit wir die Objektmethode convert() \u00fcberhaupt aufrufen k\u00f6nnen (Zeile 9 ). Dann rufen wir die convert() -Methode auf und \u00fcbergeben ihr den String \"1:00 am\" . Das Ergebnis der Methode wird in der Variablen zeit gespeichert (Zeile 12 ). Dann vergleichen wir das tats\u00e4chliche Ergebnis ( zeit ) mit dem erwarteten Ergebnis ( \"1:00\" ) und wollen, dass beide gleich sind ( assertEquals() ). Somit haben wir einen m\u00f6glichst kleinen iterativen Schritt hin zur fertigen Implementierung als Test beschrieben. Unsere n\u00e4chste Aufgabe ist nun, m\u00f6glichst wenig Programmcode zu schreiben, so dass der Test genau erf\u00fcllt wird. Diese Aufgabe erledigen wir auf ganz simple Weise, indem unsere convert() -Methode einfach den String \"1:00\" zur\u00fcckgibt. UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return \"1:00\" ; } } Das erscheint uns auf den ersten Blick v\u00f6llig sinnlos - und das ist es nat\u00fcrlich irgendwie auch. Aber wir erinnern uns: wir wollen m\u00f6glichst wenig Programmcode schreiben, so dass der Test genau erf\u00fcllt wird. Und das machen wir hier. Wenn wir nun unsere Testklasse ausf\u00fchren, dann sehen wir: Auf der linken Seite ist nun ein gr\u00fcner Balken zu sehen, d.h. alle unsere Tests (bis jetzt haben wir nur einen) sind korrekt. Unsere Methode convert() arbeitet in Bezug auf unsere Tests korrekt. Nun f\u00fcgen wir einen zweiten Test hinzu. Dazu k\u00f6nnen wir die Methode testConvert1amTo1() einfach kopieren. Die neue Methode nennen wir testConvert1amTo1() , da wir nun testen wollen, ob unsere Methode auch den String \"2:00 am\" korrekt nach \"2:00\" umwandelt. Mit diesem Test beherzigen wir das Prinzip, den n\u00e4chsten m\u00f6glichst kleinen iterativen Schritt durch einen Test zu beschreiben. Dieser m\u00f6glichst kleine Schritt ist f\u00fcr uns der Schritt von \"1:00 am\" nach \"2:00 am\" . Die neue Testmethode sieht so aus: TestUmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class TestUmrechnungTimeZeit { @Test void testConvert1amTo1 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"1:00 am\" ); // verification --> then assertEquals ( zeit , \"1:00\" ); } @Test void testConvert2amTo2 () { // preperation --> given UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // execution --> when String zeit = utz . convert ( \"2:00 am\" ); // verification --> then assertEquals ( zeit , \"2:00\" ); } } Wenn wir die Testklasse nun ausf\u00fchren, ohne die convert() -Methode zu \u00e4ndern, erhalten wir folgendes Bild: Der Balken im JUnit -Fenster ist rot. Darunter wird uns angegeben, dass der Testfall testConvert1amTo1() immer noch korrekt ist (gr\u00fcner Haken), aber der Testfall testConvert2amTo2() ist gescheitert (blaues Kreuz). Im Editorfenster ist rot unterlegt, welche Assertion gescheitert ist ( assertEquals(zeit, \"2:00\"); ). Wir brauchen nun also eine Idee, wie wir die convert() -Methode anpassen k\u00f6nnen, so dass beide Testf\u00e4lle korrekt ausgef\u00fchrt werden. Wir versuchen es mit der Idee, einfach die ersten vier Zeichen des \u00fcbergebenen Strings time zur\u00fcckzugeben: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 public class UmrechnungTimeZeit { public String convert ( String time ) { return time . substring ( 0 , 4 ); } } Wenn wir nun unsere Testklasse ausf\u00fchren, dann sind beide Testf\u00e4lle korrekt. Auf diese Art und Weise entwickeln wir nach und nach eine Implementierung der convert() -Methode. Dazu f\u00fcgen wir nach und nach immer weitere Testf\u00e4lle unserer Testklasse hinzu. Mindestens noch f\u00fcr folgende F\u00e4lle: time erwartetes Ergebnis \"1:15 am\" \"1:15\" \"11:00 am\" \"11:00\" \"11:15 am\" \"11:15\" \"1:00 pm\" \"13:00\" \"2:00 pm\" \"14:00\" \"1:15 pm\" \"13:15\" \"11:00 pm\" \"23:00\" \"11:15 pm\" \"23:15\" \"12:00 am\" \"0:00\" \"12:01 am\" \"0:01\" \"12:00 pm\" \"12:00\" \"12:01 pm\" \"12:01\" \"12:00 noon\" \"12:00\" \"12:00 midnight\" \"0:00\" Das Auswahl der Testwerte ist ganz offensichtlich ein wichtiges Thema und bestimmt die Korrektheit der sp\u00e4teren Implementierung mit. Es ist wichtig, keinen Testfall zu vergessen. Leider gibt es daf\u00fcr keine formalen Regeln, sondern nur intuitive Vorgaben. Es wird immer versucht, \"Grenzwerte\" zu ermitteln, um wirklich alle Testf\u00e4lle abzudecken.","title":"Eine erste Testmethode f\u00fcr unser Beispiel"},{"location":"junit/#quellcode-aus-dem-video","text":"Im Video \u00fcber JUnit wurde folgender Quellcode erzeugt: UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package videos.video4 ; import static org.junit.jupiter.api.Assertions.assertEquals ; import org.junit.jupiter.api.Test ; public class UmrechnungTimeZeit { public String convert ( String time ) { final int LAST_THREE_CHARS = 3 ; // \" pm\" or \" am\" if ( time . endsWith ( \"am\" )) { return time . substring ( 0 ,( time . length () - LAST_THREE_CHARS )); } else // ends with pm { final int DIFFERENCE_BETWEEN_H_TO_HH = 12 ; int hourInt = this . getHoursInt ( time ); hourInt += DIFFERENCE_BETWEEN_H_TO_HH ; String minutes = this . getMinutesStr ( time ); String zeit = hourInt + \":\" + minutes ; return zeit ; } } String getHoursStr ( String time ) { String [] allStr = time . split ( \":\" ); return allStr [ 0 ] ; } String getMinutesStr ( String time ) { final int FIRST_TWO_CHARS = 2 ; String [] allStr = time . split ( \":\" ); String afterDouble = allStr [ 1 ] ; String minutesStr = afterDouble . substring ( 0 , FIRST_TWO_CHARS ); return minutesStr ; } int getHoursInt ( String time ) { String hoursStr = this . getHoursStr ( time ); int hoursInt = Integer . valueOf ( hoursStr ); return hoursInt ; } } UmrechnungTimeZeit.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 package videos.video4 ; import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.Test ; class UmrechnungTimeZeitTest { @Test void testConvert1amTo1 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 am\" ); // than (verification) assertEquals ( zeit , \"1:00\" , \"1:00 am to 1:00 not working\" ); } @Test void testConvert2amTo2 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"2:00 am\" ); // than (verification) assertEquals ( zeit , \"2:00\" , \"2:00 am to 2:00 not working\" ); } @Test void testConvert9amTo9 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"9:00 am\" ); // than (verification) assertEquals ( \"9:00\" , zeit ); } @Test void testConvert10amTo10 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"10:00 am\" ); // than (verification) assertEquals ( \"10:00\" , zeit ); } @Test void testConvert1115amTo1115 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:15 am\" ); // than (verification) assertEquals ( \"11:15\" , zeit ); } @Test void testConvert1pmTo13 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"1:00 pm\" ); // than (verification) assertEquals ( \"13:00\" , zeit ); } @Test void testConvert3pmTo15 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"3:00 pm\" ); // than (verification) assertEquals ( \"15:00\" , zeit ); } @Test void testConvert545pmTo1745 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"5:45 pm\" ); // than (verification) assertEquals ( \"17:45\" , zeit ); } @Test void testConvert11pmTo23 () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String zeit = utz . convert ( \"11:00 pm\" ); // than (verification) assertEquals ( \"23:00\" , zeit ); } @Test void testGetHoursStr11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"11\" , hour ); } @Test void testGetHoursStr1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String hour = utz . getHoursStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"1\" , hour ); } @Test void testGetHoursInt1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"1:00 pm\" ); // than (verification) assertEquals ( 1 , hours ); } @Test void testGetHoursInt11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) int hours = utz . getHoursInt ( \"11:00 pm\" ); // than (verification) assertEquals ( 11 , hours ); } @Test void testGetMinutes1pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"1:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } @Test void testGetMinutes11pm () { // given (preperation) UmrechnungTimeZeit utz = new UmrechnungTimeZeit (); // when (execution) String minutes = utz . getMinutesStr ( \"11:00 pm\" ); // than (verification) assertEquals ( \"00\" , minutes ); } } module-info.java module SoSe2021 { requires java . desktop ; requires org . junit . jupiter . api ; }","title":"Quellcode aus dem Video"},{"location":"junit/#annotationen","text":"Neben den Assertions gibt es auch noch Annotationen , die beim Testen eine Rolle spielen. Eine Annotation haben wir bereits verwendet: @Test . Hier einen \u00dcberblick \u00fcber die h\u00e4ufigsten Annotationen: Annotation Beschreibung @Test public void method() Die Methode ist eine Testmethode @BeforeEach public void method() Die Methode wird vor jedem Test ausgef\u00fchrt @AfterEach public void method() Die Methode wird nach jedem Test ausgef\u00fchrt @BeforeAll public static void method() Die Methode wird einmalig ausgef\u00fchrt bevor die Tests starten (static!) @AfterAll public static void method() Die Methode wird einmalig ausgef\u00fchrt nachdem die Tests gelaufen sind","title":"Annotationen"},{"location":"junit/#ein-beispiel","text":"Wir betrachten die Klasse Power mit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class Power { private int base ; private int exp ; public Power ( int base , int exp ) { this . base = base ; this . exp = exp ; } public double value () { double value = 1.0 ; if ( exp > 0 ) { for ( int i = 0 ; i < exp ; i ++ ) { value *= base ; } } else { for ( int i = 0 ; i <- exp ; i ++ ) { value *= base ; } value = 1.0 / value ; } return value ; } @Override public String toString () { return \"(\" + this . base + \"^\" + this . exp + \")\" ; } public void print () { System . out . println ( this . toString ()); } @Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; Power p = ( Power ) o ; return ( this . base == p . base && this . exp == p . exp ); } @Override public int hashCode () { return 7 * this . base + 11 * this . exp ; } } F\u00fcr diese Klasse erstellen wir eine Testklasse, die neben der Annotation @Test auch die Annotationen @BeforeAll und @BeforeEach exemplarisch verwendet. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import static org.junit.jupiter.api.Assertions.* ; import org.junit.jupiter.api.BeforeAll ; import org.junit.jupiter.api.BeforeEach ; import org.junit.jupiter.api.Test ; class PowerTest { static Power p1 , p2 , p3 , p4 ; static int testnr = 1 ; @BeforeAll public static void setup () { p1 = new Power ( 2 , 3 ); p2 = new Power ( 2 , 3 ); p3 = new Power ( - 2 , 3 ); p4 = new Power ( 2 , - 3 ); } @BeforeEach public void printBeforeTests () { System . out . printf ( \"%n %n --------------- Test %d ------------ %n\" , testnr ); p1 . print (); p2 . print (); testnr ++ ; } @Test void testToString () { String s = p1 . toString (); assertEquals ( \"(2^3)\" , s , \"Strings are not equal!\" ); } @Test void testPower () { assertNotNull ( p1 , \"no Power object\" ); } @Test void testValue () { double value = p1 . value (); assertEquals ( value , 8.0 , \"2^3 should be 8.0\" ); } @Test public void testEqualsObject () { assertTrue ( p1 . equals ( p2 ), \" 2^3 should be equal to 2^3!\" ); } } Diese Testklasse deckt nat\u00fcrlich viel zu wenige Testf\u00e4lle ab, aber es geht hier nur ums Prinzip. F\u00fchren Sie die Testklasse aus und beobachten Sie dabei auch die Konsole. Vor jeden Test ( @BeforeEach ) gibt es eine Ausgabe auf die Konsole. Bevor irgendein Test ( @Test ) ausgef\u00fchrt wird ( @BeforeAll ) werden verschiedene Objekte der Klasse Power erzeugt. In den Testf\u00e4llen werden aber nur p1 und p2 verwendet. Das m\u00fcsste nat\u00fcrlich noch deutlich erweitert werden. Success Wir haben JUnit-Testing kennengelernt. Unit-Tests sind eine gute M\u00f6glichkeit, einzelne Methoden automatisiert zu testen. Mithilfe von Unit-Tests k\u00f6nnen wir Code so entwicklen, dass alle formulierten Tests erfolgreich bestehen. Werden erst die Tests geschrieben und gegen die Tests implementiert, wird dieses Programmierverfahren Test-driven development genannt. Unit-Tests k\u00f6nnen aber auch verwendet werden, um existierenden Code zu testen. JUnit ist das Framework f\u00fcr Java-Unit-Tests. Ausf\u00fchrliche Informationen zu JUnit sind hier zu finden.","title":"Ein Beispiel"},{"location":"maps/","text":"Maps \u00b6 Maps sind auch Collections. Maps sind Mengen von Schl\u00fcssel-Werte-Paaren. Wir k\u00f6nnen uns Maps als zweispaltige Tabellen vorstellen, in denen die linke Spalte die Schl\u00fcssel ( keys ) enth\u00e4lt und die rechte Spalte die Werte ( values ). Die Schl\u00fcssel in einer Map sind immer eindeutig, d.h. keine zwei Schl\u00fcssel in einer Map sind gleich. Tats\u00e4chlich handelt es sich bei der Menge der Schl\u00fcssel um eine Set . Obwohl Maps Collections sind, wurde f\u00fcr sie nicht das Interface Collection implementiert, so wie f\u00fcr Listen und Mengen, sondern ein eigenes Interface Map . F\u00fcr Interessierte lohnt sich vielleicht auch ein Blick in die Collections Framework Documentation und das Collections Framework Tutorial . Statt add() und addAll() hier put() und putAll() \u00b6 Da nicht das Collections -Interface f\u00fcr Maps implementiert wurde, erfolgt das Hinzuf\u00fcgen eines Schl\u00fcssel-Werte-Paares zu einer Map leider auch nicht \u00fcber add() bzw. das Hinzuf\u00fcgen einer Collection nicht \u00fcber addAll() , sondern \u00fcber put(K key, V value) und putAll(Map m) . K ist dabei ein Platzhalter f\u00fcr den Typ der Schl\u00fcssel und V ein Platzhalter f\u00fcr den Typ der Werte. Typ einer Map und Typ eines Schl\u00fcssel-Werte-Paares \u00b6 Eine Map wird also mit zwei Typen typisiert: Map<K, V> wobei K den Typ der Schl\u00fcssel und V den Typ der Werte definiert. Der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Das sieht f\u00fcr uns nat\u00fcrlich auch erstmal ungew\u00f6hnlich aus. Entry ist eine innere Klasse in der Klasse Map (tats\u00e4chlich sind beides Interfaces). Wir nehmen das erstmal einfach so hin und merken uns: der (typisierte) Typ einer Map ist Map<K,V> und der (typisierte) Typ jedes einzelnen Schl\u00fcssel-Werte-Paares in dieser Map ist Map.Entry<K,V> . Statt iterator() hier entrySet() \u00b6 Die Objektmethode iterator() gibt es f\u00fcr Map leider auch nicht. Stattdessen wird hier die Methode entrySet() verwendet. Da es sich bei einer Map um eine Set von lauter Schl\u00fcssel-Werte-Paaren (jeweils Typ Map.Entry<K,V> ) handelt, liefert entrySet() eine Set<Map.Entry<K,V>> zur\u00fcck. Lassen Sie sich von dieser kryptischen Schreibweise nicht abschrecken! Zur\u00fcckgegeben wird eine Set . Diese ist typisiert und zwar mit dem Typ Map.Entry , welches der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist. Map.Entry ist selbst typisiert, n\u00e4mlich mit dem Typ der Schl\u00fcssel K und dem Typ der Werte V . F\u00fcr K und V werden bei Verwendung konkrete Typen eingesetzt. Hier sind es zun\u00e4chst nur Platzhalter. Klassenbaum f\u00fcr Map \u00b6 Der Klassenbaum f\u00fcr Map hat \u00c4hnlichkeiten zum Klassenbaum f\u00fcr Collection . Wir finden hier wieder gr\u00fcne (Interfaces), rote (abstrakte Klassen) und blaue (konkrete Klassen) Felder. Auch hier ist es wieder so, dass wir Map als Typ f\u00fcr eine Map verwenden, aber f\u00fcr die Erzeugung konkreter Objekte die Klassen EnumMap , HashMap und TreeMap verwenden. Die am h\u00e4ufigsten verwendete Klasse ist HashMap , da sie am performantesten arbeitet. Sobald Reihenfolge/Sortierung eine Rolle spielt, wird TreeMap verwendet. Erstes Beispiel \u00b6 Wir betrachten ein erstes Beispiel. Wir erstellen eine HashMap und f\u00fcgen vier Eintr\u00e4ge hinzu: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashMap ; import java.util.Map ; public class Maps { public static void main ( String [] args ) { Map < String , Double > m = new HashMap <> (); m . put ( \"s0512345\" , 1.7 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0587654\" , 2.3 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0512345\" , 2.7 ); // Schluessel existiert bereits --> Wert geaendert m . put ( \"s0555555\" , 3.0 ); // neues Schluessel-Werte-Paar hinzugefuegt } } In Zeile 8 wird unsere Map erzeugt. Die Referenzvariable auf die Map hei\u00dft m . Die Schl\u00fcssel sind vom Typ String und die Werte sind vom Typ Double . Das konkrete Objekt wird durch den Aufruf des Konstruktors der Klasse HashMap erzeugt. In Zeile 9 f\u00fcgen wir mithilfe der put() -Methode ein neues Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0512345\" , der Wert ( value ) ist 1.7 . Beachten Sie, dass hier ein Auto-Boxing des double -Wertes 1.7 in ein Double stattfindet. In Zeile 10 f\u00fcgen wir mithilfe der put() -Methode ein weiters Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0587654\" , der Wert ( value ) ist 2.3 (erneut Auto-Boxing ). In Zeile 11 wird erneut die put() -Methode aufgerufen. Der Schl\u00fcssel \"s0512345\" existiert jedoch bereits. Deshalb wird nur der Wert ge\u00e4ndert. Aus dem alten Wert 1.7 wird nun 2.7 . Die Map enth\u00e4lt nach dieser Anweisung (noch nur) zwei Eintr\u00e4ge. In Zeile 12 f\u00fcgen wir mithilfe der put() -Methode ein weiters Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0555555\" , der Wert ( value ) ist 3.0 (erneut Auto-Boxing ). Nach diesen Anweisungen sieht unsere Map also wie folgt aus (die \u00dcberschriften der Tabelle dienen nur der Orientierung): Die folgende Abbildung zeigt die Methoden, um Zugriff auf die Werte, Schl\u00fcssel und alle Eintr\u00e4ge zu erhalten: Die Anwendung dieser Methoden auf unsere Map m zeigen die folgenden Anweisungen: 1 2 3 Set < String > keys = m . keySet (); // Menge aller Schluessel Collection < Double > values = m . values (); // Collection aller Werte Set < Map . Entry < String , Double >> entries = m . entrySet (); // Menge aller Schluessel-Werte-Paare die Objektmethode keySet() liefert die Menge aller Schl\u00fcssel zur\u00fcck; R\u00fcckgabetyp ist Set<K> , die Objektmethode values() liefert eine Collection aller Werte zur\u00fcck; R\u00fcckgabetyp ist Collection<V> , die Objektmethode entrySet() liefert die Menge aller Schl\u00fcssel-Werte-Paare zur\u00fcck; R\u00fcckgabetyp ist Set<Map.Entry<K,V>> Durch eine Map laufen \u00b6 Um alle Schl\u00fcssel-Werte-Paare einer Map zu extrahieren, k\u00f6nnen wir, wie bereits erw\u00e4hnt, die Methode entrySet() verwenden. F\u00fcr den R\u00fcckgabetyp Map.Entry<K,V> stehen uns zwei weitere Objektmethoden zur Verf\u00fcgung: getKey() liefert den Schl\u00fcssel des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist K , getValue() liefert den Wert des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist V . Wir betrachten f\u00fcr unsere Map m ein Beispiel: 1 2 3 4 for ( Map . Entry < String , Double > eintrag : m . entrySet ()) { System . out . println ( eintrag . getKey () + \" : \" + eintrag . getValue ()); } - In Zeile 1 wird die Methode m.entrySet() aufgerufen, diese gibt eine Set<Map.Entry<String, Double>> zur\u00fcck. Jeder einzelne Eintrag in dieser Set ist also vom Typ Map.Entry<String,Double> . Deshalb verwenden wir diesen Typ f\u00fcr unsere Variable eintrag . Wir nutzen hier also erneut die for-each -Schleife, um durch eine Set zu laufen. - In Zeile 3 verwenden wir die Objektmethoden getKey() und getValue() , die uns von Map.Entry zur Verf\u00fcgung gestellt werden. getKey() gibt uns hier einen String zur\u00fcck (den Schl\u00fcssel) und getValue() gibt hier ein Double zur\u00fcck (den Wert). Hier erfolgt eine automatische Konvertierung von Double nach String (impliziter Aufruf von toString() f\u00fcr Double ). Es erfolgt folgende Ausgabe: s0512345 : 2 .7 s0555555 : 3 .0 s0587654 : 2 .3 Wir sehen also, dass die Reihenfolge des Einf\u00fcgens der Elemente nicht gewahrt bleibt. Die Schl\u00fcssel werden auch nicht sortiert, das sieht hier nur so aus. Wir probieren auch noch die Objektmethoden keySet() und value() aus, die f\u00fcr eine Map zur Verf\u00fcgung stehen: for ( String schluessel : m . keySet ()) { System . out . println ( \"key : \" + schluessel ); } erzeugt: key : s0512345 key : s0555555 key : s0587654 und for ( Double wert : m . values ()) { System . out . println ( \"value : \" + wert . toString ()); // toString() wuerde auch implizit aufgerufen } erzeugt: value : 2 .7 value : 3 .0 value : 2 .3 \u00dcbung Was wird ausgegeben? Map < String , String > accounts = new HashMap <> (); accounts . put ( \"anton\" , \"anton@email.de\" ); accounts . put ( \"berta\" , \"berta@email.de\" ); accounts . put ( \"caesar\" , \"caesar@email.de\" ); accounts . put ( \"anton\" , \"antonius@email.de\" ); // Iteration ueber alle Eintraege (Map.Entry) der Map for ( Map . Entry < String , String > entry : accounts . entrySet ()) { System . out . println ( \"Account : \" + entry . getKey () + \" E-Mail : \" + entry . getValue ()); } Zusammenfassung Maps \u00b6 Maps speichern Referenztypen als Schl\u00fcssel und Werte Maps werden typisiert mit K (Platzhalter f\u00fcr den Referenztyp des Schl\u00fcssels) und V (Platzhalter f\u00fcr den Referenztyp des Wertes) Maps enthalten eindeutige Zuordnungen von einem Wert zu einem Schl\u00fcssel (aber nicht umgekehrt) der Zugriff auf alle Eintr\u00e4ge/Schl\u00fcssel/Werte erfolgt \u00fcber Sets/Collection der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Hier noch ein \u00dcberblick \u00fcber die wichtigsten Objektmethoden f\u00fcr eine Map . Weitere Methoden finden Sie hier . Objektmethode Beschreibung V get(K key) Gibt den Wert zum Schl\u00fcssel key zur\u00fcck. Ist der Schl\u00fcssel key nicht in der Map enthalten, wird null zur\u00fcckgegeben. V put(K key, V value) F\u00fcgt einen neuen Eintrag mit dem Schl\u00fcssel key und dem Wert value in die Map ein. Wenn ein Eintrag f\u00fcr Schl\u00fcssel key bereits existiert, wird der value \u00fcberschrieben . void putAll(Map m) F\u00fcgt alle Element der Map m in die Map ein. Wenn ein Eintrag f\u00fcr einen Schl\u00fcssel bereits existiert, wird er \u00fcberschrieben . void clear() Entfernt alle Elemente aus der Map. boolean containsKey(Object k) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Schl\u00fcssel k in der Map gibt. Der Vergleich der Schl\u00fcssel mit dem Objekt k erfolgt mit der equals() -Methode. boolean containsValue(Object v) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Wert v in der Map gibt. Der Vergleich der Werte mit dem Objekt v erfolgt mit der equals() -Methode. boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Map befinden. V remove(Object key) Entfernt den Eintrag mit dem Schl\u00fcssel key aus der Map und gibt den dazugeh\u00f6rigen Wert zur\u00fcck (wenn key in der Map enthalten ist, sonst null ). int size() Gibt die Anzahl der Elemente in der Map zur\u00fcck. Set keySet() Gibt eine Set mit allen Schl\u00fcsseln der Map zur\u00fcck. Collection values() Gibt eine Collection mit allen Werten der Map zur\u00fcck. Set > entrySet() Gibt eine Set mit allen Eintr\u00e4gen (Schl\u00fcssel-Werte-Paare) als Map.Entry der Map zur\u00fcck.","title":"Maps"},{"location":"maps/#maps","text":"Maps sind auch Collections. Maps sind Mengen von Schl\u00fcssel-Werte-Paaren. Wir k\u00f6nnen uns Maps als zweispaltige Tabellen vorstellen, in denen die linke Spalte die Schl\u00fcssel ( keys ) enth\u00e4lt und die rechte Spalte die Werte ( values ). Die Schl\u00fcssel in einer Map sind immer eindeutig, d.h. keine zwei Schl\u00fcssel in einer Map sind gleich. Tats\u00e4chlich handelt es sich bei der Menge der Schl\u00fcssel um eine Set . Obwohl Maps Collections sind, wurde f\u00fcr sie nicht das Interface Collection implementiert, so wie f\u00fcr Listen und Mengen, sondern ein eigenes Interface Map . F\u00fcr Interessierte lohnt sich vielleicht auch ein Blick in die Collections Framework Documentation und das Collections Framework Tutorial .","title":"Maps"},{"location":"maps/#statt-add-und-addall-hier-put-und-putall","text":"Da nicht das Collections -Interface f\u00fcr Maps implementiert wurde, erfolgt das Hinzuf\u00fcgen eines Schl\u00fcssel-Werte-Paares zu einer Map leider auch nicht \u00fcber add() bzw. das Hinzuf\u00fcgen einer Collection nicht \u00fcber addAll() , sondern \u00fcber put(K key, V value) und putAll(Map m) . K ist dabei ein Platzhalter f\u00fcr den Typ der Schl\u00fcssel und V ein Platzhalter f\u00fcr den Typ der Werte.","title":"Statt add() und addAll() hier put() und putAll()"},{"location":"maps/#typ-einer-map-und-typ-eines-schlussel-werte-paares","text":"Eine Map wird also mit zwei Typen typisiert: Map<K, V> wobei K den Typ der Schl\u00fcssel und V den Typ der Werte definiert. Der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Das sieht f\u00fcr uns nat\u00fcrlich auch erstmal ungew\u00f6hnlich aus. Entry ist eine innere Klasse in der Klasse Map (tats\u00e4chlich sind beides Interfaces). Wir nehmen das erstmal einfach so hin und merken uns: der (typisierte) Typ einer Map ist Map<K,V> und der (typisierte) Typ jedes einzelnen Schl\u00fcssel-Werte-Paares in dieser Map ist Map.Entry<K,V> .","title":"Typ einer Map und Typ eines Schl\u00fcssel-Werte-Paares"},{"location":"maps/#statt-iterator-hier-entryset","text":"Die Objektmethode iterator() gibt es f\u00fcr Map leider auch nicht. Stattdessen wird hier die Methode entrySet() verwendet. Da es sich bei einer Map um eine Set von lauter Schl\u00fcssel-Werte-Paaren (jeweils Typ Map.Entry<K,V> ) handelt, liefert entrySet() eine Set<Map.Entry<K,V>> zur\u00fcck. Lassen Sie sich von dieser kryptischen Schreibweise nicht abschrecken! Zur\u00fcckgegeben wird eine Set . Diese ist typisiert und zwar mit dem Typ Map.Entry , welches der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist. Map.Entry ist selbst typisiert, n\u00e4mlich mit dem Typ der Schl\u00fcssel K und dem Typ der Werte V . F\u00fcr K und V werden bei Verwendung konkrete Typen eingesetzt. Hier sind es zun\u00e4chst nur Platzhalter.","title":"Statt iterator() hier entrySet()"},{"location":"maps/#klassenbaum-fur-map","text":"Der Klassenbaum f\u00fcr Map hat \u00c4hnlichkeiten zum Klassenbaum f\u00fcr Collection . Wir finden hier wieder gr\u00fcne (Interfaces), rote (abstrakte Klassen) und blaue (konkrete Klassen) Felder. Auch hier ist es wieder so, dass wir Map als Typ f\u00fcr eine Map verwenden, aber f\u00fcr die Erzeugung konkreter Objekte die Klassen EnumMap , HashMap und TreeMap verwenden. Die am h\u00e4ufigsten verwendete Klasse ist HashMap , da sie am performantesten arbeitet. Sobald Reihenfolge/Sortierung eine Rolle spielt, wird TreeMap verwendet.","title":"Klassenbaum f\u00fcr Map"},{"location":"maps/#erstes-beispiel","text":"Wir betrachten ein erstes Beispiel. Wir erstellen eine HashMap und f\u00fcgen vier Eintr\u00e4ge hinzu: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import java.util.HashMap ; import java.util.Map ; public class Maps { public static void main ( String [] args ) { Map < String , Double > m = new HashMap <> (); m . put ( \"s0512345\" , 1.7 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0587654\" , 2.3 ); // neues Schluessel-Werte-Paar hinzugefuegt m . put ( \"s0512345\" , 2.7 ); // Schluessel existiert bereits --> Wert geaendert m . put ( \"s0555555\" , 3.0 ); // neues Schluessel-Werte-Paar hinzugefuegt } } In Zeile 8 wird unsere Map erzeugt. Die Referenzvariable auf die Map hei\u00dft m . Die Schl\u00fcssel sind vom Typ String und die Werte sind vom Typ Double . Das konkrete Objekt wird durch den Aufruf des Konstruktors der Klasse HashMap erzeugt. In Zeile 9 f\u00fcgen wir mithilfe der put() -Methode ein neues Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0512345\" , der Wert ( value ) ist 1.7 . Beachten Sie, dass hier ein Auto-Boxing des double -Wertes 1.7 in ein Double stattfindet. In Zeile 10 f\u00fcgen wir mithilfe der put() -Methode ein weiters Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0587654\" , der Wert ( value ) ist 2.3 (erneut Auto-Boxing ). In Zeile 11 wird erneut die put() -Methode aufgerufen. Der Schl\u00fcssel \"s0512345\" existiert jedoch bereits. Deshalb wird nur der Wert ge\u00e4ndert. Aus dem alten Wert 1.7 wird nun 2.7 . Die Map enth\u00e4lt nach dieser Anweisung (noch nur) zwei Eintr\u00e4ge. In Zeile 12 f\u00fcgen wir mithilfe der put() -Methode ein weiters Schl\u00fcssel-Werte-Paar hinzu. Der Schl\u00fcssel ( key ) ist \"s0555555\" , der Wert ( value ) ist 3.0 (erneut Auto-Boxing ). Nach diesen Anweisungen sieht unsere Map also wie folgt aus (die \u00dcberschriften der Tabelle dienen nur der Orientierung): Die folgende Abbildung zeigt die Methoden, um Zugriff auf die Werte, Schl\u00fcssel und alle Eintr\u00e4ge zu erhalten: Die Anwendung dieser Methoden auf unsere Map m zeigen die folgenden Anweisungen: 1 2 3 Set < String > keys = m . keySet (); // Menge aller Schluessel Collection < Double > values = m . values (); // Collection aller Werte Set < Map . Entry < String , Double >> entries = m . entrySet (); // Menge aller Schluessel-Werte-Paare die Objektmethode keySet() liefert die Menge aller Schl\u00fcssel zur\u00fcck; R\u00fcckgabetyp ist Set<K> , die Objektmethode values() liefert eine Collection aller Werte zur\u00fcck; R\u00fcckgabetyp ist Collection<V> , die Objektmethode entrySet() liefert die Menge aller Schl\u00fcssel-Werte-Paare zur\u00fcck; R\u00fcckgabetyp ist Set<Map.Entry<K,V>>","title":"Erstes Beispiel"},{"location":"maps/#durch-eine-map-laufen","text":"Um alle Schl\u00fcssel-Werte-Paare einer Map zu extrahieren, k\u00f6nnen wir, wie bereits erw\u00e4hnt, die Methode entrySet() verwenden. F\u00fcr den R\u00fcckgabetyp Map.Entry<K,V> stehen uns zwei weitere Objektmethoden zur Verf\u00fcgung: getKey() liefert den Schl\u00fcssel des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist K , getValue() liefert den Wert des Schl\u00fcssel-Werte-Paares zur\u00fcck; R\u00fcckgabetyp ist V . Wir betrachten f\u00fcr unsere Map m ein Beispiel: 1 2 3 4 for ( Map . Entry < String , Double > eintrag : m . entrySet ()) { System . out . println ( eintrag . getKey () + \" : \" + eintrag . getValue ()); } - In Zeile 1 wird die Methode m.entrySet() aufgerufen, diese gibt eine Set<Map.Entry<String, Double>> zur\u00fcck. Jeder einzelne Eintrag in dieser Set ist also vom Typ Map.Entry<String,Double> . Deshalb verwenden wir diesen Typ f\u00fcr unsere Variable eintrag . Wir nutzen hier also erneut die for-each -Schleife, um durch eine Set zu laufen. - In Zeile 3 verwenden wir die Objektmethoden getKey() und getValue() , die uns von Map.Entry zur Verf\u00fcgung gestellt werden. getKey() gibt uns hier einen String zur\u00fcck (den Schl\u00fcssel) und getValue() gibt hier ein Double zur\u00fcck (den Wert). Hier erfolgt eine automatische Konvertierung von Double nach String (impliziter Aufruf von toString() f\u00fcr Double ). Es erfolgt folgende Ausgabe: s0512345 : 2 .7 s0555555 : 3 .0 s0587654 : 2 .3 Wir sehen also, dass die Reihenfolge des Einf\u00fcgens der Elemente nicht gewahrt bleibt. Die Schl\u00fcssel werden auch nicht sortiert, das sieht hier nur so aus. Wir probieren auch noch die Objektmethoden keySet() und value() aus, die f\u00fcr eine Map zur Verf\u00fcgung stehen: for ( String schluessel : m . keySet ()) { System . out . println ( \"key : \" + schluessel ); } erzeugt: key : s0512345 key : s0555555 key : s0587654 und for ( Double wert : m . values ()) { System . out . println ( \"value : \" + wert . toString ()); // toString() wuerde auch implizit aufgerufen } erzeugt: value : 2 .7 value : 3 .0 value : 2 .3 \u00dcbung Was wird ausgegeben? Map < String , String > accounts = new HashMap <> (); accounts . put ( \"anton\" , \"anton@email.de\" ); accounts . put ( \"berta\" , \"berta@email.de\" ); accounts . put ( \"caesar\" , \"caesar@email.de\" ); accounts . put ( \"anton\" , \"antonius@email.de\" ); // Iteration ueber alle Eintraege (Map.Entry) der Map for ( Map . Entry < String , String > entry : accounts . entrySet ()) { System . out . println ( \"Account : \" + entry . getKey () + \" E-Mail : \" + entry . getValue ()); }","title":"Durch eine Map laufen"},{"location":"maps/#zusammenfassung-maps","text":"Maps speichern Referenztypen als Schl\u00fcssel und Werte Maps werden typisiert mit K (Platzhalter f\u00fcr den Referenztyp des Schl\u00fcssels) und V (Platzhalter f\u00fcr den Referenztyp des Wertes) Maps enthalten eindeutige Zuordnungen von einem Wert zu einem Schl\u00fcssel (aber nicht umgekehrt) der Zugriff auf alle Eintr\u00e4ge/Schl\u00fcssel/Werte erfolgt \u00fcber Sets/Collection der Typ eines einzelnen Schl\u00fcssel-Werte-Paares ist Map.Entry<K,V> Hier noch ein \u00dcberblick \u00fcber die wichtigsten Objektmethoden f\u00fcr eine Map . Weitere Methoden finden Sie hier . Objektmethode Beschreibung V get(K key) Gibt den Wert zum Schl\u00fcssel key zur\u00fcck. Ist der Schl\u00fcssel key nicht in der Map enthalten, wird null zur\u00fcckgegeben. V put(K key, V value) F\u00fcgt einen neuen Eintrag mit dem Schl\u00fcssel key und dem Wert value in die Map ein. Wenn ein Eintrag f\u00fcr Schl\u00fcssel key bereits existiert, wird der value \u00fcberschrieben . void putAll(Map m) F\u00fcgt alle Element der Map m in die Map ein. Wenn ein Eintrag f\u00fcr einen Schl\u00fcssel bereits existiert, wird er \u00fcberschrieben . void clear() Entfernt alle Elemente aus der Map. boolean containsKey(Object k) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Schl\u00fcssel k in der Map gibt. Der Vergleich der Schl\u00fcssel mit dem Objekt k erfolgt mit der equals() -Methode. boolean containsValue(Object v) Gibt true zur\u00fcck, wenn es einen Eintrag mit dem Wert v in der Map gibt. Der Vergleich der Werte mit dem Objekt v erfolgt mit der equals() -Methode. boolean isEmpty() Gibt true zur\u00fcck, wenn sich keine Elemente in der Map befinden. V remove(Object key) Entfernt den Eintrag mit dem Schl\u00fcssel key aus der Map und gibt den dazugeh\u00f6rigen Wert zur\u00fcck (wenn key in der Map enthalten ist, sonst null ). int size() Gibt die Anzahl der Elemente in der Map zur\u00fcck. Set keySet() Gibt eine Set mit allen Schl\u00fcsseln der Map zur\u00fcck. Collection values() Gibt eine Collection mit allen Werten der Map zur\u00fcck. Set > entrySet() Gibt eine Set mit allen Eintr\u00e4gen (Schl\u00fcssel-Werte-Paare) als Map.Entry der Map zur\u00fcck.","title":"Zusammenfassung Maps"},{"location":"mdarrays/","text":"Mehrdimensionale Arrays \u00b6 Arrays sind Objekte. Der Typ eines Arrays ergibt sich aus TypDerElemente[] Wir geben also den Typ der Elemente an (alle Elemente in einem Array sind vom selben Typ) und schreiben eckige Klammern [] dahinter. Dabei kann der Typ der Elemente sowohl ein Wertetyp sein als auch ein Referenztyp. Es k\u00f6nnte also sein, dass der Typ der Elemente selbst wieder ein Array ist. Wir w\u00fcrden dann f\u00fcr TypDerElemente[] f\u00fcr den Typ selbst wieder ein TypDerElemente[] einsetzen und bek\u00e4men TypDerElemente[][] . Und genau das geht auch - wir sprechen von mehrdimensionalen Arrays: Wir werden zweidimensionale Arrays betrachten. Vorstellen k\u00f6nnen wir uns gerade noch dreidimensionale, aber h\u00f6here Dimensionen sollten wir gar nicht verwenden, da dies eigentlich nur mit Fehlern behaftet sein kann. In zweidiemensionalen Arrays haben wir nun anstelle eines Indexes zwei. Man kann sich diese Indizes so verstellen, als w\u00fcrde der eine Index die Spalten nummerieren und der andere die Zeilen. Welcher Index wof\u00fcr steht, bleibt Ihnen \u00fcberlassen. Wir betrachten ein einf\u00fchrendes Beispiel: zweidimensionales Array f\u00fcr das kleine Einmaleins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } } In Zeile 6 wird das zweidiensionale int -Array deklariert ( int[][] einmaleins ) und auch gleichzeitig erzeugt ( new int[anzZeilen][anzSpalten] ). Das passiert genau so, wie wir es bereits von den eindimensionalen Arrays kennen, nur dass wir nun zwei Klammerpaare ( [][] ) und zwei Indizes haben. Da wir zwei Indizes haben, haben wir auch eine verschachtelte for -Schleife, um alle Elemente des Arrays betrachten zu k\u00f6nnen. Die Wertzuweisung erfolgt in Zeile 12 . Beachten Sie, dass die Abbruchbedingung der \u00e4u\u00dferen for -Schleife die Anzahl der Zeilen ermittelt ( einmaleins.length ) und in der inneren for -Schleife die Anzahl der Spalten in jeder Zeile ( einmaleins[i].length ) abgefragt wird. Den Zugriff auf ein solches zweidimensionales Array kann man sich so vorstellen: Der erste Index gibt danach die jeweilige Zeile an und der zweite die Spalte. Das bleibt aber Ihrer Interpretation \u00fcberlassen - k\u00f6nnte auch genau andersherum sein. Manche stellen sich ja ein eindimensionales Array auch vertikal vor und andere horizontal. Wichtig ist nur, dass Sie sich f\u00fcr eine Interpretation entscheiden und diese dann auch konsistent umsetzen. Zur Festigung f\u00fcgen wir in den obigen Code noch eine Ausgabe des zweidimensionalen Arrays ein: Einmaleins mit Ausgabe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; // Wertezuweisungen for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } // Ausgabe auf Konsole for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { System . out . printf ( \"%4d\" , einmaleins [ i ][ j ] ); } System . out . println (); } } ergibt folgnde Ausgabe: 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Wir werden zweidimensionale Arrays in \u00dcbung 1 noch weiter \u00fcben.","title":"Mehrdimensionale Arrays"},{"location":"mdarrays/#mehrdimensionale-arrays","text":"Arrays sind Objekte. Der Typ eines Arrays ergibt sich aus TypDerElemente[] Wir geben also den Typ der Elemente an (alle Elemente in einem Array sind vom selben Typ) und schreiben eckige Klammern [] dahinter. Dabei kann der Typ der Elemente sowohl ein Wertetyp sein als auch ein Referenztyp. Es k\u00f6nnte also sein, dass der Typ der Elemente selbst wieder ein Array ist. Wir w\u00fcrden dann f\u00fcr TypDerElemente[] f\u00fcr den Typ selbst wieder ein TypDerElemente[] einsetzen und bek\u00e4men TypDerElemente[][] . Und genau das geht auch - wir sprechen von mehrdimensionalen Arrays: Wir werden zweidimensionale Arrays betrachten. Vorstellen k\u00f6nnen wir uns gerade noch dreidimensionale, aber h\u00f6here Dimensionen sollten wir gar nicht verwenden, da dies eigentlich nur mit Fehlern behaftet sein kann. In zweidiemensionalen Arrays haben wir nun anstelle eines Indexes zwei. Man kann sich diese Indizes so verstellen, als w\u00fcrde der eine Index die Spalten nummerieren und der andere die Zeilen. Welcher Index wof\u00fcr steht, bleibt Ihnen \u00fcberlassen. Wir betrachten ein einf\u00fchrendes Beispiel: zweidimensionales Array f\u00fcr das kleine Einmaleins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } } In Zeile 6 wird das zweidiensionale int -Array deklariert ( int[][] einmaleins ) und auch gleichzeitig erzeugt ( new int[anzZeilen][anzSpalten] ). Das passiert genau so, wie wir es bereits von den eindimensionalen Arrays kennen, nur dass wir nun zwei Klammerpaare ( [][] ) und zwei Indizes haben. Da wir zwei Indizes haben, haben wir auch eine verschachtelte for -Schleife, um alle Elemente des Arrays betrachten zu k\u00f6nnen. Die Wertzuweisung erfolgt in Zeile 12 . Beachten Sie, dass die Abbruchbedingung der \u00e4u\u00dferen for -Schleife die Anzahl der Zeilen ermittelt ( einmaleins.length ) und in der inneren for -Schleife die Anzahl der Spalten in jeder Zeile ( einmaleins[i].length ) abgefragt wird. Den Zugriff auf ein solches zweidimensionales Array kann man sich so vorstellen: Der erste Index gibt danach die jeweilige Zeile an und der zweite die Spalte. Das bleibt aber Ihrer Interpretation \u00fcberlassen - k\u00f6nnte auch genau andersherum sein. Manche stellen sich ja ein eindimensionales Array auch vertikal vor und andere horizontal. Wichtig ist nur, dass Sie sich f\u00fcr eine Interpretation entscheiden und diese dann auch konsistent umsetzen. Zur Festigung f\u00fcgen wir in den obigen Code noch eine Ausgabe des zweidimensionalen Arrays ein: Einmaleins mit Ausgabe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main ( String [] args ) { int anzZeilen = 10 ; int anzSpalten = 10 ; int [][] einmaleins = new int [ anzZeilen ][ anzSpalten ] ; // Wertezuweisungen for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { einmaleins [ i ][ j ]= ( i + 1 ) * ( j + 1 ); } } // Ausgabe auf Konsole for ( int i = 0 ; i < einmaleins . length ; i ++ ) { for ( int j = 0 ; j < einmaleins [ i ] . length ; j ++ ) { System . out . printf ( \"%4d\" , einmaleins [ i ][ j ] ); } System . out . println (); } } ergibt folgnde Ausgabe: 1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Wir werden zweidimensionale Arrays in \u00dcbung 1 noch weiter \u00fcben.","title":"Mehrdimensionale Arrays"},{"location":"uebungen/","text":"\u00dcbungen \u00b6 \u00dcbung 1 (Git) \u00b6 \u00dcbung 1 Erstellen Sie sich einen GitHub-Account (oder w\u00e4hlen Sie einen anderen Git-Diensteanbieter) Erstellen Sie sich dort ein zentrales Repository Richten Sie Ihren workspace , in dem Sie alle Ihre Entwicklungen in diesem Semester durchf\u00fchren wollen (\u00dcbungen, Aufgaben, ...) als lokales Git-Repository ein Synchroniseren Sie Ihr lokales und Ihr zentrales Git-Repository Video zu \u00dcbung 1 ( Git ) - alles zu EGit herausgenommen \u00dcbung 2 (enum und zweidimensionale Arrays) \u00b6 \u00dcbung 2 Gegeben ist die folgende Klasse TicTacToe : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package uebungen.uebung2 ; public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; public TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } public void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } F\u00fcgen Sie alle notwendigen Klammern { } ein, so dass die Anweisungsbl\u00f6cke korrekt geklammert sind. Erweitern Sie die Klasse TicTacToe um eine print() -Methode, die das Spielfeld auf die Konsole ausgibt (Setzen Sie z.B. f\u00fcr den Player RED ein x und f\u00fcr den Player Black ein o und f\u00fcr EMPTY ein Leerzeichen oder ein - ). Die Ausgabe nach jeweils 2 Z\u00fcgen von RED und BLACK k\u00f6nnte dann z.B. so aussehen: - o o - x - - - x Erweitern Sie die Klasse TicTacToe um eine gewonnen() -Methode ( true , wenn ein Spieler drei Felder horizontal, diagonal oder vertikal belegt hat; ansonsten false ). Erweitern Sie die Klasse TicTacToe um eine unentschieden() -Methode ( true , wenn alle Felder besetzt sind, aber kein Spieler gewonnen hat; ansonsten false ). Erstellen Sie eine Test-Klasse mit main() -Methode. Erstellen sie darin ein Objekt der Klasse TicTacToe . F\u00fchren Sie Z\u00fcge aus ( makeMove() ) und pr\u00fcfen Sie, ob gewonnen wurde oder unentschieden ist (mit entsprechenden Ausgaben). F\u00fcr 6. m\u00fcssen Sie in der Testklasse Ihr enum State importieren. Warum ist das so? Was k\u00f6nnten Sie machen, damit das nicht notwendig ist? Zusatz: Sie k\u00f6nnen die Klasse TicTacToe beliebig erweitern, z.B.: um Ausgaben, wenn gewonnen bzw. es unentschieden ist, um Fehler in den Indizes i und j bei der makeMove() -Methode abzufangen, eine Methode spielen() implementieren, die zuf\u00e4llig f\u00fcr die Spieler die Steine setzt usw. Viel Spa\u00df! Video zu \u00dcbung 2 (TicTacToe) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 TicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 package uebungen.uebung2 ; import java.util.Random ; public class TicTacToe { State [][] field ; public TicTacToe () { this . field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < this . field . length ; i ++ ) { for ( int j = 0 ; j < this . field [ i ] . length ; j ++ ) { field [ i ][ j ]= State . EMPTY ; } } } public void makeMove ( int row , int col , State player ) { if ( row >= 0 && row < this . field . length && col >= 0 && col < this . field [ row ] . length && this . field [ row ][ col ] == State . EMPTY ) { if ( player != State . EMPTY ) { this . field [ row ][ col ]= player ; } } } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { System . out . print ( \"- \" ); } else if ( field [ row ][ col ]== State . RED ) { System . out . print ( \"x \" ); } else // BLACK { System . out . print ( \"o \" ); } } System . out . println (); } System . out . println (); } public boolean gewonnen ( State player ) { if ( player == State . EMPTY ) return false ; // alle drei Zeilen pruefen for ( int row = 0 ; row < this . field . length ; row ++ ) { if ( this . field [ row ][ 0 ] == player && this . field [ row ][ 1 ] == player && this . field [ row ][ 2 ] == player ) { return true ; } } // alle drei Spalten pruefen for ( int col = 0 ; col < this . field . length ; col ++ ) { if ( this . field [ 0 ][ col ] == player && this . field [ 1 ][ col ] == player && this . field [ 2 ][ col ] == player ) { return true ; } } // Diagonale von links oben nach rechts unten if ( this . field [ 0 ][ 0 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 2 ] == player ) { return true ; } // Diagonale von rechts oben nach links unten if ( this . field [ 0 ][ 2 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 0 ] == player ) { return true ; } return false ; } public void printResultat () { if ( this . gewonnen ( State . RED )) { System . out . println ( \"Rot hat gewonnen!!!\" ); } else if ( this . gewonnen ( State . BLACK )) { System . out . println ( \"Schwarz hat gewonnen!!!\" ); } else if ( this . unentschieden ()) { System . out . println ( \"Unentschieden!!!\" ); } } public void makeRandomMove ( State player ) { if ( player != State . EMPTY ) { Random r = new Random (); int row = r . nextInt ( 3 ); int col = r . nextInt ( 3 ); while ( this . field [ row ][ col ]!= State . EMPTY ) { row = r . nextInt ( 3 ); col = r . nextInt ( 3 ); } this . field [ row ][ col ]= player ; } } public void spielen () { State player = State . RED ; while ( ! ( this . unentschieden () || this . gewonnen ( State . RED ) || this . gewonnen ( State . BLACK ))) { this . makeRandomMove ( player ); this . print (); this . printResultat (); if ( player == State . RED ) { player = State . BLACK ; } else { player = State . RED ; } // player = (player == State.RED) ? State.BLACK : State.RED; } } public boolean voll () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { return false ; } } } return true ; } public boolean unentschieden () { return ( this . voll () && ! this . gewonnen ( State . RED ) && ! this . gewonnen ( State . BLACK )); } } State.java 1 2 3 4 5 package uebungen.uebung2 ; public enum State { EMPTY , RED , BLACK } TestTicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package uebungen.uebung2 ; public class TestTicTacToe { public static void main ( String [] args ) { TicTacToe ttt = new TicTacToe (); ttt . print (); /* ttt.makeMove(1, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 2, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, -1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 0, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 2, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 2, State.RED); ttt.printResultat(); ttt.print(); */ ttt . spielen (); // ttt.makeRandomMove(State.RED); // ttt.print(); } } \u00dcbung 3 (Exceptions) \u00b6 \u00dcbung 3 Schreiben Sie ein Programm zur Eingabe von zwei Zahlen mithilfe der Klasse JOptionPane aus dem und deren Division! Fangen Sie folgende Ausnahmen ab: Falls die Eingabe keiner Zahl entspricht. Falls die zweite Zahl eine 0 ist. Scenario : Fenster zur Eingabe von Zahl 1 \u00f6ffnet sich: falsche Eingabe - keine Zahl: Fenster \u00f6ffnet sich erneut (andere Nachricht!): Fenster zur Eingabe von Zahl 2 \u00f6ffnet sich: die Division Zahl1/Zahl2 schl\u00e4gt fehl ( ArithmeticException ), deshalb (andere Nachricht!): Ergebnis Lagern Sie eine solche Eingabem\u00f6glichkeit in eine wiederverwendbare Methode aus, z.B. public int inputInt(int min, int max) , welche die eingegebene Zahl zur\u00fcckgibt, wobei die eingegebene Zahl im Bereich [min, max] liegen muss. Lesen Sie eine Anzahl von Sekunden ein und schreiben Sie eine Umrechnung, so dass folgende Ausgabe entsteht (die Eingabe ist hier \u00fcber die Konsole gezeigt) : Gib eine Anzahl von Sekunden ein: 3456789 3456789 Sekunden sind 40 Tage, 13 Minuten, 9 Sekunden. Gib eine Anzahl von Sekunden ein: 2345678 2345678 Sekunden sind 27 Tage, 3 Stunden, 34 Minuten, 38 Sekunden. Gib eine Anzahl von Sekunden ein: 123456 123456 Sekunden sind 1 Tag, 10 Stunden, 17 Minuten, 36 Sekunden. Gib eine Anzahl von Sekunden ein: 12345 12345 Sekunden sind 3 Stunden, 25 Minuten, 45 Sekunden. Lesen Sie eine Zahl ein und geben Sie die Quersumme der Zahl aus. Viel Spa\u00df! Video zu \u00dcbung 3 (Exceptions) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 Uebung3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 package uebungen.uebung3 ; import javax.swing.JOptionPane ; public class Uebung3 { public static int inputInt ( int min , int max , String message ) { boolean eingabeOk = false ; int zahl = 0 ; // String message = \"Geben Sie eine Zahl ein : \"; while ( ! eingabeOk ) { String eingabe1 = JOptionPane . showInputDialog ( message ); try { zahl = Integer . valueOf ( eingabe1 ); if ( zahl >= min && zahl <= max ) { eingabeOk = true ; } else { message = \"Zahl muss zwischen \" + min + \" und \" + max + \" liegen!\" ; } } catch ( NumberFormatException e ) { message = \"Eingabe war keine Zahl! Bitte Zahl eingeben\" ; } } return zahl ; } public static int inputInt ( String message ) { return inputInt ( Integer . MIN_VALUE , Integer . MAX_VALUE , message ); } public static int division ( int divident , int divisor ) throws ArithmeticException { int quotient = divident / divisor ; return quotient ; } public static void printDivision () { int zahl1 = inputInt ( \"Geben Sie eine Zahl1 ein : \" ); boolean zahl2NotZero = false ; String message = \"Geben Sie eine Zahl2 ein : \" ; while ( ! zahl2NotZero ) { int zahl2 = inputInt ( message ); int result = 0 ; try { result = division ( zahl1 , zahl2 ); zahl2NotZero = true ; } catch ( ArithmeticException e ) { message = \"Zahl2 darf nicht 0 sein!\" ; } System . out . println ( zahl1 + \" / \" + zahl2 + \" = \" + result ); } } public static int quersumme ( int zahl ) { int ganz = zahl ; int quersumme = 0 ; while ( ganz > 0 ) { int rest = ganz % 10 ; quersumme += rest ; ganz = ganz / 10 ; } return quersumme ; } public static void printUmrechnungSek () { int sek = inputInt ( \"Anzahl Sekunden : \" ); int tage = sek / ( 24 * 60 * 60 ); int stunden = sek / ( 60 * 60 ) - ( tage * 24 ); int minuten = sek / ( 60 ) - ( tage * 24 * 60 ) - ( stunden * 60 ); int sekunden = sek - ( tage * 24 * 60 * 60 ) - ( stunden * 60 * 60 ) - ( minuten * 60 ); String s = sek + \" Sekunden sind \" ; if ( tage > 1 ) s += tage + \" Tage, \" ; else if ( tage == 1 ) s += \"1 Tag, \" ; if ( stunden > 1 ) s += stunden + \" Stunden, \" ; else if ( stunden == 1 ) s += \"1 Stunden, \" ; if ( minuten > 1 ) s += minuten + \" Minuten, \" ; else if ( minuten == 1 ) s += \"1 Minute, \" ; if ( sekunden > 1 ) s += sekunden + \" Sekunden.\" ; else if ( sekunden == 1 ) s += \"1 Sekunde.\" ; System . out . println ( s ); } public static void main ( String [] args ) { printDivision (); int zahl = inputInt ( \"Geben Sie eine Zahl ein\" ); // System.out.println(\"Quersumme von \" + zahl + \" ist \" + quersumme(zahl)); JOptionPane . showMessageDialog ( null , \"Quersumme von \" + zahl + \" ist \" + quersumme ( zahl )); printUmrechnungSek (); } } module-info.java 1 2 3 module SoSe2021 { requires java . desktop ; } \u00dcbung 4 (Test-driven development) \u00b6 Warning Diese \u00dcbung lassen wir weg. Am 6.5.2021 machen wir stattdessen gleich \u00dcbung 5 . Das hat den Vorteil, dass wir den Stoff von Vorlesung und \u00dcbung wieder zeitlich dichter zusammenziehen (Mittwoch Vorlesung und Donnerstag dazugeh\u00f6rige \u00dcbung). Au\u00dferdem f\u00e4llt die \u00dcbung am 13.5. wegen des Feiertages weg und somit w\u00e4re die L\u00fccke noch gr\u00f6\u00dfer. \u00dcbung 4 Implementieren Sie eine Methode public static int strStr(String haystack, String needle) durch testgetriebene Entwicklung. Die Methode gibt den Anfangsindex des ersten Auftretens von needle in haystack aus, z.B. // Beispiel 1 Input: haystack = \"hello\" , needle = \"ll\" Output: 2 // ll beginnt am Index 2 // Beispiel 2 Input: haystack = \"aaaaa\" , needle = \"bba\" Output: -1 // bba kommt nicht vor // Beispiel 3 Input: haystack = \"\" , needle = \"\" Output: 0 // \"leerer\" String ueberall, also auch bei 0 Wenn needle nicht in haystack enthalten ist, wird -1 zur\u00fcckgegeben. Implementieren Sie eine Methode public static int[][] permutations(int[] nums) durch testgetriebene Entwicklung. Die Methode gibt ein Array von int -Arrays zur\u00fcck, welches alle Permutationen der Zahlen aus nums enth\u00e4lt, z.B. // Beispiel 1 Input: nums = [ 1 ,2,3 ] Output: [[ 1 ,2,3 ] , [ 1 ,3,2 ] , [ 2 ,1,3 ] , [ 2 ,3,1 ] , [ 3 ,1,2 ] , [ 3 ,2,1 ]] // Beispiel 2 Input: nums = [ 0 ,1 ] Output: [[ 0 ,1 ] , [ 1 ,0 ]] // Beispiel 3 Input: nums = [ 1 ] Output: [[ 1 ]] Sie d\u00fcrfen folgende Annahmen treffen: 1 <= nums.length <= 6 -10 <= nums[i] <= 10 nums enth\u00e4lt keine Doppelungen Viel Spa\u00df! \u00dcbung 5 (Listen und Mengen) \u00b6 \u00dcbung 5 Erstellen Sie eine Klasse Uebung5 mit main() -Methode. Definieren Sie in der main() -Methode eine Variable words vom Typ String[] und weisen Sie dieser Variablen folgende Werte zu: String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; A. Listen ( List ) Erstellen Sie eine Methode public static List<String> createArrayList(String[] words) . In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Liste ( List ) zur\u00fcck. Erstellen Sie eine Methode public static void printList(List<String> list) . Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Liste aus. Erstellen Sie in der main() -Methode mithilfe der Methode createArrayList(words) eine Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String> . Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. Studieren Sie alle Methoden f\u00fcr List unter https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html . Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 Geben Sie den Wert des ersten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux Geben Sie den Wert des letzten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox L\u00f6schen Sie die Werte \"Apple\" , \"Google\" und \"Facebook\" . Geben Sie die Liste erneut mithilfe der printList(list) -Methode aus. B. Mengen ( Set ) Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words) . In dieser Methode soll eine HashSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie eine Methode public static void printSet(Set<String> set) . Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Menge aus. Erstellen Sie in der main() -Methode mithilfe der Methode createHashSet(words) eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String> . Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente in der Liste? Warum ist das so? Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words) . In dieser Methode soll eine TreeSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Menge ( Set ) mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie in der main() -Methode mithilfe der Methode createTreeSet(words) eine Menge und speichern Sie diese Menge in einer Variablen. Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet ? Zusatz Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list) . Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. Geben Sie diese Liste mithilfe der printList() -Methode in der main() -Methode aus. M\u00f6gliche Ausgabe (je nach Reihenfolge des Aufrufs der Methoden) Liste mit 16 Elementen : -------------------------- Linux Apple Facebook Amazon IBM Lenovo Google IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Index des ersten Auftretens von Apple : 1 Index des letzten Auftretens von Apple : 9 erstes Element in der Liste : Linux letztes Element in der Liste : Firefox Liste mit 13 Elementen : -------------------------- Linux Amazon IBM Lenovo IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Doublets- Liste mit 4 Elementen : -------------------------- Linux IBM IBM Linux ohne Doublets- Liste mit 9 Elementen : -------------------------- Amazon Lenovo Microsoft Apple Google Twitter Skype Chrome Firefox Menge mit 12 Elementen : -------------------------- Lenovo Google Apple Skype Linux IBM Twitter Chrome Microsoft Amazon Facebook Firefox Menge mit 12 Elementen : -------------------------- Amazon Apple Chrome Facebook Firefox Google IBM Lenovo Linux Microsoft Skype Twitter Video zu \u00dcbung 5 (Listen und Mengen) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 - aus der \u00dcbung von Frau Busjahn (mit Kommentaren) Uebung5.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 package uebungen.uebung5.loesung ; import java.util.ArrayList ; import java.util.HashSet ; import java.util.Iterator ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Uebung5 { //A1. Erstellen Sie eine Methode public static List<String> createArrayList(String[] words). //In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. Die Methode gibt die bef\u00fcllte Liste (List) zur\u00fcck. public static List < String > createArrayList ( String [] words ){ // neue ArrayList mit String als Type anlegen List < String > list = new ArrayList <> (); // jedes Element aus words in die Liste einf\u00fcgen for ( int i = 0 ; i < words . length ; i ++ ) { list . add ( words [ i ] ); } return list ; } //A2. Erstellen Sie eine Methode public static void printList(List<String> list). //Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Liste aus. public static void printList ( List < String > list ) { //Variante 1: Iterator System . out . println ( \"--Iterator--\" ); Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } //Variante 2: for-Schleife System . out . println ( \"--Schleife--\" ); for ( String s : list ) { System . out . println ( s ); } //Anzahl der Elemente ausgeben System . out . println ( \"Die Liste hat \" + list . size () + \" Elemente.\" ); } //B1. Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words). //In dieser Methode soll eine HashSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createHashSet ( String [] words ) { Set < String > set = new HashSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //B2. Erstellen Sie eine Methode public static void printSet(Set<String> set). //Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Menge aus. public static void printSet ( Set < String > set ) { for ( String s : set ) { System . out . println ( s ); } System . out . println ( \"Das Set hat \" + set . size () + \" Elemente.\" ); } //B4. Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words). //In dieser Methode soll eine TreeSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Menge (Set) mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createTreeSet ( String [] words ) { Set < String > set = new TreeSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //Zusatz: Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list). //Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. //Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. //Geben Sie diese Liste mithilfe der printList()-Methode in der main()-Methode aus. public static List < String > findDoublets ( List < String > list ) { //Grundidee //Beispiel-Liste: \"a\" \"b\" \"a\" \"c\" \"a\" //Index: 0 1 2 3 4 //Inhalt: a b a c a //erster Index von \"a\": 0 //letzter Index von \"a\":4 //0 != 4 -> es gibt Duplikate //erster Index von \"b\":1 //letzter Index von \"b\":1 //1 == 1 -> keine Duplikate, also diesen Eintrag als Einzeleintrag merken //... //leere Liste \"singles\" f\u00fcr Einzeleintr\u00e4ge anlegen List < String > singles = new ArrayList <> (); //durch list iterieren und testen ob das Element Duplikate hat, //wenn nicht in \"singles\" speichern Iterator < String > it = list . iterator (); //it = copy.iterator(); while ( it . hasNext ()) { String s = it . next (); if ( list . indexOf ( s ) == list . lastIndexOf ( s )) singles . add ( s ); } //Kopie von list anlegen List < String > copy = new ArrayList <> (); it = list . iterator (); while ( it . hasNext ()) copy . add ( it . next ()); //alle singles aus der kopierten Liste entfernen copy . removeAll ( singles ); return copy ; //um zu testen, warum die Kopie n\u00f6tig ist: //copy.removeAll(singles); und return copy; ersetzen durch //list.removeAll(singles); //return list; //und dann die Ausgabe von l2 in der main anschauen } public static void main ( String [] args ) { String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; System . out . println ( \"---------- A ----------\" ); //A3. Erstellen Sie in der main()-Methode mithilfe der Methode createArrayList(words) eine //Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String>. List < String > l1 = createArrayList ( words ); //Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. printList ( l1 ); //A4. Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 System . out . println ( \"Index des ersten Auftretens von Apple: \" + l1 . indexOf ( \"Apple\" )); //Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 System . out . println ( \"Index des letzten Auftretens von Apple: \" + l1 . lastIndexOf ( \"Apple\" )); //Geben Sie den Wert des ersten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux System . out . println ( \"erstes Element der Liste: \" + l1 . get ( 0 )); //Geben Sie den Wert des letzten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox System . out . println ( \"letztes Element der Liste: \" + l1 . get ( l1 . size () - 1 )); //L\u00f6schen Sie die Werte \"Apple\", \"Google\" und \"Facebook\". //Geben Sie die Liste erneut mithilfe der printList(list)-Methode aus. //1. M\u00f6glichkeit: nur 1. Vorkommen l\u00f6schen l1 . remove ( \"Apple\" ); l1 . remove ( \"Google\" ); l1 . remove ( \"Facebook\" ); printList ( l1 ); //2. M\u00f6glichkeit: alle l\u00f6schen while ( l1 . remove ( \"Apple\" )); while ( l1 . remove ( \"Google\" )); while ( l1 . remove ( \"Facebook\" )); printList ( l1 ); System . out . println ( \"---------- B ----------\" ); System . out . println ( \"-------HashSet------\" ); //B3. Erstellen Sie in der main()-Methode mithilfe der Methode createHashSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String>. Set < String > h1 = createHashSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente //in der Liste? Warum ist das so? printSet ( h1 ); System . out . println ( \"-------TreeSet------\" ); //B5. Erstellen Sie in der main()-Methode mithilfe der Methode createTreeSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen. Set < String > t1 = createTreeSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet? printSet ( t1 ); System . out . println ( \"-------Duplicates------\" ); List < String > l2 = createArrayList ( words ); List < String > d = findDoublets ( l2 ); printList ( d ); printList ( l2 ); } } \u00dcbung 6 (Wrapper-Klassen und Maps) \u00b6 \u00dcbung 6 Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: String name; List<Integer> bevoelkerung; float flaeche; Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor public Stadt(String name, List<Integer> bevoelkerung, float flaeche) , der die Objektvariablen initialisiert. Erstellen Sie f\u00fcr die Klasse Stadt eine print() -Methode, so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Erstellen Sie eine Klasse StadtTest mit main() -Methode. Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } Liste Erstellen Sie in der main() -Methode eine List<Stadt> staedteListe = new ArrayList<>(); . F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Menge Erstellen Sie in der main() -Methode eine Set<Stadt> staedteMenge = new HashSet<>(); . F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? Stadt - Teil 2 Implementieren Sie in der Klasse Stadt die equals(Object) - und die hashCode() -Methode. F\u00fchren Sie danach die StadtTest -Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? Maps Erstellen Sie in der main() -Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>(); . F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer -Wert beginnend mit 1 als Key sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array als Value hinzu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys . Ausgaben ------------ Liste -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 ------------ Menge -------------- Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 ------------ Maps -------------- 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 die von Frau Busjahn vorkommentierten Klassen Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Da es sich um einen Konstruktor einer Kindklasse handelt, sollte zuerst explizit der Konstruktor der Elternklasse aufrufen werden //kann aber wie implements erst sp\u00e4ter erg\u00e4nzt werden //Objektvariablen initialisieren this . ??? = ??? ; ... } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 //import //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Liste --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n------------ Menge --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? System . out . printf ( \"%n------------ Maps --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte } } Video zu \u00dcbung 6 (Wrapper-Klassen und Maps) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 (aus dem Video - mit compareTo - den Teil mit TreeSet und compareTo m\u00fcssen Sie aber nicht beachten, kommt n\u00e4chste Woche) Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 package uebungen.uebung6 ; import java.util.* ; //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt implements Comparable //Der Teil mit \"implements\" wird nicht von Anfang an ben\u00f6tigt, es kann also auch erstmal mit \"public class Stadt\" begonnen werden. //W\u00e4hrend es bei primitiven Datentypen meist eindeutig ist, ob ein Wert gr\u00f6\u00dfer, kleiner oder gleich gro\u00df ist wie ein anderer Wert, ist die Ordnung bei Objekten nicht so klar. //Daher muss Stadt Klasse ein bestimmtes Interface implementieren, um festzulegen, was verglichen werden soll. { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Da es sich um einen Konstruktor einer Kindklasse handelt, sollte zuerst explizit der Konstruktor der Elternklasse aufrufen werden //kann aber wie implements erst sp\u00e4ter erg\u00e4nzt werden //Objektvariablen initialisieren this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen System . out . printf ( \"%-15s %9.2f km2 \" , this . name , this . flaeche ); for ( Integer el : this . bevoelkerung ) { System . out . printf ( \"%,10d\" , el ); } System . out . println (); } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben Stadt stadt = ( Stadt ) o ; return this . name . equals ( stadt . name ); } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben return this . name . hashCode (); } //Festlegen, dass der Name des \u00fcbergebenen Stadt-Objekts o mit dem Namen des aktuellen Stadt-Objekts verglichen werden soll @Override public int compareTo ( Object o ) { Stadt stadt = ( Stadt ) o ; return this . name . compareTo ( stadt . name ); } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 package uebungen.uebung6 ; //import import java.util.* ; //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------------- Liste -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen Stadt [] staedte = staedte (); for ( Stadt stadt : staedte ) { staedteListe . add ( stadt ); } //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. for ( Stadt stadt : staedteListe ) { stadt . print (); } //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n%n------------------------- Menge -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge1 = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. for ( Stadt stadt : staedte ()) { staedteMenge1 . add ( stadt ); } //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben for ( Stadt stadt : staedteMenge1 ) { stadt . print (); } //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? //Notieren Sie sich die Reihenfolge, in der St\u00e4dte ausgegeben werden. //\u00c4ndern Sie den Konstruktor von HashSet<>() in TreeSet<>(). Was passiert und warum? Set < Stadt > staedteMenge2 = new TreeSet <> (); //analog zu oben System . out . printf ( \"%n%n------------------------- Maps -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); Integer number = 1 ; for ( Stadt stadt : staedte ()) { staedteMap . put ( number , stadt ); number ++ ; } // Stadt berlin = staedte[0]; // staedteMap.put(2, berlin); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. for ( Map . Entry < Integer , Stadt > eintrag : staedteMap . entrySet ()) { System . out . printf ( \"%-3d\" , eintrag . getKey ()); Stadt stadt = eintrag . getValue (); stadt . print (); } //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte System . out . printf ( \"%n%n------------------------- Test compareTo -------------------------%n%n\" ); System . out . println ( \"Berlin\" . compareTo ( \"Anton\" )); System . out . println ( \"Anton\" . compareTo ( \"Berlin\" )); System . out . println ( \"Berlin\" . compareTo ( \"Berlin\" )); System . out . println ( \"Anton\" . compareTo ( \"Zeppelin\" )); } } eine andere m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 (aus der \u00dcbung von Frau Busjahn) Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package prog2_uebungen ; import java.util.* ; //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Objektvariablen initialisieren this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben System . out . print ( name + \" \" + flaeche + \" km2 \" ); //mithilfe eines Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben Iterator < Integer > it = bevoelkerung . iterator (); while ( it . hasNext ()) { System . out . print ( it . next () + \" \" ); } //Alternative mit Schleife // for(Integer i : bevoelkerung) // { // System.out.print(i + \" \"); // } System . out . println (); } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der St\u00e4dtename des \u00fcbergebenen Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck if ( o == null ) return false ; // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck, // da die St\u00e4dtenamen dann auf jeden Fall auch gleich sind if ( o == this ) return true ; // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck if ( o . getClass () != this . getClass ()) return false ; //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o Stadt other = ( Stadt ) o ; //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben return ( this . name . equals ( other . name )); } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben return this . name . hashCode (); } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 package prog2_uebungen ; import java.util.* ; //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { //staedte() genauer anschauen System . out . printf ( \"%n------------ R\u00fcckgabe von staedte() --------------%n\" ); Stadt [] staedteArray = staedte (); for ( int i = 0 ; i < staedteArray . length ; i ++ ) { Stadt s = staedteArray [ i ] ; System . out . println ( s . name + \" \" + s . flaeche + \" \" + s . bevoelkerung ); } System . out . printf ( \"%n------------ Liste --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen for ( Stadt s : staedte ()) { staedteListe . add ( s ); } //Alternative: //for (Stadt s : staedteArray) { // staedteListe.add(s); //} //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen for ( Stadt s : staedteListe ) { s . print (); } System . out . printf ( \"%n------------ Menge --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. Integer i = 1 ; //int i = 1; ginge auch, w\u00fcrde dann beim Einf\u00fcgen automtisch zu Integer umgewandelt (Auto-Boxing) for ( Stadt s : staedte ()) { staedteMap . put ( i ++ , s ); } //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. for ( Map . Entry < Integer , Stadt > eintrag : staedteMap . entrySet ()) { System . out . print ( eintrag . getKey () + \": \" ); eintrag . getValue (). print (); } } } Zusatz \u00b6 Test-driven development \u00b6 parseDouble(String) In der Aufgabe 2 sollen Sie f\u00fcr die Klasse MyInteger eine Methode parseInt(String s) schreiben, die einen String s in eine int -Zahl umwandelt, wenn dies m\u00f6glich ist. In dieser \u00dcbung wollen wir eine solche (statische) Methode parseDouble(String s) f\u00fcr eine Klasse MyDouble testgetrieben entwickeln. \u00dcberlegen Sie sich dazu einige Strings, die Sie umwandeln wollen und die dazugeh\u00f6rigen erwarteten Ergebnisse. Es muss nicht vollst\u00e4ndig implementiert werden. Es geht ums Prinzip. Mithilfe von assertThrows() k\u00f6nnen Sie \u00fcbrigens pr\u00fcfen, ob eine Exception geworfen wird (wenn s keiner Zahl entspricht) - siehe dazu z.B. hier oder hier . Viel Spa\u00df!","title":"\u00dcbungen"},{"location":"uebungen/#ubungen","text":"","title":"\u00dcbungen"},{"location":"uebungen/#ubung-1-git","text":"\u00dcbung 1 Erstellen Sie sich einen GitHub-Account (oder w\u00e4hlen Sie einen anderen Git-Diensteanbieter) Erstellen Sie sich dort ein zentrales Repository Richten Sie Ihren workspace , in dem Sie alle Ihre Entwicklungen in diesem Semester durchf\u00fchren wollen (\u00dcbungen, Aufgaben, ...) als lokales Git-Repository ein Synchroniseren Sie Ihr lokales und Ihr zentrales Git-Repository Video zu \u00dcbung 1 ( Git ) - alles zu EGit herausgenommen","title":"\u00dcbung 1 (Git)"},{"location":"uebungen/#ubung-2-enum-und-zweidimensionale-arrays","text":"\u00dcbung 2 Gegeben ist die folgende Klasse TicTacToe : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package uebungen.uebung2 ; public class TicTacToe { enum State { EMPTY , RED , BLACK }; State [][] field ; public TicTacToe () { field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < field . length ; i ++ ) for ( int j = 0 ; j < field [ i ] . length ; j ++ ) field [ i ][ j ]= State . EMPTY ; } public void makeMove ( int i , int j , State player ) { if ( field [ i ][ j ]== State . EMPTY && player != State . EMPTY ) field [ i ][ j ]= player ; } } F\u00fcgen Sie alle notwendigen Klammern { } ein, so dass die Anweisungsbl\u00f6cke korrekt geklammert sind. Erweitern Sie die Klasse TicTacToe um eine print() -Methode, die das Spielfeld auf die Konsole ausgibt (Setzen Sie z.B. f\u00fcr den Player RED ein x und f\u00fcr den Player Black ein o und f\u00fcr EMPTY ein Leerzeichen oder ein - ). Die Ausgabe nach jeweils 2 Z\u00fcgen von RED und BLACK k\u00f6nnte dann z.B. so aussehen: - o o - x - - - x Erweitern Sie die Klasse TicTacToe um eine gewonnen() -Methode ( true , wenn ein Spieler drei Felder horizontal, diagonal oder vertikal belegt hat; ansonsten false ). Erweitern Sie die Klasse TicTacToe um eine unentschieden() -Methode ( true , wenn alle Felder besetzt sind, aber kein Spieler gewonnen hat; ansonsten false ). Erstellen Sie eine Test-Klasse mit main() -Methode. Erstellen sie darin ein Objekt der Klasse TicTacToe . F\u00fchren Sie Z\u00fcge aus ( makeMove() ) und pr\u00fcfen Sie, ob gewonnen wurde oder unentschieden ist (mit entsprechenden Ausgaben). F\u00fcr 6. m\u00fcssen Sie in der Testklasse Ihr enum State importieren. Warum ist das so? Was k\u00f6nnten Sie machen, damit das nicht notwendig ist? Zusatz: Sie k\u00f6nnen die Klasse TicTacToe beliebig erweitern, z.B.: um Ausgaben, wenn gewonnen bzw. es unentschieden ist, um Fehler in den Indizes i und j bei der makeMove() -Methode abzufangen, eine Methode spielen() implementieren, die zuf\u00e4llig f\u00fcr die Spieler die Steine setzt usw. Viel Spa\u00df! Video zu \u00dcbung 2 (TicTacToe) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 2 TicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 package uebungen.uebung2 ; import java.util.Random ; public class TicTacToe { State [][] field ; public TicTacToe () { this . field = new State [ 3 ][ 3 ] ; for ( int i = 0 ; i < this . field . length ; i ++ ) { for ( int j = 0 ; j < this . field [ i ] . length ; j ++ ) { field [ i ][ j ]= State . EMPTY ; } } } public void makeMove ( int row , int col , State player ) { if ( row >= 0 && row < this . field . length && col >= 0 && col < this . field [ row ] . length && this . field [ row ][ col ] == State . EMPTY ) { if ( player != State . EMPTY ) { this . field [ row ][ col ]= player ; } } } public void print () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { System . out . print ( \"- \" ); } else if ( field [ row ][ col ]== State . RED ) { System . out . print ( \"x \" ); } else // BLACK { System . out . print ( \"o \" ); } } System . out . println (); } System . out . println (); } public boolean gewonnen ( State player ) { if ( player == State . EMPTY ) return false ; // alle drei Zeilen pruefen for ( int row = 0 ; row < this . field . length ; row ++ ) { if ( this . field [ row ][ 0 ] == player && this . field [ row ][ 1 ] == player && this . field [ row ][ 2 ] == player ) { return true ; } } // alle drei Spalten pruefen for ( int col = 0 ; col < this . field . length ; col ++ ) { if ( this . field [ 0 ][ col ] == player && this . field [ 1 ][ col ] == player && this . field [ 2 ][ col ] == player ) { return true ; } } // Diagonale von links oben nach rechts unten if ( this . field [ 0 ][ 0 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 2 ] == player ) { return true ; } // Diagonale von rechts oben nach links unten if ( this . field [ 0 ][ 2 ] == player && this . field [ 1 ][ 1 ] == player && this . field [ 2 ][ 0 ] == player ) { return true ; } return false ; } public void printResultat () { if ( this . gewonnen ( State . RED )) { System . out . println ( \"Rot hat gewonnen!!!\" ); } else if ( this . gewonnen ( State . BLACK )) { System . out . println ( \"Schwarz hat gewonnen!!!\" ); } else if ( this . unentschieden ()) { System . out . println ( \"Unentschieden!!!\" ); } } public void makeRandomMove ( State player ) { if ( player != State . EMPTY ) { Random r = new Random (); int row = r . nextInt ( 3 ); int col = r . nextInt ( 3 ); while ( this . field [ row ][ col ]!= State . EMPTY ) { row = r . nextInt ( 3 ); col = r . nextInt ( 3 ); } this . field [ row ][ col ]= player ; } } public void spielen () { State player = State . RED ; while ( ! ( this . unentschieden () || this . gewonnen ( State . RED ) || this . gewonnen ( State . BLACK ))) { this . makeRandomMove ( player ); this . print (); this . printResultat (); if ( player == State . RED ) { player = State . BLACK ; } else { player = State . RED ; } // player = (player == State.RED) ? State.BLACK : State.RED; } } public boolean voll () { for ( int row = 0 ; row < this . field . length ; row ++ ) { for ( int col = 0 ; col < this . field [ row ] . length ; col ++ ) { if ( field [ row ][ col ]== State . EMPTY ) { return false ; } } } return true ; } public boolean unentschieden () { return ( this . voll () && ! this . gewonnen ( State . RED ) && ! this . gewonnen ( State . BLACK )); } } State.java 1 2 3 4 5 package uebungen.uebung2 ; public enum State { EMPTY , RED , BLACK } TestTicTacToe.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package uebungen.uebung2 ; public class TestTicTacToe { public static void main ( String [] args ) { TicTacToe ttt = new TicTacToe (); ttt . print (); /* ttt.makeMove(1, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 2, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, -1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 1, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 1, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(1, 0, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(0, 2, State.RED); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 0, State.BLACK); ttt.printResultat(); ttt.print(); ttt.makeMove(2, 2, State.RED); ttt.printResultat(); ttt.print(); */ ttt . spielen (); // ttt.makeRandomMove(State.RED); // ttt.print(); } }","title":"\u00dcbung 2 (enum und zweidimensionale Arrays)"},{"location":"uebungen/#ubung-3-exceptions","text":"\u00dcbung 3 Schreiben Sie ein Programm zur Eingabe von zwei Zahlen mithilfe der Klasse JOptionPane aus dem und deren Division! Fangen Sie folgende Ausnahmen ab: Falls die Eingabe keiner Zahl entspricht. Falls die zweite Zahl eine 0 ist. Scenario : Fenster zur Eingabe von Zahl 1 \u00f6ffnet sich: falsche Eingabe - keine Zahl: Fenster \u00f6ffnet sich erneut (andere Nachricht!): Fenster zur Eingabe von Zahl 2 \u00f6ffnet sich: die Division Zahl1/Zahl2 schl\u00e4gt fehl ( ArithmeticException ), deshalb (andere Nachricht!): Ergebnis Lagern Sie eine solche Eingabem\u00f6glichkeit in eine wiederverwendbare Methode aus, z.B. public int inputInt(int min, int max) , welche die eingegebene Zahl zur\u00fcckgibt, wobei die eingegebene Zahl im Bereich [min, max] liegen muss. Lesen Sie eine Anzahl von Sekunden ein und schreiben Sie eine Umrechnung, so dass folgende Ausgabe entsteht (die Eingabe ist hier \u00fcber die Konsole gezeigt) : Gib eine Anzahl von Sekunden ein: 3456789 3456789 Sekunden sind 40 Tage, 13 Minuten, 9 Sekunden. Gib eine Anzahl von Sekunden ein: 2345678 2345678 Sekunden sind 27 Tage, 3 Stunden, 34 Minuten, 38 Sekunden. Gib eine Anzahl von Sekunden ein: 123456 123456 Sekunden sind 1 Tag, 10 Stunden, 17 Minuten, 36 Sekunden. Gib eine Anzahl von Sekunden ein: 12345 12345 Sekunden sind 3 Stunden, 25 Minuten, 45 Sekunden. Lesen Sie eine Zahl ein und geben Sie die Quersumme der Zahl aus. Viel Spa\u00df! Video zu \u00dcbung 3 (Exceptions) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 3 Uebung3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 package uebungen.uebung3 ; import javax.swing.JOptionPane ; public class Uebung3 { public static int inputInt ( int min , int max , String message ) { boolean eingabeOk = false ; int zahl = 0 ; // String message = \"Geben Sie eine Zahl ein : \"; while ( ! eingabeOk ) { String eingabe1 = JOptionPane . showInputDialog ( message ); try { zahl = Integer . valueOf ( eingabe1 ); if ( zahl >= min && zahl <= max ) { eingabeOk = true ; } else { message = \"Zahl muss zwischen \" + min + \" und \" + max + \" liegen!\" ; } } catch ( NumberFormatException e ) { message = \"Eingabe war keine Zahl! Bitte Zahl eingeben\" ; } } return zahl ; } public static int inputInt ( String message ) { return inputInt ( Integer . MIN_VALUE , Integer . MAX_VALUE , message ); } public static int division ( int divident , int divisor ) throws ArithmeticException { int quotient = divident / divisor ; return quotient ; } public static void printDivision () { int zahl1 = inputInt ( \"Geben Sie eine Zahl1 ein : \" ); boolean zahl2NotZero = false ; String message = \"Geben Sie eine Zahl2 ein : \" ; while ( ! zahl2NotZero ) { int zahl2 = inputInt ( message ); int result = 0 ; try { result = division ( zahl1 , zahl2 ); zahl2NotZero = true ; } catch ( ArithmeticException e ) { message = \"Zahl2 darf nicht 0 sein!\" ; } System . out . println ( zahl1 + \" / \" + zahl2 + \" = \" + result ); } } public static int quersumme ( int zahl ) { int ganz = zahl ; int quersumme = 0 ; while ( ganz > 0 ) { int rest = ganz % 10 ; quersumme += rest ; ganz = ganz / 10 ; } return quersumme ; } public static void printUmrechnungSek () { int sek = inputInt ( \"Anzahl Sekunden : \" ); int tage = sek / ( 24 * 60 * 60 ); int stunden = sek / ( 60 * 60 ) - ( tage * 24 ); int minuten = sek / ( 60 ) - ( tage * 24 * 60 ) - ( stunden * 60 ); int sekunden = sek - ( tage * 24 * 60 * 60 ) - ( stunden * 60 * 60 ) - ( minuten * 60 ); String s = sek + \" Sekunden sind \" ; if ( tage > 1 ) s += tage + \" Tage, \" ; else if ( tage == 1 ) s += \"1 Tag, \" ; if ( stunden > 1 ) s += stunden + \" Stunden, \" ; else if ( stunden == 1 ) s += \"1 Stunden, \" ; if ( minuten > 1 ) s += minuten + \" Minuten, \" ; else if ( minuten == 1 ) s += \"1 Minute, \" ; if ( sekunden > 1 ) s += sekunden + \" Sekunden.\" ; else if ( sekunden == 1 ) s += \"1 Sekunde.\" ; System . out . println ( s ); } public static void main ( String [] args ) { printDivision (); int zahl = inputInt ( \"Geben Sie eine Zahl ein\" ); // System.out.println(\"Quersumme von \" + zahl + \" ist \" + quersumme(zahl)); JOptionPane . showMessageDialog ( null , \"Quersumme von \" + zahl + \" ist \" + quersumme ( zahl )); printUmrechnungSek (); } } module-info.java 1 2 3 module SoSe2021 { requires java . desktop ; }","title":"\u00dcbung 3 (Exceptions)"},{"location":"uebungen/#ubung-4-test-driven-development","text":"Warning Diese \u00dcbung lassen wir weg. Am 6.5.2021 machen wir stattdessen gleich \u00dcbung 5 . Das hat den Vorteil, dass wir den Stoff von Vorlesung und \u00dcbung wieder zeitlich dichter zusammenziehen (Mittwoch Vorlesung und Donnerstag dazugeh\u00f6rige \u00dcbung). Au\u00dferdem f\u00e4llt die \u00dcbung am 13.5. wegen des Feiertages weg und somit w\u00e4re die L\u00fccke noch gr\u00f6\u00dfer. \u00dcbung 4 Implementieren Sie eine Methode public static int strStr(String haystack, String needle) durch testgetriebene Entwicklung. Die Methode gibt den Anfangsindex des ersten Auftretens von needle in haystack aus, z.B. // Beispiel 1 Input: haystack = \"hello\" , needle = \"ll\" Output: 2 // ll beginnt am Index 2 // Beispiel 2 Input: haystack = \"aaaaa\" , needle = \"bba\" Output: -1 // bba kommt nicht vor // Beispiel 3 Input: haystack = \"\" , needle = \"\" Output: 0 // \"leerer\" String ueberall, also auch bei 0 Wenn needle nicht in haystack enthalten ist, wird -1 zur\u00fcckgegeben. Implementieren Sie eine Methode public static int[][] permutations(int[] nums) durch testgetriebene Entwicklung. Die Methode gibt ein Array von int -Arrays zur\u00fcck, welches alle Permutationen der Zahlen aus nums enth\u00e4lt, z.B. // Beispiel 1 Input: nums = [ 1 ,2,3 ] Output: [[ 1 ,2,3 ] , [ 1 ,3,2 ] , [ 2 ,1,3 ] , [ 2 ,3,1 ] , [ 3 ,1,2 ] , [ 3 ,2,1 ]] // Beispiel 2 Input: nums = [ 0 ,1 ] Output: [[ 0 ,1 ] , [ 1 ,0 ]] // Beispiel 3 Input: nums = [ 1 ] Output: [[ 1 ]] Sie d\u00fcrfen folgende Annahmen treffen: 1 <= nums.length <= 6 -10 <= nums[i] <= 10 nums enth\u00e4lt keine Doppelungen Viel Spa\u00df!","title":"\u00dcbung 4 (Test-driven development)"},{"location":"uebungen/#ubung-5-listen-und-mengen","text":"\u00dcbung 5 Erstellen Sie eine Klasse Uebung5 mit main() -Methode. Definieren Sie in der main() -Methode eine Variable words vom Typ String[] und weisen Sie dieser Variablen folgende Werte zu: String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; A. Listen ( List ) Erstellen Sie eine Methode public static List<String> createArrayList(String[] words) . In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Liste ( List ) zur\u00fcck. Erstellen Sie eine Methode public static void printList(List<String> list) . Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Liste aus. Erstellen Sie in der main() -Methode mithilfe der Methode createArrayList(words) eine Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String> . Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. Studieren Sie alle Methoden f\u00fcr List unter https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html . Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 Geben Sie den Wert des ersten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux Geben Sie den Wert des letzten Elementes der Liste aus. Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox L\u00f6schen Sie die Werte \"Apple\" , \"Google\" und \"Facebook\" . Geben Sie die Liste erneut mithilfe der printList(list) -Methode aus. B. Mengen ( Set ) Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words) . In dieser Methode soll eine HashSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie eine Methode public static void printSet(Set<String> set) . Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. Geben Sie auch die Anzahl der Elemente der Menge aus. Erstellen Sie in der main() -Methode mithilfe der Methode createHashSet(words) eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String> . Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente in der Liste? Warum ist das so? Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words) . In dieser Methode soll eine TreeSet erstellt werden. Alle Elemente in dieser Liste sind vom Typ String . Bef\u00fcllen Sie diese Menge ( Set ) mit allen W\u00f6rtern aus dem words -Array. Die Methode gibt die bef\u00fcllte Menge ( Set ) zur\u00fcck. Erstellen Sie in der main() -Methode mithilfe der Methode createTreeSet(words) eine Menge und speichern Sie diese Menge in einer Variablen. Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet ? Zusatz Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list) . Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. Geben Sie diese Liste mithilfe der printList() -Methode in der main() -Methode aus. M\u00f6gliche Ausgabe (je nach Reihenfolge des Aufrufs der Methoden) Liste mit 16 Elementen : -------------------------- Linux Apple Facebook Amazon IBM Lenovo Google IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Index des ersten Auftretens von Apple : 1 Index des letzten Auftretens von Apple : 9 erstes Element in der Liste : Linux letztes Element in der Liste : Firefox Liste mit 13 Elementen : -------------------------- Linux Amazon IBM Lenovo IBM Microsoft Apple Google Twitter Skype Chrome Linux Firefox Doublets- Liste mit 4 Elementen : -------------------------- Linux IBM IBM Linux ohne Doublets- Liste mit 9 Elementen : -------------------------- Amazon Lenovo Microsoft Apple Google Twitter Skype Chrome Firefox Menge mit 12 Elementen : -------------------------- Lenovo Google Apple Skype Linux IBM Twitter Chrome Microsoft Amazon Facebook Firefox Menge mit 12 Elementen : -------------------------- Amazon Apple Chrome Facebook Firefox Google IBM Lenovo Linux Microsoft Skype Twitter Video zu \u00dcbung 5 (Listen und Mengen) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 5 - aus der \u00dcbung von Frau Busjahn (mit Kommentaren) Uebung5.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 package uebungen.uebung5.loesung ; import java.util.ArrayList ; import java.util.HashSet ; import java.util.Iterator ; import java.util.List ; import java.util.Set ; import java.util.TreeSet ; public class Uebung5 { //A1. Erstellen Sie eine Methode public static List<String> createArrayList(String[] words). //In dieser Methode soll eine ArrayList erstellt werden. Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. Die Methode gibt die bef\u00fcllte Liste (List) zur\u00fcck. public static List < String > createArrayList ( String [] words ){ // neue ArrayList mit String als Type anlegen List < String > list = new ArrayList <> (); // jedes Element aus words in die Liste einf\u00fcgen for ( int i = 0 ; i < words . length ; i ++ ) { list . add ( words [ i ] ); } return list ; } //A2. Erstellen Sie eine Methode public static void printList(List<String> list). //Diese Methode gibt alle Elemente der Liste list auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Liste aus. public static void printList ( List < String > list ) { //Variante 1: Iterator System . out . println ( \"--Iterator--\" ); Iterator < String > it = list . iterator (); while ( it . hasNext ()) { System . out . println ( it . next ()); } //Variante 2: for-Schleife System . out . println ( \"--Schleife--\" ); for ( String s : list ) { System . out . println ( s ); } //Anzahl der Elemente ausgeben System . out . println ( \"Die Liste hat \" + list . size () + \" Elemente.\" ); } //B1. Erstellen Sie eine Methode public static Set<String> createHashSet(String[] words). //In dieser Methode soll eine HashSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Liste mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createHashSet ( String [] words ) { Set < String > set = new HashSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //B2. Erstellen Sie eine Methode public static void printSet(Set<String> set). //Diese Methode gibt alle Elemente der Menge set auf der Konsole aus. //Geben Sie auch die Anzahl der Elemente der Menge aus. public static void printSet ( Set < String > set ) { for ( String s : set ) { System . out . println ( s ); } System . out . println ( \"Das Set hat \" + set . size () + \" Elemente.\" ); } //B4. Erstellen Sie eine Methode public static Set<String> createTreeSet(String[] words). //In dieser Methode soll eine TreeSet erstellt werden. //Alle Elemente in dieser Liste sind vom Typ String. //Bef\u00fcllen Sie diese Menge (Set) mit allen W\u00f6rtern aus dem words-Array. //Die Methode gibt die bef\u00fcllte Menge (Set) zur\u00fcck. public static Set < String > createTreeSet ( String [] words ) { Set < String > set = new TreeSet <> (); for ( int i = 0 ; i < words . length ; i ++ ) { set . add ( words [ i ] ); } return set ; } //Zusatz: Erstellen Sie f\u00fcr die Liste eine Methode public static List<String> findDoublets(List<String> list). //Diese Methode erstellt eine Liste, in der alle Elemente enthalten sind, die in list doppelt vorkommen. //Diese Elemente werden dann auch doppelt in die Resultat-Liste \u00fcbernommen. //Geben Sie diese Liste mithilfe der printList()-Methode in der main()-Methode aus. public static List < String > findDoublets ( List < String > list ) { //Grundidee //Beispiel-Liste: \"a\" \"b\" \"a\" \"c\" \"a\" //Index: 0 1 2 3 4 //Inhalt: a b a c a //erster Index von \"a\": 0 //letzter Index von \"a\":4 //0 != 4 -> es gibt Duplikate //erster Index von \"b\":1 //letzter Index von \"b\":1 //1 == 1 -> keine Duplikate, also diesen Eintrag als Einzeleintrag merken //... //leere Liste \"singles\" f\u00fcr Einzeleintr\u00e4ge anlegen List < String > singles = new ArrayList <> (); //durch list iterieren und testen ob das Element Duplikate hat, //wenn nicht in \"singles\" speichern Iterator < String > it = list . iterator (); //it = copy.iterator(); while ( it . hasNext ()) { String s = it . next (); if ( list . indexOf ( s ) == list . lastIndexOf ( s )) singles . add ( s ); } //Kopie von list anlegen List < String > copy = new ArrayList <> (); it = list . iterator (); while ( it . hasNext ()) copy . add ( it . next ()); //alle singles aus der kopierten Liste entfernen copy . removeAll ( singles ); return copy ; //um zu testen, warum die Kopie n\u00f6tig ist: //copy.removeAll(singles); und return copy; ersetzen durch //list.removeAll(singles); //return list; //und dann die Ausgabe von l2 in der main anschauen } public static void main ( String [] args ) { String [] words = { \"Linux\" , \"Apple\" , \"Facebook\" , \"Amazon\" , \"IBM\" , \"Lenovo\" , \"Google\" , \"IBM\" , \"Microsoft\" , \"Apple\" , \"Google\" , \"Twitter\" , \"Skype\" , \"Chrome\" , \"Linux\" , \"Firefox\" }; System . out . println ( \"---------- A ----------\" ); //A3. Erstellen Sie in der main()-Methode mithilfe der Methode createArrayList(words) eine //Liste und speichern Sie diese Liste in einer Variablen vom Typ List<String>. List < String > l1 = createArrayList ( words ); //Geben Sie alle Elemente dieser Liste mithilfe der Methode printList() auf der Konsole aus. printList ( l1 ); //A4. Ermitteln Sie den Index in der Liste, in der \"Apple\" das erste Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des ersten Auftretens von Apple : 1 System . out . println ( \"Index des ersten Auftretens von Apple: \" + l1 . indexOf ( \"Apple\" )); //Ermitteln Sie den Index in der Liste, in der \"Apple\" das letzte Mal auftaucht. //Erzeugen Sie folgende Ausgabe: Index des letzten Auftretens von Apple : 9 System . out . println ( \"Index des letzten Auftretens von Apple: \" + l1 . lastIndexOf ( \"Apple\" )); //Geben Sie den Wert des ersten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: erstes Element der Liste : Linux System . out . println ( \"erstes Element der Liste: \" + l1 . get ( 0 )); //Geben Sie den Wert des letzten Elementes der Liste aus. //Erzeugen Sie folgende Ausgabe: letztes Element der Liste : Firefox System . out . println ( \"letztes Element der Liste: \" + l1 . get ( l1 . size () - 1 )); //L\u00f6schen Sie die Werte \"Apple\", \"Google\" und \"Facebook\". //Geben Sie die Liste erneut mithilfe der printList(list)-Methode aus. //1. M\u00f6glichkeit: nur 1. Vorkommen l\u00f6schen l1 . remove ( \"Apple\" ); l1 . remove ( \"Google\" ); l1 . remove ( \"Facebook\" ); printList ( l1 ); //2. M\u00f6glichkeit: alle l\u00f6schen while ( l1 . remove ( \"Apple\" )); while ( l1 . remove ( \"Google\" )); while ( l1 . remove ( \"Facebook\" )); printList ( l1 ); System . out . println ( \"---------- B ----------\" ); System . out . println ( \"-------HashSet------\" ); //B3. Erstellen Sie in der main()-Methode mithilfe der Methode createHashSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen vom Typ Set<String>. Set < String > h1 = createHashSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Anzahl der Elemente im Vergleich zur Anzahl der Elemente //in der Liste? Warum ist das so? printSet ( h1 ); System . out . println ( \"-------TreeSet------\" ); //B5. Erstellen Sie in der main()-Methode mithilfe der Methode createTreeSet(words) //eine Menge und speichern Sie diese Menge in einer Variablen. Set < String > t1 = createTreeSet ( words ); //Geben Sie alle Elemente dieser Menge mithilfe der Methode printSet() auf der Konsole aus. //Was beobachten Sie in Bezug auf die Sortierung der Elemente im Vergleich zur HashSet? printSet ( t1 ); System . out . println ( \"-------Duplicates------\" ); List < String > l2 = createArrayList ( words ); List < String > d = findDoublets ( l2 ); printList ( d ); printList ( l2 ); } }","title":"\u00dcbung 5 (Listen und Mengen)"},{"location":"uebungen/#ubung-6-wrapper-klassen-und-maps","text":"\u00dcbung 6 Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: String name; List<Integer> bevoelkerung; float flaeche; Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor public Stadt(String name, List<Integer> bevoelkerung, float flaeche) , der die Objektvariablen initialisiert. Erstellen Sie f\u00fcr die Klasse Stadt eine print() -Methode, so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Erstellen Sie eine Klasse StadtTest mit main() -Methode. Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } Liste Erstellen Sie in der main() -Methode eine List<Stadt> staedteListe = new ArrayList<>(); . F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Menge Erstellen Sie in der main() -Methode eine Set<Stadt> staedteMenge = new HashSet<>(); . F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array zu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? Stadt - Teil 2 Implementieren Sie in der Klasse Stadt die equals(Object) - und die hashCode() -Methode. F\u00fchren Sie danach die StadtTest -Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? Maps Erstellen Sie in der main() -Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>(); . F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer -Wert beginnend mit 1 als Key sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte() -Methode erzeugtem Array als Value hinzu. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print() -Methode aus der Klasse Stadt aus. Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys . Ausgaben ------------ Liste -------------- Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 ------------ Menge -------------- Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 ------------ Maps -------------- 1 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 2 Hamburg 755 ,22 km2 1 .715.392 1 .786.448 1 .810.438 3 Muenchen 310 ,70 km2 1 .210.223 1 .353.186 1 .464.301 4 Koeln 405 ,02 km2 962 .884 1 .007.119 1 .075.935 5 Frankfurt/Main 248 ,31 km2 648 .550 679 .664 736 .414 6 Berlin 891 ,68 km2 3 .382.169 3 .460.725 3 .574.830 die von Frau Busjahn vorkommentierten Klassen Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Da es sich um einen Konstruktor einer Kindklasse handelt, sollte zuerst explizit der Konstruktor der Elternklasse aufrufen werden //kann aber wie implements erst sp\u00e4ter erg\u00e4nzt werden //Objektvariablen initialisieren this . ??? = ??? ; ... } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 //import //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n------------ Liste --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n------------ Menge --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? System . out . printf ( \"%n------------ Maps --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte } } Video zu \u00dcbung 6 (Wrapper-Klassen und Maps) m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 (aus dem Video - mit compareTo - den Teil mit TreeSet und compareTo m\u00fcssen Sie aber nicht beachten, kommt n\u00e4chste Woche) Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 package uebungen.uebung6 ; import java.util.* ; //import //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt implements Comparable //Der Teil mit \"implements\" wird nicht von Anfang an ben\u00f6tigt, es kann also auch erstmal mit \"public class Stadt\" begonnen werden. //W\u00e4hrend es bei primitiven Datentypen meist eindeutig ist, ob ein Wert gr\u00f6\u00dfer, kleiner oder gleich gro\u00df ist wie ein anderer Wert, ist die Ordnung bei Objekten nicht so klar. //Daher muss Stadt Klasse ein bestimmtes Interface implementieren, um festzulegen, was verglichen werden soll. { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Da es sich um einen Konstruktor einer Kindklasse handelt, sollte zuerst explizit der Konstruktor der Elternklasse aufrufen werden //kann aber wie implements erst sp\u00e4ter erg\u00e4nzt werden //Objektvariablen initialisieren this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben //mithilfe einer Schleife oder Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben //Beispiel f\u00fcr Schleife: //https://freiheit.f4.htw-berlin.de/prog2/collections/#die-for-each-schleife //Beispiel f\u00fcr Iterator: //https://freiheit.f4.htw-berlin.de/prog2/collections/#listen System . out . printf ( \"%-15s %9.2f km2 \" , this . name , this . flaeche ); for ( Integer el : this . bevoelkerung ) { System . out . printf ( \"%,10d\" , el ); } System . out . println (); } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? //Kommentieren Sie hashCode() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? //Kommentieren Sie equals() wieder aus und f\u00fchren StadtTest erneut aus. Was \u00e4ndert sich? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der Name des \u00fcbergebenen Stadt-Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck if ( o == null ) return false ; if ( this == o ) return true ; if ( this . getClass () != o . getClass ()) return false ; //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben Stadt stadt = ( Stadt ) o ; return this . name . equals ( stadt . name ); } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben return this . name . hashCode (); } //Festlegen, dass der Name des \u00fcbergebenen Stadt-Objekts o mit dem Namen des aktuellen Stadt-Objekts verglichen werden soll @Override public int compareTo ( Object o ) { Stadt stadt = ( Stadt ) o ; return this . name . compareTo ( stadt . name ); } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 package uebungen.uebung6 ; //import import java.util.* ; //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { System . out . printf ( \"%n%n------------------------- Liste -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen Stadt [] staedte = staedte (); for ( Stadt stadt : staedte ) { staedteListe . add ( stadt ); } //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. for ( Stadt stadt : staedteListe ) { stadt . print (); } //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen System . out . printf ( \"%n%n------------------------- Menge -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge1 = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. for ( Stadt stadt : staedte ()) { staedteMenge1 . add ( stadt ); } //analog zur gleichen Aufgabe mit der Liste oben //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. //analog zur gleichen Aufgabe mit der Liste oben for ( Stadt stadt : staedteMenge1 ) { stadt . print (); } //Berlin erscheint doppelt, obwohl eine Menge keine doppelten Elemente enthalten darf. Warum? //Notieren Sie sich die Reihenfolge, in der St\u00e4dte ausgegeben werden. //\u00c4ndern Sie den Konstruktor von HashSet<>() in TreeSet<>(). Was passiert und warum? Set < Stadt > staedteMenge2 = new TreeSet <> (); //analog zu oben System . out . printf ( \"%n%n------------------------- Maps -------------------------%n%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); Integer number = 1 ; for ( Stadt stadt : staedte ()) { staedteMap . put ( number , stadt ); number ++ ; } // Stadt berlin = staedte[0]; // staedteMap.put(2, berlin); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. for ( Map . Entry < Integer , Stadt > eintrag : staedteMap . entrySet ()) { System . out . printf ( \"%-3d\" , eintrag . getKey ()); Stadt stadt = eintrag . getValue (); stadt . print (); } //Beispiel, wie man eine Map durchgeht: https://freiheit.f4.htw-berlin.de/prog2/maps/#durch-eine-map-laufen //erst den key ausgeben //dann die Werte System . out . printf ( \"%n%n------------------------- Test compareTo -------------------------%n%n\" ); System . out . println ( \"Berlin\" . compareTo ( \"Anton\" )); System . out . println ( \"Anton\" . compareTo ( \"Berlin\" )); System . out . println ( \"Berlin\" . compareTo ( \"Berlin\" )); System . out . println ( \"Anton\" . compareTo ( \"Zeppelin\" )); } } eine andere m\u00f6gliche L\u00f6sung f\u00fcr \u00dcbung 6 (aus der \u00dcbung von Frau Busjahn) Stadt.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package prog2_uebungen ; import java.util.* ; //1. Erstellen Sie eine Klasse Stadt mit folgenden Objektvariablen: public class Stadt { String name ; List < Integer > bevoelkerung ; float flaeche ; //2. Erstellen Sie f\u00fcr die Klasse Stadt einen parametrisierten Konstruktor //public Stadt(String name, List<Integer> bevoelkerung, float flaeche), //der die Objektvariablen initialisiert. public Stadt ( String name , List < Integer > bevoelkerung , float flaeche ) { //Objektvariablen initialisieren this . name = name ; this . bevoelkerung = bevoelkerung ; this . flaeche = flaeche ; } //3. Erstellen Sie f\u00fcr die Klasse Stadt eine print()-Methode, //so dass eine Ausgabe auf der Konsole in folgender Form erscheint (Bsp.): //Berlin 891,68 km2 3.382.169 3.460.725 3.574.830 void print () { //Namen der Stadt, ihre Fl\u00e4che und \"km2\" ausgeben System . out . print ( name + \" \" + flaeche + \" km2 \" ); //mithilfe eines Iterator Eintr\u00e4ge der Bev\u00f6lkerungs-Liste ausgeben Iterator < Integer > it = bevoelkerung . iterator (); while ( it . hasNext ()) { System . out . print ( it . next () + \" \" ); } //Alternative mit Schleife // for(Integer i : bevoelkerung) // { // System.out.print(i + \" \"); // } System . out . println (); } //Teil 2 //1. Implementieren Sie in der Klasse Stadt die equals(Object)- und die hashCode()-Methode. //F\u00fchren Sie danach die StadtTest-Klasse erneut aus. Was hat sich an der Menge ge\u00e4ndert? @Override public boolean equals ( Object o ) { //Es soll getestet werden, ob der St\u00e4dtename des \u00fcbergebenen Objekts o gleich dem Namen des aktuellen Stadt-Objekts ist //Vorher m\u00fcssen erst ein paar F\u00e4lle abgekl\u00e4rt werden: // wenn \u00fcbergebenes Objekt o null ist, gib false zur\u00fcck if ( o == null ) return false ; // wenn \u00fcbergebenes Objekt o gleich dem aktuellen Objekt der Klasse ist, gib true zur\u00fcck, // da die St\u00e4dtenamen dann auf jeden Fall auch gleich sind if ( o == this ) return true ; // wenn die Laufzeitklasse des \u00fcbergebenen Objekts o nicht gleich der Laufzeitklasse des aktuellen Objekts ist, // gib false zur\u00fcck if ( o . getClass () != this . getClass ()) return false ; //Wenn diese drei F\u00e4lle nicht eingetreten sind: //Stadt-Objekt anlegen vom \u00fcbergebenen Objekt o Stadt other = ( Stadt ) o ; //testen ob der Name des \u00fcbergebenen Stadt-Objekts gleich dem Namen des aktuellen Stadt-Objekts ist //Ergebnis zur\u00fcckgeben return ( this . name . equals ( other . name )); } @Override public int hashCode () { //Hashcode des Stadtnamens zur\u00fcckgeben return this . name . hashCode (); } } StadtTest.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 package prog2_uebungen ; import java.util.* ; //4. Erstellen Sie eine Klasse StadtTest mit main()-Methode. //Kopieren Sie in die Klasse die Methode public static Stadt[] staedte() hinein: public class StadtTest { public static Stadt [] staedte () { Stadt [] staedte = new Stadt [ 6 ] ; List < Integer > berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 0 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); List < Integer > hamburgBevoelkerung = new ArrayList <> (); hamburgBevoelkerung . add ( 1715392 ); hamburgBevoelkerung . add ( 1786448 ); hamburgBevoelkerung . add ( 1810438 ); staedte [ 1 ] = new Stadt ( \"Hamburg\" , hamburgBevoelkerung , 755.22f ); List < Integer > muenchenBevoelkerung = new ArrayList <> (); muenchenBevoelkerung . add ( 1210223 ); muenchenBevoelkerung . add ( 1353186 ); muenchenBevoelkerung . add ( 1464301 ); staedte [ 2 ] = new Stadt ( \"Muenchen\" , muenchenBevoelkerung , 310.70f ); List < Integer > koelnBevoelkerung = new ArrayList <> (); koelnBevoelkerung . add ( 962884 ); koelnBevoelkerung . add ( 1007119 ); koelnBevoelkerung . add ( 1075935 ); staedte [ 3 ] = new Stadt ( \"Koeln\" , koelnBevoelkerung , 405.02f ); List < Integer > frankfurtBevoelkerung = new ArrayList <> (); frankfurtBevoelkerung . add ( 648550 ); frankfurtBevoelkerung . add ( 679664 ); frankfurtBevoelkerung . add ( 736414 ); staedte [ 4 ] = new Stadt ( \"Frankfurt/Main\" , frankfurtBevoelkerung , 248.31f ); berlinBevoelkerung = new ArrayList <> (); berlinBevoelkerung . add ( 3382169 ); berlinBevoelkerung . add ( 3460725 ); berlinBevoelkerung . add ( 3574830 ); staedte [ 5 ] = new Stadt ( \"Berlin\" , berlinBevoelkerung , 891.68f ); return staedte ; } public static void main ( String [] args ) { //staedte() genauer anschauen System . out . printf ( \"%n------------ R\u00fcckgabe von staedte() --------------%n\" ); Stadt [] staedteArray = staedte (); for ( int i = 0 ; i < staedteArray . length ; i ++ ) { Stadt s = staedteArray [ i ] ; System . out . println ( s . name + \" \" + s . flaeche + \" \" + s . bevoelkerung ); } System . out . printf ( \"%n------------ Liste --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine List<Stadt> staedteListe = new ArrayList<>();. //F\u00fcgen Sie der staedteListe alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. List < Stadt > staedteListe = new ArrayList <> (); //durch staedte iterieren und die St\u00e4dte zur staedteListe hinzuf\u00fcgen for ( Stadt s : staedte ()) { staedteListe . add ( s ); } //Alternative: //for (Stadt s : staedteArray) { // staedteListe.add(s); //} //2. Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung //der print()-Methode aus der Klasse Stadt aus. //durch staedteListe iterieren und f\u00fcr jeden Eintrag die print()-Methode aufrufen for ( Stadt s : staedteListe ) { s . print (); } System . out . printf ( \"%n------------ Menge --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Set<Stadt> staedteMenge = new HashSet<>();. Set < Stadt > staedteMenge = new HashSet <> (); //F\u00fcgen Sie der staedteMenge alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array zu. for ( Stadt s : staedte ()) { staedteMenge . add ( s ); } //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der //print()-Methode aus der Klasse Stadt aus. for ( Stadt s : staedteMenge ) { s . print (); } System . out . printf ( \"%n------------ Maps --------------%n\" ); //1. Erstellen Sie in der main()-Methode eine Map<Integer, Stadt> staedteMap = new HashMap<>();. Map < Integer , Stadt > staedteMap = new HashMap <> (); //F\u00fcgen Sie der staedteMap einen fortlaufenden, eindeutigen Integer-Wert beginnend mit 1 als Key //sowie alle alle St\u00e4dte aus dem durch Aufruf der staedte()-Methode erzeugtem Array als Value hinzu. Integer i = 1 ; //int i = 1; ginge auch, w\u00fcrde dann beim Einf\u00fcgen automtisch zu Integer umgewandelt (Auto-Boxing) for ( Stadt s : staedte ()) { staedteMap . put ( i ++ , s ); } //Geben Sie alle Informationen \u00fcber alle St\u00e4dte aus der Liste unter Verwendung der print()-Methode aus der Klasse Stadt aus. //Beginnen Sie die Zeile jeweils mit der Ausgabe des Keys. for ( Map . Entry < Integer , Stadt > eintrag : staedteMap . entrySet ()) { System . out . print ( eintrag . getKey () + \": \" ); eintrag . getValue (). print (); } } }","title":"\u00dcbung 6 (Wrapper-Klassen und Maps)"},{"location":"uebungen/#zusatz","text":"","title":"Zusatz"},{"location":"uebungen/#test-driven-development","text":"parseDouble(String) In der Aufgabe 2 sollen Sie f\u00fcr die Klasse MyInteger eine Methode parseInt(String s) schreiben, die einen String s in eine int -Zahl umwandelt, wenn dies m\u00f6glich ist. In dieser \u00dcbung wollen wir eine solche (statische) Methode parseDouble(String s) f\u00fcr eine Klasse MyDouble testgetrieben entwickeln. \u00dcberlegen Sie sich dazu einige Strings, die Sie umwandeln wollen und die dazugeh\u00f6rigen erwarteten Ergebnisse. Es muss nicht vollst\u00e4ndig implementiert werden. Es geht ums Prinzip. Mithilfe von assertThrows() k\u00f6nnen Sie \u00fcbrigens pr\u00fcfen, ob eine Exception geworfen wird (wenn s keiner Zahl entspricht) - siehe dazu z.B. hier oder hier . Viel Spa\u00df!","title":"Test-driven development"},{"location":"wiederholung/","text":"Wiederholung \u00b6 Datentypen \u00b6 Wertetypen \u00b6 es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!! Referenztypen \u00b6 es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? } Datenstrukturen \u00b6 Variablen \u00b6 einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden Arrays \u00b6 Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0 Literale \u00b6 sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5 Ausdr\u00fccke \u00b6 kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, . Anweisungen \u00b6 Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; } Methoden \u00b6 wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); } Vererbung \u00b6 Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererebung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden Konstruktoren \u00b6 besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 } Access Controller (Zugriffsmodifizierer) \u00b6 Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse","title":"Wiederholung"},{"location":"wiederholung/#wiederholung","text":"","title":"Wiederholung"},{"location":"wiederholung/#datentypen","text":"","title":"Datentypen"},{"location":"wiederholung/#wertetypen","text":"es wird der konkrete Wert in der Variablen gespeichert belegen abh\u00e4ngig vom Datentyp unterschiedlich viel Arbeitsspeicher \u2192 unterschiedliche Wertebereiche Beispiele Wertetypen // boolean f\u00fcr Wahrheitswerte true und false boolean x = false ; // mit false initialisiert boolean wahr = true ; // Schluesselwort true boolean falsch = ! wahr ; // Enthaelt den Wert false // byte, short, int, long f\u00fcr ganze Zahlen byte a = 0 ; // mit 0 initialisiert short b = 124 ; // Zuweisung einer ganzen Zahl int c = a + b ; // Wertebereich immer beachten! long lo = c * 200 ; // l nicht als Variablenname verwenden // char f\u00fcr ein einzelnes Zeichen - einfache Anfuehrungszeichen! char zeichen = 'c' ; // Doppelte \" f\u00fcr Strings! // float und double f\u00fcr Flie\u00dfkommazahlen float f = 0.0f ; // Wird mit 0.0 initialisiert double d = 100.25 ; // Dezimalpunkt statt Dezimalkomma!!","title":"Wertetypen"},{"location":"wiederholung/#referenztypen","text":"es wird eine Referenz auf ein Objekt gespeichert Objekte besitzen Eigenschaften: Methoden (Verhalten) und Variablen (Zustand) Zugriff auf Methoden und Variablen \u00fcber den Punkt-Operator Beispiele Referenztypen // Schluesselwort class um neue Klasse (Typ) zu definieren public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher // Objektmethode public void print () { System . out . println ( this . base + \"^\" + this . exp ); } } // irgendwo im Hauptprogramm public static void main ( String [] args ) { Power p1 = new Power ( 2 , 4 ); Power p2 = new Power ( 2 , 4 ); p1 . print (); p2 . print (); boolean equal = ( p1 == p2 ); // true oder false ? }","title":"Referenztypen"},{"location":"wiederholung/#datenstrukturen","text":"","title":"Datenstrukturen"},{"location":"wiederholung/#variablen","text":"einfachste Datenstruktur \u2192 speichern genau einen Wert (kann auch Referenz auf ein Objekt sein) sind von einem Datentyp (Wertetyp oder Referenztyp) haben einen Namen besitzen einen Wert Wert kann sich bei Variablen zur Laufzeit \u00e4ndern (Wertzuweisungsoperator =) Wert von Konstanten kann nicht mehr ge\u00e4ndert werden (final) besitzen einen G\u00fcltigkeitsbereich (den sogenannten Scope) Scope einer Variable: der Anweisungsblock, in dem die Variable deklariert wurde lokale Variable: in einer Methode deklariert \u2192 dort lokal globale Variable: in einer Klasse deklariert \u2192 dort global Beispiele Variablen int zahlen = 0 ; // konventionelle Variable final float PI = 3.14516f ; // Konstante // Erzeugen eines neuen Feldes (Arrays) und Zuweisen der Referenz int [] zahlenFeld = new int [ 100 ] ; // Klassen mit Objekt- und Klassenvariablen public class Power { int base ; // Objektvariablen, f\u00fcr jedes Objekt int exp ; // existieren Kopien im Arbeitsspeicher public String toString () { // lokale Variable --> nur in der Methode gueltig String output = this . base + \"^\" + this . exp ; return output ; } // Variablen sollten mit einem Kleinbuchstaben beginnen // Konstanten sollten nur mit Gro\u00dfbuchstaben benannt werden","title":"Variablen"},{"location":"wiederholung/#arrays","text":"Arrays sind Objekte (Referenztypen) speichern eine festgelegte Anzahl von Werten eines festgelegten Datentyps (k\u00f6nnen Werte- und Referenztypen sein) besitzen Methoden (z.B. sort() ) und Variablen (z.B. length ) k\u00f6nnen auch mehrdimensional sein Zugriff auf Elemente mit eckigen Klammern unter Verwndung des Indexes Beispiele Arrays // Einfache Deklaration -> nur Datentyp bekannt, keine Laenge int [] zahlen ; // Eckige Klammern f\u00fcr Array-Datentyp // Erzeugen eines neuen Feldes und Zuweisen der Referenz zahlen = new int [ 100 ] ; // new-Operator, hier: Angabe der Laenge // Explizite Initialisierung bei der Deklaration // Bei Initialisiert mit Werten --> keine Laengenangabe noetig float [] werte = new float [ 10 ] ; // Platz f\u00fcr 10 Werte double [] fib = { 1.0 , 2.0 , 3.0 }; // Werte in {}-Klammern // Mehrdimensionale Felder int [][] hdBild = new int [ 1920 ][ 1080 ] ; // Felder k\u00f6nnen f\u00fcr alle Datentypen verwendet werden Power [] potenzen = new Power [ 5 ] ; // Noch keine Objekte enthalten potenzen [ 0 ] = new Power ( 2 , 4 ); // Zuweisung Objekt an Index 0","title":"Arrays"},{"location":"wiederholung/#literale","text":"sind Werte sind von einem bestimmten Datentyp (kann auch ein Referenztyp sein) keine ausf\u00fchrbare Einheit \u2192 kein Ausdruck \u2192 k\u00f6nnen nicht alleine stehen meistens auf der rechten Seite einer Wertzuweisung als Parameterwert bei Aufruf einer Methode als Vergleichswert bei logischen Ausdr\u00fccken Beispiele Literale 100 true 'a' \"hallo\" { 1 , 2 , 3 , 4 } 5.5","title":"Literale"},{"location":"wiederholung/#ausdrucke","text":"kleinste ausf\u00fchrbare Einheit eines Programms z.B.: Zuweisung numerische Berechnung logische Bedingung Operatoren: arithmetisch: +, -, *, /, %, ++, -- relational: ==, !=, <, >, <=, >= logisch: !, &&, || Zuweisung: =, +=, -=, *=, /=, %= sonstige: a?b:c, typecast, new, instanceof, .","title":"Ausdr\u00fccke"},{"location":"wiederholung/#anweisungen","text":"Einzelanweisung ; Block {} Deklaration Typ Methode , Typ Variable Ausdruck Bedingung if() else switch() case Schleifen for while do while Exceptions try catch() Assertions assert Beispiele Anweisungen // Bloecke immer zwischen geschweiften Klammern { // Anweisung 1... // Anweisung 2... } // Definition und Deklaration int a ; float b = 1.0f ; // Einfacher Ausdruck a = 1010 ; // Bedingungen if ( a == 1010 ) // if-Zweig muss immer vorhanden sein { // Anweisungen... } else if ( a == 1011 ) // 0 - beliebig viele else-if-Zweige { // Anweisungen... } else // 0 - 1 else-Zweig { // Anweisungen... } switch ( a ) // zu pruefende Variable in Klammern { case 1010 : { b *= 2.0 ; break ; } // beliebig viele case-Zweige case 1011 : { b *= 3.0 ; break ; } // break nicht vergessen default : { b = 0.0f ; } // Zweig f\u00fcr alle anderen Werte } int [] meinFeld = { 1 , 2 , 3 , 4 , 5 }; // for-Schleife // 1. Initialisierung // 2. Schleifen-Bedingung // 3. Anweisungen nach Schleifendurchlauf // Schleifen-Anweisungen als Block hinter for for ( int index = 0 ; index < meinFeld . length ; index ++ ) { System . out . println ( meinFeld [ index ] ); } // while-Schleife // Nur Schleifen-Bedingung angeben // Auf Endlos-Schleifen achten while ( index < meinFeld . length ) { System . out . println ( meinFeld [ index ] ); index ++ ; }","title":"Anweisungen"},{"location":"wiederholung/#methoden","text":"wiederverwendbare und/oder logisch abgeschlossene Programmteile sollten in Methoden zusammengefasst werden Methoden besitzen einen Namen (im Scope eindeutig), keinen, einen oder mehrere Parameter und einen R\u00fcckgabetyp (evtl. void ) Aufruf einer Methode durch Namen und runde Klammern, in welche Werte f\u00fcr die Parameter \u00fcbergeben werden bei Aufruf einer Methode werden alle Anweisungen abgearbeitet, die in der Methode definiert (implementiert) wurden (bis zum return ) werden Methoden mit R\u00fcckgabetyp (also nicht void ) aufgerufen, entspricht ihr Aufruf einem konkreten Wert (R\u00fcckgabewert) Methodenstack/Call stack public static int multiply ( int a , int b ) { return a * b ; } public static int square ( int n ) { return multiply ( n , n ); } public static void printSquare ( int n ) { int squared = square ( n ); System . out . println ( n + \" x \" + n + \" = \" + squared ); } public static void main ( String [] args ) { printSquare ( 4 ); }","title":"Methoden"},{"location":"wiederholung/#vererbung","text":"Weitergabe aller Methoden und Objekte einer Elternklasse (Basisklasse) an eine Kindklasse (Subklasse) Schl\u00fcsselwort extends jede Klasse (bis auf Object ) besitzt genau eine Elternklasse; ist keine angegeben, ist es automatisch Object Vererebung beschreibt \u201eis-a\u201c-Beziehung Methoden der Elternklasse k\u00f6nnen \u00fcberschrieben werden (wenn sie nicht als final definiert wurden) \u2192 @Override verwenden Originalmethode kann mit Schl\u00fcsselwort super aufgerufen werden","title":"Vererbung"},{"location":"wiederholung/#konstruktoren","text":"besondere Objektmethoden, die beim Erzeugen des Objektes aufgerufen werden gleicher Name wie die Klasse, keinen R\u00fcckgabetyp angeben (auch nicht void ) wird kein Konstruktor definiert, steht automatisch (implizit) ein parameterloser Konstruktor zur Verf\u00fcgung (einzige Ausnahme: in der Elternklasse existieren nur parametrisierte Konstruktoren) Aufruf von this und super m\u00f6glich werden nicht vererbt Beispiele Konstruktoren public class Power { int base ; int exp ; public Power () { this ( 1 , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base ) { this ( base , 0 ); // Aufruf des Konstruktors in Zeile 15 } public Power ( int base , int exp ) { this . base = base ; // Parameterwerte f\u00fcr base und int this . exp = exp ; // auf Objektvariablen sichern } } public static void main ( String [] args ) { Power p1 = new Power (); // p1.base = 1, p1.exp = 0 Power p2 = new Power ( 10 ); // p2.base = 10, p2.exp = 0 Power p3 = new Power ( 10 , 5 ); // p3.base = 10, p3.exp = 5 }","title":"Konstruktoren"},{"location":"wiederholung/#access-controller-zugriffsmodifizierer","text":"Steuerung der Lebensdauer, Sichtbarkeit und Ver\u00e4nderbarkeit von Klassen, Methoden und Variablen \u2013 Prinzip der Datenkapselung Klassen public Zugriff von au\u00dferhalb des Paketes (default) Zugriff nur innerhalb des Paketes final von der Klasse k\u00f6nnen keine Klassen erben abstract Klasse besitzt Methoden, die keinen Methodenrumpf besitzen (nicht implementiert sind) Variablen und Methoden (wenn Klasse public ) public Zugriff von \u00fcberall (bei Variablen vermeiden!) protected Zugriff aus Klasse und Kindklasse (default) Zugriff aus Klasse und Paket private Zugriff nur aus Klasse","title":"Access Controller (Zugriffsmodifizierer)"},{"location":"wrapper/","text":"Wrapper-Klassen \u00b6 In Collections lassen sich nur Elemente speichern, die von einem Referenztyp sind. Das hei\u00dft es k\u00f6nnen keine Werte vom Typ int , boolean , double , char , long usw. speichern. Wenn wir z.B. versuchen, eine Liste mit int zu typisieren List < int > l = new ArrayList <> (); // Fehler !! bekommen wir einen Fehler angezeigt und k\u00f6nnen das Programm gar nicht compilieren. Trotzdem wollen wir nat\u00fcrlich auch solche \"Werte\" in Collections verwalten. Dazu existieren f\u00fcr alle Wertetypen entsprechende Referenztypen, sogenannte Wrapper-Klassen . Diese sind Integer , Double , Float , Short , Byte , Long , Character und Boolean und befinden sich im java.lang -Paket (also dem Standardpaket von Java - muss nicht importiert werden). Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" ( wrappen ) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel int \u2194 Integer verdeutlichen: Der int -Wert 10 wird zu einem Typ Integer und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von boolean , byte , short , long , float und double so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von char Character und die Wrapper-Klasse von int Integer . Wertetyp Referenztyp (Wrapper-Klasse) byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character Objekterzeugung \u00b6 Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen: Verwendung des Kontruktors, Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, Verwendung der statischen Methode valueOf() , Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, sogenanntes Boxing (autmatisches wrappen eins Wertes in seinen Referenztyp). Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von Integer an. Es gilt aber f\u00fcr alle Wrapper-Klassen. Verwendung des Kontruktors - deprecated \u00b6 F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von Integer als ein int -Wert) oder es wird ein String \u00fcbergeben, der idealerweise einen passenden Wrt ent\u00e4lt, also f\u00fcr Integer soll der String eine Zahl enthalten. Am Beispiel von Integer k\u00f6nnte das z.B. so aussehen: // Konstruktor mit Uebergabe Wertetyp int i = 100 ; Integer iObject1 = new Integer ( i ); Integer iObject2 = new Integer ( 100 ); // Konstruktor mit Uebergabe String String s = \"100\" ; Integer iObject3 = new Integer ( s ); Integer iObject4 = new Integer ( \"100\" ); // Moeglich f\u00fcr alle numerischen Datentypen und boolean F\u00fcr Character gibt es nur einen parametrisierten Konstruktor: Character\u200b(char value) . Die \u00dcbergabe eines Strings ist dort nicht m\u00f6glich. Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated , sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden valueOf() zu verwenden. Die valueOf() -Methoden \u00b6 Die valueOf() -Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften: sie sind statisch, d.h. der Aufruf erfolgt \u00fcber Klassenmane.valueOf() , sie sind sogenannte Erzeugermethoden , denn sie geben ein Objekt der Klasse zur\u00fcck Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein String \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele // Wrapper-Klassen haben die Klassenmethoden // valueOf(Wertetyp b) ... Integer iObject1 = Integer . valueOf ( 100 ); Boolean bObject1 = Boolean . valueOf ( true ); Double dObject1 = Double . valueOf ( 5.5 ); // ... oder valueOf(String s) Integer iObject2 = Integer . valueOf ( \"100\" ); Boolean bObject2 = Boolean . valueOf ( \"true\" ); Double dObject2 = Double . valueOf ( \"5.5\" ); Auch hier gilt wieder, dass f\u00fcr Character nur eine valueOf() -Methode existiert, n\u00e4mlich valueOf(char c) . Die \u00dcbergabe eines Strings ist nicht m\u00f6glich. Auto-Boxing \u00b6 Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing . Beispiele: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter Eclipse \u2192 Preferences \u2192 Java \u2192 Compiler \u2192 Errors/Warnings folgende Einstellungen: \u00dcbung Was wird ausgegeben und warum? Integer i1 = 5000 ; Integer i2 = 5000 ; System . out . println ( i1 == i2 ); Werte extrahieren \u00b6 H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher int -Wert von einem Integer -Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <wrapperTyp>Value() -Objektmethoden zur Verf\u00fcgung also: intValue() , doubleValue() , charValue() , booleanValue() usw. Betrachten wir nochmal die Beispiele von eben: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; int i1 = io1 . intValue (); // 100 boolean b1 = bo1 . booleanValue (); // true char c1 = co1 . charValue (); // 'a' double d1 = do1 . doubleValue (); // 5.5 float f1 = fo1 . floatValue (); // 2.7 long l1 = lo1 . longValue (); // 1234 Aber auch hier gibt es wieder ein Auto-Unboxing . Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <wrapperTyp>Value() -Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben: int i2 = io1 ; // 100 boolean b2 = bo1 ; // true char c2 = co1 ; // 'a' double d2 = do1 ; // 5.5 float f2 = fo1 ; // 2.7 long l2 = lo1 ; // 1234 Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. \u00dcbung Geht das und wenn ja, warum? Was wird jeweils ausgegeben? Integer i1 = 5000 ; Integer i2 = 5000 ; Integer i3 = 5001 ; System . out . println ( i1 >= i2 ); System . out . println ( i3 > i2 ); Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von Double . Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden String erzeugt werden kann, indem die statische <WrapperTyp>.parse>Wrapper-Typ> -Methode verwendet wird. Links zu den Java-Docs \u00b6 Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. Boolean Byte Character Double Float Integer Long Short \u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number . Diese enth\u00e4lt die Objektmethoden byteValue() , doubleValue() , floatValue() , intValue() , longValue() und shortValue() . Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. \u00dcbung Schauen Sie sich einmal die Java-Dokumentation der Klasse Integer an. Welche Exception kann die valueOf(String) -Methode werfen? Welche Methode aus der Klasse Integer wird durch die valueOf(String) -Methode aufgerufen?","title":"Wrapper-Klassen"},{"location":"wrapper/#wrapper-klassen","text":"In Collections lassen sich nur Elemente speichern, die von einem Referenztyp sind. Das hei\u00dft es k\u00f6nnen keine Werte vom Typ int , boolean , double , char , long usw. speichern. Wenn wir z.B. versuchen, eine Liste mit int zu typisieren List < int > l = new ArrayList <> (); // Fehler !! bekommen wir einen Fehler angezeigt und k\u00f6nnen das Programm gar nicht compilieren. Trotzdem wollen wir nat\u00fcrlich auch solche \"Werte\" in Collections verwalten. Dazu existieren f\u00fcr alle Wertetypen entsprechende Referenztypen, sogenannte Wrapper-Klassen . Diese sind Integer , Double , Float , Short , Byte , Long , Character und Boolean und befinden sich im java.lang -Paket (also dem Standardpaket von Java - muss nicht importiert werden). Die grunds\u00e4tzliche Idee von Wrapper-Klassen ist das \"Verpacken\" ( wrappen ) eines Wertetyps in einen Referenztyp. Die folgende Abbildung soll das f\u00fcr das Beispiel int \u2194 Integer verdeutlichen: Der int -Wert 10 wird zu einem Typ Integer und somit zu einem Referenztyp. Daf\u00fcr sind alle Vorteile von referenztypen nutzbar, z.B. Objektmethoden, Vererbung usw. Welche Wrapper-Klasse zu welchem Wertetyp geh\u00f6rt, wird aus dem Namen erkennbar. Leider ist das aber nicht ganz konsistent. W\u00e4hrend die Wrapper-Klassen von boolean , byte , short , long , float und double so hei\u00dfen, wie die Wertetypen, nur jeweils mit einem Gro\u00dfbuchstaben am Anfang, hei\u00dft die Wrapper-Klasse von char Character und die Wrapper-Klasse von int Integer . Wertetyp Referenztyp (Wrapper-Klasse) byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character","title":"Wrapper-Klassen"},{"location":"wrapper/#objekterzeugung","text":"Es gibt ziemlich viele M\u00f6glichkeiten, um Objekte eines Wrapper-Klassen-Typs zu erzeugen: Verwendung des Kontruktors, Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, Verwendung der statischen Methode valueOf() , Parameterwert entweder vom Typ String oder vom entsprechenden Wertetyp, sogenanntes Boxing (autmatisches wrappen eins Wertes in seinen Referenztyp). Wir schauen uns die drei M\u00f6glichkeiten am Beispiel von Integer an. Es gilt aber f\u00fcr alle Wrapper-Klassen.","title":"Objekterzeugung"},{"location":"wrapper/#verwendung-des-kontruktors-deprecated","text":"F\u00fcr jede Wrapper-Klasse stehen zwei parametrisierte Konstruktoren zur Verf\u00fcgung, entweder wird ein entsprechender Wert \u00fcbergeben (am Beispiel von Integer als ein int -Wert) oder es wird ein String \u00fcbergeben, der idealerweise einen passenden Wrt ent\u00e4lt, also f\u00fcr Integer soll der String eine Zahl enthalten. Am Beispiel von Integer k\u00f6nnte das z.B. so aussehen: // Konstruktor mit Uebergabe Wertetyp int i = 100 ; Integer iObject1 = new Integer ( i ); Integer iObject2 = new Integer ( 100 ); // Konstruktor mit Uebergabe String String s = \"100\" ; Integer iObject3 = new Integer ( s ); Integer iObject4 = new Integer ( \"100\" ); // Moeglich f\u00fcr alle numerischen Datentypen und boolean F\u00fcr Character gibt es nur einen parametrisierten Konstruktor: Character\u200b(char value) . Die \u00dcbergabe eines Strings ist dort nicht m\u00f6glich. Wichtig hier ist zu betonen, dass man die Konstruktoren jedoch nicht verwenden sollte. Das hat haupts\u00e4chlich Performance-Gr\u00fcnde, sowohl in Zeit als auch in Speicher. Seit Java 9 gelten die Konstruktoren als deprecated , sollten also nicht mehr verwendet werden. Stattdessen wird empfohlen, die statischen Methoden valueOf() zu verwenden.","title":"Verwendung des Kontruktors - deprecated"},{"location":"wrapper/#die-valueof-methoden","text":"Die valueOf() -Methoden der Wrapper-Klassen haben zwei wichtige Eigenschaften: sie sind statisch, d.h. der Aufruf erfolgt \u00fcber Klassenmane.valueOf() , sie sind sogenannte Erzeugermethoden , denn sie geben ein Objekt der Klasse zur\u00fcck Wie bei den Konstruktoren auch, k\u00f6nnen der Methode entweder ein Wert vom entsprechenden Typ oder ein String \u00fcbergeben werden, der ein Wert von dem Wertetyp enth\u00e4lt. Beispiele // Wrapper-Klassen haben die Klassenmethoden // valueOf(Wertetyp b) ... Integer iObject1 = Integer . valueOf ( 100 ); Boolean bObject1 = Boolean . valueOf ( true ); Double dObject1 = Double . valueOf ( 5.5 ); // ... oder valueOf(String s) Integer iObject2 = Integer . valueOf ( \"100\" ); Boolean bObject2 = Boolean . valueOf ( \"true\" ); Double dObject2 = Double . valueOf ( \"5.5\" ); Auch hier gilt wieder, dass f\u00fcr Character nur eine valueOf() -Methode existiert, n\u00e4mlich valueOf(char c) . Die \u00dcbergabe eines Strings ist nicht m\u00f6glich.","title":"Die valueOf()-Methoden"},{"location":"wrapper/#auto-boxing","text":"Die dritte M\u00f6glichkeit, Objekte einer Wrapper-Klasse zu erzeugen, besteht darin, den entsprechenden Wert automatisch \"wrappen\" zu lassen, das sogenannte Auto-Boxing . Beispiele: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; Wahrscheinlich wird diese Form der Objekterzeugung die von Ihnen am meisten verwendete werden. Das ist auch v\u00f6llig in Ordnung. Sie sollten sich nur dessen bewusst sein, dass dabei ein solches Auto-Boxing passiert. Es ist empfehlenswert, gerade zu Anfang, Eclipse (oder Ihre IDE) so einzustellen, dass Sie eine Warnung erhalten, wenn ein solches Auto-Boxing passiert. das hat den Vorteil, dass die dieses Vorgehen nicht aus dem Blick verlieren, sondern dass Ihnen bewusst bleibt, dass die Werte gerade in eine Referenz umgewandelt werden. W\u00e4hlen Sie dazu in Eclipse unter Eclipse \u2192 Preferences \u2192 Java \u2192 Compiler \u2192 Errors/Warnings folgende Einstellungen: \u00dcbung Was wird ausgegeben und warum? Integer i1 = 5000 ; Integer i2 = 5000 ; System . out . println ( i1 == i2 );","title":"Auto-Boxing"},{"location":"wrapper/#werte-extrahieren","text":"H\u00e4ufig wollen wir aus unseren Wrapper-Objekten wieder die \"Werte extrahieren\", also z.B. erfahren, welcher int -Wert von einem Integer -Objekt repr\u00e4sentiert wird. Um das zu tun, stellen die Wrapper-Klassen jeweils <wrapperTyp>Value() -Objektmethoden zur Verf\u00fcgung also: intValue() , doubleValue() , charValue() , booleanValue() usw. Betrachten wir nochmal die Beispiele von eben: Integer io1 = 100 ; Boolean bo1 = true ; Character co1 = 'a' ; Double do1 = 5.5 ; Float fo1 = 2.7f ; Long lo1 = 1234L ; int i1 = io1 . intValue (); // 100 boolean b1 = bo1 . booleanValue (); // true char c1 = co1 . charValue (); // 'a' double d1 = do1 . doubleValue (); // 5.5 float f1 = fo1 . floatValue (); // 2.7 long l1 = lo1 . longValue (); // 1234 Aber auch hier gibt es wieder ein Auto-Unboxing . Das hei\u00dft, es w\u00e4re auch m\u00f6glich auf die <wrapperTyp>Value() -Objektmethode zu verzichten und stattdessen einfach das hier zu schreiben: int i2 = io1 ; // 100 boolean b2 = bo1 ; // true char c2 = co1 ; // 'a' double d2 = do1 ; // 5.5 float f2 = fo1 ; // 2.7 long l2 = lo1 ; // 1234 Auch hier sollte man sich aber stets der Tatsache bewusst sein, dass ein Unboxing passiert. \u00dcbung Geht das und wenn ja, warum? Was wird jeweils ausgegeben? Integer i1 = 5000 ; Integer i2 = 5000 ; Integer i3 = 5001 ; System . out . println ( i1 >= i2 ); System . out . println ( i3 > i2 ); Die folgende Abbildung zeigt einen \u00dcberblick \u00fcber die einzelnen Konvertierungen am Beispiel von Double . Beachten Sie dabei auch, dass ein Wert direkt aus einem passenden String erzeugt werden kann, indem die statische <WrapperTyp>.parse>Wrapper-Typ> -Methode verwendet wird.","title":"Werte extrahieren"},{"location":"wrapper/#links-zu-den-java-docs","text":"Hier sind die Links zu den jeweiligen Java-Dokumentationen der Klassen aufgelistet (f\u00fcr Java 11). Ein Blick lohnt sich, da f\u00fcr die einzelnen Klassen jeweils viele Objektmethoden zur Verf\u00fcgung stehen, die Ihnen sehr n\u00fctzlich sein k\u00f6nnen. Boolean Byte Character Double Float Integer Long Short \u00dcbrigens erben die numerischen Datentypen alle von der Klasse Number . Diese enth\u00e4lt die Objektmethoden byteValue() , doubleValue() , floatValue() , intValue() , longValue() und shortValue() . Deswegen werden in allen numerischen Wrapper-Klassen auch alle diese Objektmethoden zur Verf\u00fcgung gestellt. \u00dcbung Schauen Sie sich einmal die Java-Dokumentation der Klasse Integer an. Welche Exception kann die valueOf(String) -Methode werfen? Welche Methode aus der Klasse Integer wird durch die valueOf(String) -Methode aufgerufen?","title":"Links zu den Java-Docs"}]}